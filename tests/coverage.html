
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MarketDataApp/sdk-go/client/baseRequest.go (37.1%)</option>
				
				<option value="file1">github.com/MarketDataApp/sdk-go/client/client.go (65.8%)</option>
				
				<option value="file2">github.com/MarketDataApp/sdk-go/client/client_helper.go (85.7%)</option>
				
				<option value="file3">github.com/MarketDataApp/sdk-go/client/indices_candles.go (61.8%)</option>
				
				<option value="file4">github.com/MarketDataApp/sdk-go/client/indices_quotes.go (0.0%)</option>
				
				<option value="file5">github.com/MarketDataApp/sdk-go/client/logging.go (56.8%)</option>
				
				<option value="file6">github.com/MarketDataApp/sdk-go/client/markets_status.go (42.9%)</option>
				
				<option value="file7">github.com/MarketDataApp/sdk-go/client/options_chain.go (0.0%)</option>
				
				<option value="file8">github.com/MarketDataApp/sdk-go/client/options_expirations.go (0.0%)</option>
				
				<option value="file9">github.com/MarketDataApp/sdk-go/client/options_lookup.go (0.0%)</option>
				
				<option value="file10">github.com/MarketDataApp/sdk-go/client/options_quotes.go (0.0%)</option>
				
				<option value="file11">github.com/MarketDataApp/sdk-go/client/options_strikes.go (0.0%)</option>
				
				<option value="file12">github.com/MarketDataApp/sdk-go/client/stocks_candles.go (16.1%)</option>
				
				<option value="file13">github.com/MarketDataApp/sdk-go/client/stocks_earnings.go (0.0%)</option>
				
				<option value="file14">github.com/MarketDataApp/sdk-go/client/stocks_news.go (0.0%)</option>
				
				<option value="file15">github.com/MarketDataApp/sdk-go/client/stocks_quotes.go (0.0%)</option>
				
				<option value="file16">github.com/MarketDataApp/sdk-go/client/stocks_tickers.go (54.8%)</option>
				
				<option value="file17">github.com/MarketDataApp/sdk-go/examples.go (0.0%)</option>
				
				<option value="file18">github.com/MarketDataApp/sdk-go/examples_indices.go (0.0%)</option>
				
				<option value="file19">github.com/MarketDataApp/sdk-go/examples_options.go (0.0%)</option>
				
				<option value="file20">github.com/MarketDataApp/sdk-go/examples_stocks.go (0.0%)</option>
				
				<option value="file21">github.com/MarketDataApp/sdk-go/examples_v2.go (14.5%)</option>
				
				<option value="file22">github.com/MarketDataApp/sdk-go/helpers/dates/datekeys.go (85.8%)</option>
				
				<option value="file23">github.com/MarketDataApp/sdk-go/helpers/dates/dates.go (73.4%)</option>
				
				<option value="file24">github.com/MarketDataApp/sdk-go/helpers/dates/init.go (94.1%)</option>
				
				<option value="file25">github.com/MarketDataApp/sdk-go/helpers/dates/parse.go (40.4%)</option>
				
				<option value="file26">github.com/MarketDataApp/sdk-go/helpers/dates/parseExcel.go (81.8%)</option>
				
				<option value="file27">github.com/MarketDataApp/sdk-go/helpers/dates/parseStrings.go (95.1%)</option>
				
				<option value="file28">github.com/MarketDataApp/sdk-go/helpers/dates/parseTime.go (89.7%)</option>
				
				<option value="file29">github.com/MarketDataApp/sdk-go/helpers/dates/parseTimestamps.go (66.7%)</option>
				
				<option value="file30">github.com/MarketDataApp/sdk-go/helpers/parameters/CountryParams.go (83.3%)</option>
				
				<option value="file31">github.com/MarketDataApp/sdk-go/helpers/parameters/DateKeyParams.go (80.0%)</option>
				
				<option value="file32">github.com/MarketDataApp/sdk-go/helpers/parameters/DateParams.go (78.9%)</option>
				
				<option value="file33">github.com/MarketDataApp/sdk-go/helpers/parameters/FiftyTwoWeekParams.go (0.0%)</option>
				
				<option value="file34">github.com/MarketDataApp/sdk-go/helpers/parameters/OptionParams.go (7.6%)</option>
				
				<option value="file35">github.com/MarketDataApp/sdk-go/helpers/parameters/ResolutionParams.go (80.0%)</option>
				
				<option value="file36">github.com/MarketDataApp/sdk-go/helpers/parameters/StockCandleParams.go (12.5%)</option>
				
				<option value="file37">github.com/MarketDataApp/sdk-go/helpers/parameters/StockEarningsParams.go (0.0%)</option>
				
				<option value="file38">github.com/MarketDataApp/sdk-go/helpers/parameters/SymbolParams.go (80.0%)</option>
				
				<option value="file39">github.com/MarketDataApp/sdk-go/helpers/parameters/UniversalParams.go (0.0%)</option>
				
				<option value="file40">github.com/MarketDataApp/sdk-go/helpers/parameters/UserInputParams.go (0.0%)</option>
				
				<option value="file41">github.com/MarketDataApp/sdk-go/helpers/parameters/parsing.go (83.3%)</option>
				
				<option value="file42">github.com/MarketDataApp/sdk-go/helpers/types/types.go (91.7%)</option>
				
				<option value="file43">github.com/MarketDataApp/sdk-go/main.go (0.0%)</option>
				
				<option value="file44">github.com/MarketDataApp/sdk-go/models/indices_candles.go (61.5%)</option>
				
				<option value="file45">github.com/MarketDataApp/sdk-go/models/indices_quotes.go (0.0%)</option>
				
				<option value="file46">github.com/MarketDataApp/sdk-go/models/markets_status.go (46.7%)</option>
				
				<option value="file47">github.com/MarketDataApp/sdk-go/models/options_expirations.go (0.0%)</option>
				
				<option value="file48">github.com/MarketDataApp/sdk-go/models/options_lookup.go (0.0%)</option>
				
				<option value="file49">github.com/MarketDataApp/sdk-go/models/options_quotes.go (0.0%)</option>
				
				<option value="file50">github.com/MarketDataApp/sdk-go/models/options_strikes.go (0.0%)</option>
				
				<option value="file51">github.com/MarketDataApp/sdk-go/models/stocks_candles.go (77.4%)</option>
				
				<option value="file52">github.com/MarketDataApp/sdk-go/models/stocks_earnings.go (0.0%)</option>
				
				<option value="file53">github.com/MarketDataApp/sdk-go/models/stocks_news.go (0.0%)</option>
				
				<option value="file54">github.com/MarketDataApp/sdk-go/models/stocks_quotes.go (0.0%)</option>
				
				<option value="file55">github.com/MarketDataApp/sdk-go/models/stocks_tickers.go (26.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/go-resty/resty/v2"
)

type MarketDataPacked interface {
        IsValid() bool
        Unpack() any
}

// baseRequest is a struct that represents a basic request in the Market Data Client package.
// It contains a request of type *resty.Request, a path of type string, a client of type *MarketDataClient,
// a child of type any, and an Error of type error.
type baseRequest struct {
        request *resty.Request
        path    string
        client  *MarketDataClient
        child   any
        Error   error
}

// getParams calls the getParams method of the appropriate MarketDataRequest.
func (br *baseRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov8" title="3">{
        if br == nil || br.child == nil </span><span class="cov0" title="0">{
                return []parameters.MarketDataParam{}, nil
        }</span>

        // Check if child is of type *baseRequest
        <span class="cov8" title="3">if _, ok := br.child.(*baseRequest); ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("child is of type *baseRequest, stopping recursion")
        }</span>

        <span class="cov8" title="3">if msr, ok := br.child.(*MarketStatusRequest); ok </span><span class="cov0" title="0">{
                params, err := msr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov8" title="3">if tr, ok := br.child.(*TickersRequest); ok </span><span class="cov1" title="1">{
                params, err := tr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return params, nil</span>
        }

        <span class="cov5" title="2">if scr, ok := br.child.(*StockCandlesRequest); ok </span><span class="cov1" title="1">{
                params, err := scr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return params, nil</span>
        }

        <span class="cov1" title="1">if scr, ok := br.child.(*StockCandlesRequestV2); ok </span><span class="cov0" title="0">{
                params, err := scr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov1" title="1">if sqr, ok := br.child.(*StockQuoteRequest); ok </span><span class="cov0" title="0">{
                params, err := sqr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov1" title="1">if snr, ok := br.child.(*StockNewsRequest); ok </span><span class="cov0" title="0">{
                params, err := snr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov1" title="1">if iqr, ok := br.child.(*IndexQuoteRequest); ok </span><span class="cov0" title="0">{
                params, err := iqr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov1" title="1">if ser, ok := br.child.(*StockEarningsRequest); ok </span><span class="cov0" title="0">{
                params, err := ser.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov1" title="1">if icr, ok := br.child.(*IndicesCandlesRequest); ok </span><span class="cov1" title="1">{
                params, err := icr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return params, nil</span>
        }

        <span class="cov0" title="0">if oer, ok := br.child.(*OptionsExpirationsRequest); ok </span><span class="cov0" title="0">{
                params, err := oer.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov0" title="0">if olr, ok := br.child.(*OptionLookupRequest); ok </span><span class="cov0" title="0">{
                params, err := olr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov0" title="0">if osr, ok := br.child.(*OptionsStrikesRequest); ok </span><span class="cov0" title="0">{
                params, err := osr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov0" title="0">if oqr, ok := br.child.(*OptionQuoteRequest); ok </span><span class="cov0" title="0">{
                params, err := oqr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov0" title="0">if ocr, ok := br.child.(*OptionChainRequest); ok </span><span class="cov0" title="0">{
                params, err := ocr.getParams()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return params, nil</span>
        }

        <span class="cov0" title="0">return []parameters.MarketDataParam{}, nil</span>
}

// getPath returns the path of the BaseRequest.
// It returns an error if the BaseRequest is nil.
func (br *baseRequest) getPath() (string, error) <span class="cov8" title="3">{
        if br == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("path is nil")
        }</span>
        <span class="cov8" title="3">return br.path, nil</span>
}

// getResty returns the resty.Request for the BaseRequest.
func (br *baseRequest) getResty() *resty.Request <span class="cov8" title="3">{
        return br.request
}</span>

func newBaseRequest(clients ...*MarketDataClient) *baseRequest <span class="cov10" title="4">{
        var mdClient *MarketDataClient
        var err error

        if len(clients) &gt; 0 </span><span class="cov0" title="0">{
                mdClient = clients[0]
        }</span> else<span class="cov10" title="4"> {
                mdClient, err = GetClient()
                if mdClient == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov10" title="4">baseReq := &amp;baseRequest{
                request: mdClient.R(),
                client:  mdClient,
                Error:   err,
        }

        return baseReq</span>
}

// getError returns the error of the BaseRequest.
func (br *baseRequest) getError() error <span class="cov8" title="3">{
        return br.Error
}</span>

// Raw executes the request and returns the raw resty.Response.
// An optional MarketDataClient can be passed to replace the client used in the request.
func (br *baseRequest) Raw(optionalClients ...*MarketDataClient) (*resty.Response, error) <span class="cov1" title="1">{
        if br == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("baseRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov1" title="1">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                br.client = optionalClients[0]
        }</span>

        // Check if the client is nil after potentially replacing it
        <span class="cov1" title="1">if br.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MarketDataClient is nil")
        }</span>

        <span class="cov1" title="1">response, err := br.client.GetRawResponse(br)
        return response, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package client provides a Go SDK for interacting with the Market Data API.
// It includes functionality for making API requests, handling responses,
// managing rate limits, and logging. The SDK supports various data types
// including stocks, options, and market status information.
//
// Usage:
// To use the SDK, you first need to create an instance of MarketDataClient
// using the NewClient function. This client will then be used to make
// API requests to the Market Data API.
//
// Example:
//     client := NewClient()
//     client.Debug(true) // Enable debug mode to log detailed request and response information
//     quote, err := client.StockQuotes().Symbol("AAPL").Get()
//
// Authentication:
// The SDK uses an API token for authentication. The token can be set as an
// environment variable (MARKETDATA_TOKEN) or directly in your code. However,
// storing tokens in your code is not recommended for security reasons.
//
// Rate Limiting:
// The MarketDataClient automatically tracks and manages the API's rate limits.
// You can check if the rate limit has been exceeded with the RateLimitExceeded method.
//
// Logging:
// The SDK logs all unsuccessful (400-499 and 500-599) responses to specific log files
// based on the response status code. Successful responses (200-299) are logged when
// debug mode is enabled. Logs include detailed information such as request and response
// headers, response status code, and the response body.
//
// Debug Mode:
// Debug mode can be enabled by calling the Debug method on the MarketDataClient instance.
// When enabled, the SDK will log detailed information about each request and response,
// which is useful for troubleshooting.
//
// Environment:
// The SDK can be configured to work with different environments (production, test, development)
// by setting the appropriate host URL. The default environment is production.
package client

import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/url"
        "os"
        "strconv"
        "sync"
        "time"

        "github.com/go-resty/resty/v2"
        _ "github.com/joho/godotenv/autoload"
)

var marketDataClient *MarketDataClient

const (
        Version = "0.0.5" // Version specifies the current version of the SDK.

        prodEnv = "prod" // prodEnv is the environment name for production.
        testEnv = "test" // testEnv is the environment name for testing.
        devEnv  = "dev"  // devEnv is the environment name for development.

        prodHost = "api.marketdata.app" // prodHost is the hostname for the production environment.
        testHost = "tst.marketdata.app" // testHost is the hostname for the testing environment.
        devHost  = "localhost"          // devHost is the hostname for the development environment.

        prodProtocol = "https" // prodProtocol specifies the protocol to use in the production environment.
        testProtocol = "https" // testProtocol specifies the protocol to use in the testing environment.
        devProtocol  = "http"  // devProtocol specifies the protocol to use in the development environment.
)

// MarketDataClient struct defines the structure for the MarketData client instance.
// It embeds the resty.Client to inherit the HTTP client functionalities.
// Additionally, it includes fields for managing rate limits and synchronization,
// as well as an error field for capturing any errors that occur during API calls.
// The debug field is used to control logging verbosity.
//
// Public Methods:
// - Debug(enable bool) *MarketDataClient: Enables or disables debug mode for logging detailed request and response information.
// - RateLimitExceeded() bool: Checks if the rate limit for API requests has been exceeded.

type MarketDataClient struct {
        *resty.Client              // Embedding resty.Client to utilize its HTTP client functionalities.
        RateLimitLimit     int     // RateLimitLimit represents the maximum number of requests that can be made in a rate limit window.
        RateLimitRemaining int     // RateLimitRemaining tracks the number of requests that can still be made before hitting the rate limit.
        RateLimitReset     time.Time // RateLimitReset indicates the time when the rate limit will be reset.
        mu                 sync.Mutex // mu is used to ensure thread-safe access to the client's fields.
        Error              error      // Error captures any errors that occur during the execution of API calls.
        debug              bool       // debug indicates whether debug mode is enabled, controlling the verbosity of logs.
}


// RateLimitExceeded checks if the rate limit for API requests has been exceeded.
// It returns true if the number of remaining requests is less than or equal to zero
// and the current time is before the rate limit reset time, indicating that the client
// must wait before making further requests. Otherwise, it returns false, indicating
// that the client can continue making requests.
func (c *MarketDataClient) RateLimitExceeded() bool <span class="cov5" title="3">{
        // If there are remaining requests, return false immediately.
        if c.RateLimitRemaining &gt; 0 </span><span class="cov5" title="3">{
                return false
        }</span>
        // If no remaining requests and the current time is after the rate limit reset,
        // it means the rate limit has been reset, and we can return false.
        <span class="cov0" title="0">if c.RateLimitRemaining &lt;= 0 &amp;&amp; time.Now().After(c.RateLimitReset) </span><span class="cov0" title="0">{
                return false
        }</span>
        // If no remaining requests and the current time is before the rate limit reset,
        // it means the rate limit is exceeded, and we must wait, returning true.
        <span class="cov0" title="0">if c.RateLimitRemaining &lt;= 0 &amp;&amp; time.Now().Before(c.RateLimitReset) </span><span class="cov0" title="0">{
                return true
        }</span>
        // Default case should not be reached, but return false as a safeguard.
        <span class="cov0" title="0">return false</span>
}

// addLogFromRequestResponse adds a log entry based on the request and response information.
// It redacts sensitive information from headers, extracts rate limit and ray ID from the response,
// calculates request latency, and constructs a log entry with these details.
// If debug mode is enabled, the log entry is printed in a human-readable format.
// Regardless of debug mode, the log entry is written to the log.
func (c *MarketDataClient) addLogFromRequestResponse(req *resty.Request, resp *resty.Response) <span class="cov9" title="7">{
        // Redact sensitive information from request headers.
        redactedHeaders := redactAuthorizationHeader(req.Header)
        // Extract response headers.
        resHeaders := resp.Header()
        // Attempt to extract rate limit consumed information from the response.
        rateLimitConsumed, err := getRateLimitConsumed(resp)
        if err != nil </span><span class="cov0" title="0">{
                // If an error occurs, set the client's error field and return early.
                c.Error = err
                return
        }</span>
        // Attempt to extract the ray ID from the response.
        <span class="cov9" title="7">rayID, err := getRayIDFromResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                // If an error occurs, set the client's error field and return early.
                c.Error = err
                return
        }</span>
        // Calculate the latency of the request.
        <span class="cov9" title="7">delay := getLatencyFromRequest(req)
        // Extract the status code from the response.
        status := resp.StatusCode()
        // Convert the response body to a string.
        body := string(resp.Body())

        // Create a new log entry with the gathered information.
        logEntry := AddToLog(GetLogs(), time.Now(), rayID, req.URL, rateLimitConsumed, delay, status, body, redactedHeaders, resHeaders)
        // If debug mode is enabled and the log entry is not nil, pretty print the log entry.
        if c.debug &amp;&amp; logEntry != nil </span><span class="cov0" title="0">{
                logEntry.PrettyPrint()
        }</span>
        // If the log entry is not nil, write it to the log.
        <span class="cov9" title="7">if logEntry != nil </span><span class="cov5" title="3">{
                logEntry.WriteToLog(c.debug)
        }</span>
}

// getEnvironment determines the environment the client is operating in based on the host URL.
// It parses the host URL to extract the hostname and matches it against predefined hostnames
// for production, testing, and development environments. If a match is found, it returns the
// corresponding environment name; otherwise, it defaults to "Unknown".
func (c *MarketDataClient) getEnvironment() string <span class="cov0" title="0">{
        u, err := url.Parse(c.Client.HostURL) // Parse the host URL to extract the hostname.
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing host URL: %v", err) // Log any error encountered during URL parsing.
                return "Unknown" // Default to "Unknown" if there's an error in parsing the URL.
        }</span>
        <span class="cov0" title="0">switch u.Hostname() </span>{ // Match the extracted hostname against predefined hostnames.
        case prodHost:<span class="cov0" title="0">
                return prodEnv</span> // Return the production environment name if matched.
        case testHost:<span class="cov0" title="0">
                return testEnv</span> // Return the testing environment name if matched.
        case devHost:<span class="cov0" title="0">
                return devEnv</span> // Return the development environment name if matched.
        default:<span class="cov0" title="0">
                return "Unknown"</span> // Default to "Unknown" if no matches are found.
        }
}

// String returns a formatted string representation of the MarketDataClient instance.
// It includes the client type (environment), rate limit information, and the rate limit reset time.
func (c *MarketDataClient) String() string <span class="cov0" title="0">{
        clientType := c.getEnvironment() // Determine the client's environment.
        // Format and return the string representation.
        return fmt.Sprintf("Client Type: %s, RateLimitLimit: %d, RateLimitRemaining: %d, RateLimitReset: %v", clientType, c.RateLimitLimit, c.RateLimitRemaining, c.RateLimitReset)
}</span>

// setDefaultResetTime sets the default rate limit reset time for the MarketDataClient.
// It calculates the reset time based on the current time in the Eastern Time Zone,
// defaulting to 9:30 AM on the current or next day depending on the current time.
func (c *MarketDataClient) setDefaultResetTime() <span class="cov7" title="4">{
        // Load the Eastern Time Zone location
        location, _ := time.LoadLocation("America/New_York")
        // Get the current time in the Eastern Time Zone
        now := time.Now().In(location)

        // Initialize defaultReset to 9:30 AM Eastern Time on the current day
        defaultReset := time.Date(now.Year(), now.Month(), now.Day(), 9, 30, 0, 0, location)

        // If the current time is after 9:30 AM, adjust defaultReset to 9:30 AM on the next day
        if now.After(defaultReset) </span><span class="cov7" title="4">{
                nextDay := now.AddDate(0, 0, 1) // Calculate the next day
                defaultReset = time.Date(nextDay.Year(), nextDay.Month(), nextDay.Day(), 9, 30, 0, 0, location) // Set defaultReset to 9:30 AM on the next day
        }</span>

        // Update the MarketDataClient's RateLimitReset to the calculated default reset time
        <span class="cov7" title="4">c.RateLimitReset = defaultReset</span>
}

// NewClient initializes and returns a new instance of MarketDataClient with default settings.
// It sets the default rate limit reset time, environment to production, and configures
// common headers and hooks for the HTTP client.
func NewClient() *MarketDataClient <span class="cov7" title="4">{
        // Initialize a new MarketDataClient with default resty client and debug mode disabled.
        client := &amp;MarketDataClient{
                Client: resty.New(),
                debug:  false,
        }

        // Set the default rate limit reset time.
        client.setDefaultResetTime()

        // Set the client environment to production.
        client.Environment(prodEnv)

        // Set the "User-Agent" header to include the SDK version.
        client.Client.SetHeader("User-Agent", "sdk-go/"+Version)

        // Enable tracing for the client to facilitate debugging.
        client.Client.EnableTrace()

        // Set the OnBeforeRequest hook to perform actions before sending a request.
        // Currently, this hook does not perform any actions but can be used for logging or modifying requests.
        client.Client.OnBeforeRequest(func(c *resty.Client, req *resty.Request) error </span><span class="cov9" title="7">{
                // This is a placeholder for pre-request actions such as logging the request URL.
                return nil
        }</span>)

        // Set the OnAfterResponse hook to perform actions after receiving a response.
        // This hook updates the rate limit information and logs the request and response details.
        <span class="cov7" title="4">client.Client.OnAfterResponse(func(c *resty.Client, resp *resty.Response) error </span><span class="cov9" title="7">{
                // Update the client's rate limit information based on the response headers.
                client.updateRateLimit(resp)
                // Add logs from the request and response for debugging purposes.
                client.addLogFromRequestResponse(resp.Request, resp)
                // Placeholder for additional post-response actions such as logging or processing the response.
                return nil
        }</span>)

        // Return the initialized MarketDataClient instance.
        <span class="cov7" title="4">return client</span>
}

// Debug is a method that enables or disables the debug mode of the client.
// Debug mode will result in the request and response headers being printed to
// the terminal with each request.
func (c *MarketDataClient) Debug(enable bool) *MarketDataClient <span class="cov1" title="1">{
        c.debug = enable
        return c
}</span>

// updateRateLimit updates the client's rate limit information based on the response headers.
// It extracts the rate limit values from the response headers and updates the client's rate limit fields.
func (c *MarketDataClient) updateRateLimit(resp *resty.Response) <span class="cov9" title="7">{
        // Lock the mutex before updating the shared rate limit fields to ensure thread safety.
        c.mu.Lock()
        defer c.mu.Unlock() // Ensure the mutex is unlocked after updating.

        // Extract rate limit headers from the response.
        limitHeader := resp.Header().Get("X-Api-Ratelimit-Limit")
        remainingHeader := resp.Header().Get("X-Api-Ratelimit-Remaining")
        resetHeader := resp.Header().Get("X-Api-Ratelimit-Reset")

        // Log errors if any of the required rate limit headers are missing.
        if limitHeader == "" </span><span class="cov0" title="0">{
                log.Println("Error: missing 'X-Api-Ratelimit-Limit' header")
                return
        }</span>
        <span class="cov9" title="7">if remainingHeader == "" </span><span class="cov0" title="0">{
                log.Println("Error: missing 'X-Api-Ratelimit-Remaining' header")
                return
        }</span>
        <span class="cov9" title="7">if resetHeader == "" </span><span class="cov0" title="0">{
                log.Println("Error: missing 'X-Api-Ratelimit-Reset' header")
                return
        }</span>

        // Convert the rate limit values from strings to appropriate numeric types.
        <span class="cov9" title="7">limitVal, err := strconv.Atoi(limitHeader) // Convert the limit value to an integer.
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error converting limit header to int: %v", err)
                return
        }</span>

        <span class="cov9" title="7">remainingVal, err := strconv.Atoi(remainingHeader) // Convert the remaining value to an integer.
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error converting remaining header to int: %v", err)
                return
        }</span>

        <span class="cov9" title="7">resetVal, err := strconv.ParseInt(resetHeader, 10, 64) // Convert the reset timestamp to an int64.
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error converting reset header to int64: %v", err)
                return
        }</span>

        // Update the client's rate limit fields with the new values.
        <span class="cov9" title="7">c.RateLimitLimit = limitVal
        c.RateLimitRemaining = remainingVal
        c.RateLimitReset = time.Unix(resetVal, 0)</span> // Convert the reset timestamp to a time.Time value.
}

// prepareAndExecuteRequest prepares the request based on the provided baseRequest and executes it.
// It returns the response from the server or an error if the request preparation or execution fails.
func (c *MarketDataClient) prepareAndExecuteRequest(br *baseRequest, result interface{}) (*resty.Response, error) <span class="cov5" title="3">{

        // Check for any errors in the base request.
        if err := br.getError(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if the client's rate limit has been exceeded before proceeding with the request.
        <span class="cov5" title="3">if c.RateLimitExceeded() </span><span class="cov0" title="0">{
                return nil, errors.New("rate limit exceeded")
        }</span>

        // Initialize the Resty request and set the result type if provided.
        <span class="cov5" title="3">req := br.getResty()
        if result != nil </span><span class="cov4" title="2">{
                req = req.SetResult(result)
        }</span>

        // Retrieve and parse the parameters from the base request.
        <span class="cov5" title="3">paramsSlice, err := br.getParams()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">for _, param := range paramsSlice </span><span class="cov10" title="8">{
                err := param.SetParams(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Get the path for the request.
        <span class="cov5" title="3">path, err := br.getPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute the GET request to the specified path.
        <span class="cov5" title="3">resp, err := req.Get(path)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        // Check if the response status is not successful and handle errors accordingly.
        <span class="cov5" title="3">if !resp.IsSuccess() </span><span class="cov0" title="0">{
                var result map[string]interface{}
                _ = json.Unmarshal(resp.Body(), &amp;result) // Attempt to unmarshal the response body into a map.
                if errMsg, ok := result["errmsg"]; ok </span><span class="cov0" title="0">{
                        // Return an error with the non-OK status and the error message from the response.
                        return resp, fmt.Errorf("received non-OK status: %s, error message: %v, URL: %s", resp.Status(), errMsg, resp.Request.URL)
                }</span>
                // Return an error with the non-OK status if no specific error message is found in the response.
                <span class="cov0" title="0">return resp, fmt.Errorf("received non-OK status: %s for URL: %s", resp.Status(), resp.Request.URL)</span>        }

        <span class="cov5" title="3">return resp, nil</span>
}

// GetFromRequest executes a prepared request and returns the response.
// It handles any errors that occur during the request execution and checks for errors in the response.
// If an error is found in the response, it is returned as part of the response object.
//
// Parameters:
// - br: A pointer to a baseRequest object containing the request details.
// - result: An interface where the result of the request will be stored if successful.
//
// Returns:
// - A pointer to a resty.Response object containing the response from the server.
// - An error object if an error occurred during the request execution or if the response contains an error.
func (c *MarketDataClient) GetFromRequest(br *baseRequest, result interface{}) (*resty.Response, error) <span class="cov4" title="2">{
        // Execute the prepared request and capture the response and any error.
        resp, err := c.prepareAndExecuteRequest(br, result)
        if err != nil </span><span class="cov0" title="0">{
                // Return the response and the error if an error occurred during request execution.
                return resp, err
        }</span>

        // Check if the response contains an error and return it if present.
        <span class="cov4" title="2">if resp.Error() != nil </span><span class="cov0" title="0">{
                // Handle unmarshalling error by returning the error contained in the response.
                return resp, resp.Error().(error)
        }</span>

        // Return the response and nil indicating no error occurred.
        <span class="cov4" title="2">return resp, nil</span>
}

// GetRawResponse executes a prepared request without processing the response.
// This function is useful when the caller needs the raw response for custom processing.
//
// Parameters:
// - br: A pointer to a baseRequest object containing the request details.
//
// Returns:
// - A pointer to a resty.Response object containing the raw response from the server.
// - An error object if an error occurred during the request execution.
func (c *MarketDataClient) GetRawResponse(br *baseRequest) (*resty.Response, error) <span class="cov1" title="1">{
        return c.prepareAndExecuteRequest(br, nil)
}</span>

func GetClient(token ...string) (*MarketDataClient, error) <span class="cov9" title="7">{
        if len(token) == 0 </span><span class="cov7" title="5">{
                if marketDataClient != nil </span><span class="cov7" title="4">{
                        if marketDataClient.Error != nil </span><span class="cov0" title="0">{
                                return nil, marketDataClient.Error
                        }</span>
                        <span class="cov7" title="4">return marketDataClient, nil</span>
                }
                <span class="cov1" title="1">token = append(token, os.Getenv("MARKETDATA_TOKEN"))</span>
        }

        <span class="cov5" title="3">if token[0] == "" </span><span class="cov0" title="0">{
                return nil, errors.New("no token provided")
        }</span>

        // Always create a new client when a token is provided
        <span class="cov5" title="3">client := NewClient()
        if client.Error != nil </span><span class="cov0" title="0">{
                return nil, client.Error
        }</span>

        <span class="cov5" title="3">client.Token(token[0])
        if client.Error != nil </span><span class="cov1" title="1">{
                return nil, client.Error
        }</span>

        // Save the new client to the global variable if no errors are present
        <span class="cov4" title="2">marketDataClient = client

        return client, nil</span>
}

// Environment configures the base URL of the MarketDataClient based on the provided environment string.
// This method allows the client to switch between different environments such as production, testing, and development.
//
// Parameters:
// - env: A string representing the environment to configure. Accepted values are "prodEnv", "testEnv", and "devEnv".
//
// Returns:
// - A pointer to the MarketDataClient instance with the configured environment.
// If an invalid environment is provided, the client's Error field is set, and the same instance is returned.
func (c *MarketDataClient) Environment(env string) *MarketDataClient <span class="cov7" title="5">{
        var baseURL string
        switch env </span>{
        case prodEnv:<span class="cov7" title="5">
                baseURL = prodProtocol + "://" + prodHost</span> // Set baseURL for production environment
        case testEnv:<span class="cov0" title="0">
                baseURL = testProtocol + "://" + testHost</span> // Set baseURL for testing environment
        case devEnv:<span class="cov0" title="0">
                baseURL = devProtocol + "://" + devHost</span> // Set baseURL for development environment
        default:<span class="cov0" title="0">
                c.Error = fmt.Errorf("invalid environment: %s", env) // Set error for invalid environment
                return c</span>
        }

        <span class="cov7" title="5">c.Client.SetBaseURL(baseURL) // Configure the client with the determined baseURL

        return c</span>
}

// init initializes the global marketDataClient with a token and environment fetched from environment variables.
// It retrieves the "MARKETDATA_TOKEN" and "DEFAULT_ENV" variables and uses them to configure the marketDataClient.
// If both the token and environment variables are set, it creates a new MarketDataClient instance,
// sets its environment and token based on the retrieved values, and assigns it to the global marketDataClient variable.
func init() <span class="cov4" title="2">{
        token := os.Getenv("MARKETDATA_TOKEN") // Retrieve the market data token from environment variables
        env := os.Getenv("DEFAULT_ENV") // Retrieve the default environment from environment variables

        // Check if both token and environment variables are not empty
        if token != "" &amp;&amp; env != "" </span><span class="cov1" title="1">{
                // Create and configure a new MarketDataClient instance with the environment and token
                marketDataClient = NewClient().Environment(env).Token(token)
        }</span>
}

// Token configures the authentication token for the MarketDataClient.
// This method sets the authentication scheme to "Bearer" and assigns the provided bearerToken for subsequent requests.
// It also makes an initial request to the MarketData API to authorize the token and fetch rate limit information.
//
// Parameters:
// - bearerToken: A string representing the authentication token to be used for API requests.
//
// Returns:
// - A pointer to the MarketDataClient instance with the configured authentication token.
// If an error occurs during the initial request or if the response indicates a failure, the client's Error field is set,
// and the same instance is returned.
func (c *MarketDataClient) Token(bearerToken string) *MarketDataClient <span class="cov7" title="4">{
        // Set the authentication scheme to "Bearer"
        c.Client.SetAuthScheme("Bearer")

        // Set the authentication token
        c.Client.SetAuthToken(bearerToken)

        // Make an initial request to authorize the token and load the rate limit information
        resp, err := c.Client.R().Get("https://api.marketdata.app/user/")
        if err != nil </span><span class="cov0" title="0">{
                c.Error = err // Set error if there's an issue with the request
                return c
        }</span>
        <span class="cov7" title="4">if !resp.IsSuccess() </span><span class="cov1" title="1">{
                err = fmt.Errorf("received non-OK status: %s", resp.Status()) // Create error for non-successful response
                c.Error = err
                return c
        }</span>

        <span class="cov5" title="3">return c</span>
}

// GetLogs returns a pointer to the HttpRequestLogs instance.
// This function is useful for accessing the logs that have been collected during HTTP requests.
func GetLogs() *HttpRequestLogs <span class="cov9" title="7">{
        return Logs
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package client

import (
        "errors"
        "net/http"
        "strconv"
        "strings"

        "github.com/go-resty/resty/v2"
)

// getRateLimitConsumed extracts the rate limit consumed value from the response headers.
// It specifically looks for the "X-Api-RateLimit-Consumed" header and attempts to convert its value to an integer.
//
// Parameters:
// - resp: A pointer to a resty.Response from which the header will be extracted.
//
// Returns:
// - int: The integer value of the "X-Api-RateLimit-Consumed" header if present and successfully converted.
// - error: An error if the header is missing or if the conversion to an integer fails.
func getRateLimitConsumed(resp *resty.Response) (int, error) <span class="cov7" title="7">{
        rateLimitConsumedStr := resp.Header().Get("X-Api-RateLimit-Consumed")
        if rateLimitConsumedStr == "" </span><span class="cov0" title="0">{
                return 0, errors.New("error: missing 'x-Api-RateLimit-Consumed' header")
        }</span>
        <span class="cov7" title="7">rateLimitConsumed, err := strconv.Atoi(rateLimitConsumedStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov7" title="7">return rateLimitConsumed, nil</span>
}

// getRayIDFromResponse extracts the "Cf-Ray" header value from the response.
//
// Parameters:
// - resp: A pointer to a resty.Response from which the header will be extracted.
//
// Returns:
// - string: The value of the "Cf-Ray" header if present.
// - error: An error if the "Cf-Ray" header is missing.
func getRayIDFromResponse(resp *resty.Response) (string, error) <span class="cov7" title="7">{
        rayID := resp.Header().Get("Cf-Ray")
        if rayID == "" </span><span class="cov0" title="0">{
                return "", errors.New("Cf-Ray header not found")
        }</span>
        <span class="cov7" title="7">return rayID, nil</span>
}

// getLatencyFromRequest calculates the server processing time for a request.
//
// Parameters:
// - req: A pointer to a resty.Request which has been executed and contains trace information.
//
// Returns:
// - int64: The server processing time in milliseconds.
func getLatencyFromRequest(req *resty.Request) int64 <span class="cov7" title="7">{
        trace := req.TraceInfo()
        return trace.ServerTime.Milliseconds()
}</span>

// redactAuthorizationHeader takes an http.Header object and returns a new http.Header object with the "Authorization" header value redacted.
// The redaction replaces the token with a string that has the same length but with the characters replaced by asterisks, except for the last four characters.
//
// Parameters:
// - headers: The original http.Header object containing the headers.
//
// Returns:
// - http.Header: A new http.Header object with the "Authorization" header value redacted if present.
func redactAuthorizationHeader(headers http.Header) http.Header <span class="cov7" title="7">{
        // Copy the headers so we don't modify the original
        copiedHeaders := make(http.Header)
        for k, v := range headers </span><span class="cov10" title="14">{
                copiedHeaders[k] = v
        }</span>

        // Redact the Authorization header if it exists
        <span class="cov7" title="7">if _, ok := copiedHeaders["Authorization"]; ok </span><span class="cov7" title="7">{
                token := copiedHeaders.Get("Authorization")
                redactedToken := "Bearer " + strings.Repeat("*", len(token)-8) + token[len(token)-4:]
                copiedHeaders.Set("Authorization", redactedToken)
        }</span>

        <span class="cov7" title="7">return copiedHeaders</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// IndicesCandlesRequest represents a request to the /v1/indices/candles endpoint.
// It encapsulates parameters for resolution, symbol, and date to be used in the request.
// This struct provides methods such as Resolution(), Symbol(), Date(), and From() to set these parameters respectively.
//
// Public Methods:
// - Resolution(q string) *IndicesCandlesRequest: Sets the resolution parameter for the request.
// - Symbol(q string) *IndicesCandlesRequest: Sets the symbol parameter for the request.
// - Date(q interface{}) *IndicesCandlesRequest: Sets the date parameter for the request.
// - From(q interface{}) *IndicesCandlesRequest: Sets the 'from' date parameter for the request.
type IndicesCandlesRequest struct {
        *baseRequest
        resolutionParams *parameters.ResolutionParams // Holds the resolution parameter of the request.
        symbolParams     *parameters.SymbolParams     // Holds the symbol parameter of the request.
        dateParams       *parameters.DateParams       // Holds the date parameters of the request.
}

// Resolution sets the resolution parameter for the IndicesCandlesRequest.
// This method is used to specify the granularity of the candle data to be retrieved.
// It modifies the resolutionParams field of the IndicesCandlesRequest instance to store the resolution value.
//
// Parameters:
// - q: A string representing the resolution to be set. Valid resolutions may include values like "1min", "5min", "1h", etc., depending on the API's supported resolutions.
//
// Returns:
// - *IndicesCandlesRequest: This method returns a pointer to the IndicesCandlesRequest instance it was called on. This allows for method chaining, where multiple setter methods can be called in a single statement. If the receiver (*IndicesCandlesRequest) is nil, it returns nil to prevent a panic.
//
// Note:
// If an error occurs while setting the resolution (e.g., if the resolution value is not supported), the Error field of the IndicesCandlesRequest is set with the encountered error, but the method still returns the IndicesCandlesRequest instance to allow for further method calls or error handling by the caller.
func (icr *IndicesCandlesRequest) Resolution(q string) *IndicesCandlesRequest <span class="cov8" title="1">{
        if icr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := icr.resolutionParams.SetResolution(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.Error = err
        }</span>
        <span class="cov8" title="1">return icr</span>
}
// it may return nil or set the Error field of the IndicesCandlesRequest respectively.
func (icr *IndicesCandlesRequest) Symbol(q string) *IndicesCandlesRequest <span class="cov8" title="1">{
        if icr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := icr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.Error = err
        }</span>
        <span class="cov8" title="1">return icr</span>
}

// Date sets the date parameter of the IndicesCandlesRequest.
// It accepts an interface{} parameter q which represents the date to be set.
// It returns a pointer to the IndicesCandlesRequest instance to allow for method chaining.
// If an error occurs while setting the date, the Error field of the baseRequest is set.
func (icr *IndicesCandlesRequest) Date(q interface{}) *IndicesCandlesRequest <span class="cov0" title="0">{
        err := icr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return icr</span>
}

// From sets the 'from' date parameter for the IndicesCandlesRequest. It configures the starting point of the date range for which the candle data is requested.
// Parameters:
// - q: An interface{} that represents the starting date. It can be a string, a time.Time object, or any other type that the underlying SetFrom method can process.
// Returns:
// - *IndicesCandlesRequest: A pointer to the IndicesCandlesRequest instance to allow for method chaining.
func (icr *IndicesCandlesRequest) From(q interface{}) *IndicesCandlesRequest <span class="cov8" title="1">{
        err := icr.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.baseRequest.Error = err
        }</span>
        <span class="cov8" title="1">return icr</span>
}

// To sets the 'to' date parameter for the IndicesCandlesRequest. It configures the ending point of the date range for which the candle data is requested.
// Parameters:
// - q: An interface{} that represents the ending date. It can be a string, a time.Time object, or any other type that the underlying SetTo method can process.
// Returns:
// - *IndicesCandlesRequest: A pointer to the IndicesCandlesRequest instance to allow for method chaining.
func (icr *IndicesCandlesRequest) To(q interface{}) *IndicesCandlesRequest <span class="cov8" title="1">{
        err := icr.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.baseRequest.Error = err
        }</span>
        <span class="cov8" title="1">return icr</span>
}

// Countback sets the countback parameter for the IndicesCandlesRequest. It specifies the number of candles to return, counting backwards from the 'to' date.
// Parameters:
// - q: An int representing the number of candles to return.
// Returns:
// - *IndicesCandlesRequest: A pointer to the IndicesCandlesRequest instance to allow for method chaining.
func (icr *IndicesCandlesRequest) Countback(q int) *IndicesCandlesRequest <span class="cov0" title="0">{
        err := icr.dateParams.SetCountback(q)
        if err != nil </span><span class="cov0" title="0">{
                icr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return icr</span>
}

// getParams packs the IndicesCandlesRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the IndicesCandlesRequest into a single slice
// for easier manipulation and usage in subsequent requests.
//
// Parameters:
// - None
//
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the IndicesCandlesRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (icr *IndicesCandlesRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov8" title="1">{
        if icr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndicesCandlesRequest is nil")
        }</span>
        <span class="cov8" title="1">params := []parameters.MarketDataParam{icr.dateParams, icr.symbolParams, icr.resolutionParams}
        return params, nil</span>
}

// Packed sends the IndicesCandlesRequest and returns the IndicesCandlesResponse.
// This method checks if the IndicesCandlesRequest receiver is nil, returning an error if true.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Otherwise, it proceeds to send the request and returns the IndicesCandlesResponse along with any error encountered during the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.IndicesCandlesResponse: A pointer to the IndicesCandlesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (icr *IndicesCandlesRequest) Packed(optionalClients ...*MarketDataClient) (*models.IndicesCandlesResponse, error) <span class="cov8" title="1">{
        if icr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndicesCandlesRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov8" title="1">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                icr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov8" title="1">var icrResp models.IndicesCandlesResponse
        _, err := icr.baseRequest.client.GetFromRequest(icr.baseRequest, &amp;icrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;icrResp, nil</span>
}

// Get sends the IndicesCandlesRequest, unpacks the IndicesCandlesResponse, and returns a slice of IndexCandle.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual candle data
// from the indices candles request. The method first checks if the IndicesCandlesRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of IndexCandle using the Unpack method from the response.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.IndexCandle: A slice of IndexCandle containing the unpacked candle data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (icr *IndicesCandlesRequest) Get(optionalClients ...*MarketDataClient) ([]models.IndexCandle, error) <span class="cov8" title="1">{
        if icr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndicesCandlesRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov8" title="1">icrResp, err := icr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov8" title="1">data, err := icrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// IndexCandles creates a new IndicesCandlesRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for date, resolution, and symbol, and sets the request path based on
// the predefined endpoints for indices candles.
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
// Returns:
// - *IndicesCandlesRequest: A pointer to the newly created IndicesCandlesRequest with default parameters and associated client.
func IndexCandles(client ...*MarketDataClient) *IndicesCandlesRequest <span class="cov8" title="1">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["indices"]["candles"]

        icr := &amp;IndicesCandlesRequest{
                baseRequest:      baseReq,
                dateParams:       &amp;parameters.DateParams{},
                resolutionParams: &amp;parameters.ResolutionParams{},
                symbolParams:     &amp;parameters.SymbolParams{},
        }

        baseReq.child = icr

        return icr
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// IndexQuoteRequest represents a request to the /indices/quote endpoint.
// It encapsulates parameters for symbol and fifty-two-week data to be used in the request.
// This struct provides methods such as Symbol() and FiftyTwoWeek() to set these parameters respectively.
//
// Public Methods:
// - Symbol(q string) *IndexQuoteRequest: Sets the symbol parameter for the request.
// - FiftyTwoWeek(q bool) *IndexQuoteRequest: Sets the fifty-two-week parameter for the request.
type IndexQuoteRequest struct {
        *baseRequest
        symbolParams       *parameters.SymbolParams
        fiftyTwoWeekParams *parameters.FiftyTwoWeekParams
}

// Symbol sets the symbol parameter for the IndexQuoteRequest.
// This method is used to specify the market symbol for which the quote data is requested.
// It modifies the symbolParams field of the IndexQuoteRequest instance to store the symbol value.
//
// Parameters:
// - q: A string representing the market symbol to be set.
//
// Returns:
// - *IndexQuoteRequest: This method returns a pointer to the IndexQuoteRequest instance it was called on. This allows for method chaining, where multiple setter methods can be called in a single statement. If the receiver (*IndexQuoteRequest) is nil, it returns nil to prevent a panic.
//
// Note:
// If an error occurs while setting the symbol (e.g., if the symbol value is not supported), the Error field of the IndexQuoteRequest is set with the encountered error, but the method still returns the IndexQuoteRequest instance to allow for further method calls or error handling by the caller.
func (iqr *IndexQuoteRequest) Symbol(q string) *IndexQuoteRequest <span class="cov0" title="0">{
        if iqr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := iqr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                iqr.Error = err
        }</span>
        <span class="cov0" title="0">return iqr</span>
}

// FiftyTwoWeek sets the FiftyTwoWeek parameter for the IndexQuoteRequest.
// This method is used to specify whether to include fifty-two-week high and low data in the quote.
// It modifies the fiftyTwoWeekParams field of the IndexQuoteRequest instance to store the boolean value.
//
// Parameters:
// - q: A boolean indicating whether to include fifty-two-week data.
//
// Returns:
// - *IndexQuoteRequest: This method returns a pointer to the IndexQuoteRequest instance it was called on. This allows for method chaining. If the receiver (*IndexQuoteRequest) is nil, it returns nil to prevent a panic.
func (iqr *IndexQuoteRequest) FiftyTwoWeek(q bool) *IndexQuoteRequest <span class="cov0" title="0">{
        if iqr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">iqr.fiftyTwoWeekParams.SetFiftyTwoWeek(q)
        return iqr</span>
}

// getParams packs the IndexQuoteRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the IndexQuoteRequest into a single slice
// for easier manipulation and usage in subsequent requests.
//
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the IndexQuoteRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (iqr *IndexQuoteRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if iqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndexQuoteRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{iqr.symbolParams, iqr.fiftyTwoWeekParams}
        return params, nil</span>
}

// Packed sends the IndexQuoteRequest and returns the IndexQuotesResponse.
// This method checks if the IndexQuoteRequest receiver is nil, returning an error if true.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Otherwise, it proceeds to send the request and returns the IndexQuotesResponse along with any error encountered during the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.IndexQuotesResponse: A pointer to the IndexQuotesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (iqr *IndexQuoteRequest) Packed(optionalClients ...*MarketDataClient) (*models.IndexQuotesResponse, error) <span class="cov0" title="0">{
        if iqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndexQuoteRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                iqr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var iqrResp models.IndexQuotesResponse
        _, err := iqr.baseRequest.client.GetFromRequest(iqr.baseRequest, &amp;iqrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;iqrResp, nil</span>
}

// Get sends the IndexQuoteRequest, unpacks the IndexQuotesResponse, and returns a slice of IndexQuote.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual quote data
// from the index quote request. The method first checks if the IndexQuoteRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of IndexQuote using the Unpack method from the response.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.IndexQuote: A slice of IndexQuote containing the unpacked quote data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (iqr *IndexQuoteRequest) Get(optionalClients ...*MarketDataClient) ([]models.IndexQuote, error) <span class="cov0" title="0">{
        if iqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("IndexQuoteRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">iqrResp, err := iqr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := iqrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// IndexQuotes creates a new IndexQuoteRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for symbol and fifty-two-week data, and sets the request path based on
// the predefined endpoints for index quotes.
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
// Returns:
// - *IndexQuoteRequest: A pointer to the newly created IndexQuoteRequest with default parameters and associated client.
func IndexQuotes(client ...*MarketDataClient) *IndexQuoteRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["indices"]["quotes"]

        iqr := &amp;IndexQuoteRequest{
                baseRequest:        baseReq,
                symbolParams:       &amp;parameters.SymbolParams{},
                fiftyTwoWeekParams: &amp;parameters.FiftyTwoWeekParams{},
        }

        baseReq.child = iqr

        return iqr
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package client

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "sort"
        "strings"
        "time"

        "github.com/fatih/color"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var (
        //debugModeLogger = log.New(os.Stdout, "", 0) // 0 turns off all flags, including the default timestamp flag
        blue   = color.New(color.FgBlue).SprintFunc()
        yellow = color.New(color.FgYellow).SprintFunc()
        purple = color.New(color.FgMagenta).SprintFunc()
)

var (
        SuccessLogger     *zap.Logger
        ClientErrorLogger *zap.Logger
        ServerErrorLogger *zap.Logger
        Logs              *HttpRequestLogs
        MaxLogEntries           = 100000        // MaxLogEntries is the maximum number of log entries that will be stored in memory.
        MemoryLimit       int64 = 100 * 1048576 // MemoryLimit is the limit (in bytes) of log entries that will be stored in memory.

)

// HttpRequestLogs represents a collection of HTTP request logs.
// It provides methods to manipulate and retrieve log entries.
//
// Public Methods:
// - String() string: Returns a string representation of all HTTP request logs.
// - PrintLatest(): Prints the latest HTTP request log entry.
type HttpRequestLogs struct {
        Logs []HttpRequestLog
}

// HttpRequestLog represents a single HTTP request log entry.
// It includes detailed information about the request and response, such as headers, status code, and response body.
//
// Public Methods:
// - WriteToLog(debug bool): Writes the log entry to the appropriate logger based on the HTTP response status.
// - String() string: Returns a string representation of the HTTP request log entry.
// - PrettyPrint(): Prints a formatted representation of the HTTP request log entry.
type HttpRequestLog struct {
        Timestamp         time.Time
        ReqHeaders        http.Header // The Request Headers
        ResHeaders        http.Header // The Response Headers
        RayID             string      // The Ray ID from the HTTP response
        Request           string      // The URL of the HTTP Request
        Status            int         // The status code of the response
        RateLimitConsumed int         // The number of requests consumed from the rate limit
        Delay             int64       // The time (in miliseconds) between the request and the server's response
        Response          string      // The server response
        memory            int64       // The amount of memory (in bytes) used by the log entry
}

// WriteToLog writes the log entry to the appropriate logger based on the HTTP response status.
// Parameters:
// - debug: A boolean indicating whether to log as a debug message.
func (h HttpRequestLog) WriteToLog(debug bool) <span class="cov3" title="3">{
        var logger *zap.Logger
        var logMessage string

        // Try to parse the JSON response into a map
        var jsonResponse map[string]interface{}
        err := json.Unmarshal([]byte(h.Response), &amp;jsonResponse)

        // If the parsing fails, log the response as a string
        var responseBody interface{}
        if err != nil </span><span class="cov0" title="0">{
                responseBody = h.Response
        }</span> else<span class="cov3" title="3"> {
                responseBody = jsonResponse
        }</span>

        <span class="cov3" title="3">if h.Status &gt;= 200 &amp;&amp; h.Status &lt; 300 </span><span class="cov3" title="3">{
                if debug </span><span class="cov0" title="0">{
                        logger = SuccessLogger
                        logMessage = "Successful Request"
                }</span>
        } else<span class="cov0" title="0"> if h.Status &gt;= 400 &amp;&amp; h.Status &lt; 500 </span><span class="cov0" title="0">{
                logger = ClientErrorLogger
                logMessage = "Client Error"
        }</span> else<span class="cov0" title="0"> if h.Status &gt;= 500 </span><span class="cov0" title="0">{
                logger = ServerErrorLogger
                logMessage = "Server Error"
        }</span>

        <span class="cov3" title="3">if logger != nil </span><span class="cov0" title="0">{
                logger.Info(logMessage,
                        zap.String("cf_ray", h.RayID),
                        zap.String("request_url", h.Request),
                        zap.Int("ratelimit_consumed", h.RateLimitConsumed),
                        zap.Int("response_code", h.Status),
                        zap.Int64("delay_ms", h.Delay),
                        zap.Any("request_headers", h.ReqHeaders),
                        zap.Any("response_headers", h.ResHeaders),
                        zap.Any("response_body", responseBody), // Log the parsed JSON response or the original string

                )
        }</span>
}

// String returns a string representation of the HTTP request log entry.
// Returns:
// - A string representing the log entry.
func (h HttpRequestLog) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Timestamp: %v, Status: %d, Request: %s, Request Headers: %s, RayID: %s, RateLimitConsumed: %d, Delay: %dms, Response Headers: %s, Response: %s",
                h.Timestamp.Format("2006-01-02 15:04:05"), h.Status, h.Request, h.ReqHeaders, h.RayID, h.RateLimitConsumed, h.Delay, h.ResHeaders, h.Response)
}</span>

// PrettyPrint prints a formatted representation of the HTTP request log entry.
func (h HttpRequestLog) PrettyPrint() <span class="cov0" title="0">{
        fmt.Println(blue("Timestamp:"), h.Timestamp.Format("2006-01-02 15:04:05"))
        fmt.Println(blue("Request:"), h.Request)
        fmt.Println(blue("Request Headers:"))
        h.printHeaders(h.ReqHeaders)
        fmt.Println(blue("Status:"), h.Status)
        fmt.Println(blue("Ray ID:"), h.RayID)
        fmt.Println(blue("Rate Limit Consumed:"), h.RateLimitConsumed)
        fmt.Println(blue("Delay:"), fmt.Sprintf("%dms", h.Delay))
        fmt.Println(blue("Response Headers:"))
        h.printHeaders(h.ResHeaders)
        fmt.Println(blue("Response:"), h.Response)
}</span>

// printHeaders prints the HTTP headers in a formatted manner. Headers starting with "X-Api-Ratelimit" are highlighted.
// Parameters:
// - headers: The HTTP headers to be printed.
func (h HttpRequestLog) printHeaders(headers http.Header) <span class="cov0" title="0">{
        keys := make([]string, 0, len(headers))
        for name := range headers </span><span class="cov0" title="0">{
                keys = append(keys, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys) // Sort the keys alphabetically

        for _, name := range keys </span><span class="cov0" title="0">{
                values := headers[name]
                if strings.HasPrefix(name, "X-Api-Ratelimit") </span><span class="cov0" title="0">{
                        fmt.Println(purple(name + ": " + strings.Join(values, ", ")))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(yellow(name+": "), strings.Join(values, ", "))
                }</span>
        }
}

// memoryUsage calculates the memory usage of the log entry.
// Returns:
// - An integer representing the memory usage of the log entry in bytes.
func (h HttpRequestLog) memoryUsage() int <span class="cov3" title="3">{
        // Size of time.Time (24 bytes)
        timestampSize := 24

        // Size of string: size of string header (16 bytes) + length of string
        rayIDSize := 16 + len(h.RayID)
        requestSize := 16 + len(h.Request)
        responseSize := 16 + len(h.Response)

        // Size of int (4 bytes)
        statusSize := 4
        rateLimitConsumedSize := 4

        // Size of int64 (8 bytes)
        delaySize := 8
        memorySize := 8

        // Size of http.Header
        reqHeadersSize := h.headerSize(h.ReqHeaders)
        resHeadersSize := h.headerSize(h.ResHeaders)

        totalSize := timestampSize + rayIDSize + requestSize + statusSize + rateLimitConsumedSize + delaySize + responseSize + memorySize + reqHeadersSize + resHeadersSize

        return totalSize
}</span>

// headerSize calculates the memory usage of HTTP headers.
// Parameters:
// - header: The HTTP headers for which the memory usage is calculated.
// Returns:
// - An integer representing the memory usage of the headers in bytes.
func (h HttpRequestLog) headerSize(header http.Header) int <span class="cov4" title="6">{
        size := 0
        for key, values := range header </span><span class="cov10" title="63">{
                // Size of string: size of string header (16 bytes) + length of string
                keySize := 16 + len(key)
                for _, value := range values </span><span class="cov10" title="63">{
                        valueSize := 16 + len(value)
                        size += keySize + valueSize
                }</span>
        }
        <span class="cov4" title="6">return size</span>
}

func NewHttpRequestLog(timestamp time.Time, rayID string, request string, rateLimitConsumed int, delay int64, status int, body string, reqHeaders http.Header, resHeaders http.Header) HttpRequestLog <span class="cov3" title="3">{
        log := HttpRequestLog{
                Timestamp:         timestamp,
                Status:            status,
                RayID:             rayID,
                RateLimitConsumed: rateLimitConsumed,
                Delay:             delay,
                Request:           request,
                Response:          body,
                ReqHeaders:        reqHeaders,
                ResHeaders:        resHeaders,
        }

        log.memory = int64(log.memoryUsage())

        return log
}</span>

// totalMemoryUsage calculates the total memory usage of all log entries.
// Returns:
// - An int64 representing the total memory usage of all log entries in bytes.
func (h *HttpRequestLogs) totalMemoryUsage() int64 <span class="cov3" title="3">{
        total := int64(0)
        for _, log := range h.Logs </span><span class="cov4" title="4">{
                total += log.memory
        }</span>
        <span class="cov3" title="3">return total</span>
}

// String returns a string representation of all HTTP request logs.
// Returns:
// - A string representing all log entries.
func (h *HttpRequestLogs) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        for _, log := range h.Logs </span><span class="cov0" title="0">{
                sb.WriteString(log.String())
                sb.WriteString("\n")
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// GetLastLogResponse returns the response of the last log entry in the HttpRequestLogs.
//
// This method checks if there are any logs present. If there are no logs, it returns a message indicating that no logs are available.
// If logs are present, it calculates the index of the last log entry, accesses it, and returns its response.
//
// Returns:
// - A string representing the response of the last log entry. If no logs are available, returns "No logs available".
func (h *HttpRequestLogs) GetLastLogResponse() string <span class="cov1" title="1">{
    // Step 2: Check if there are no logs
    if len(h.Logs) == 0 </span><span class="cov0" title="0">{
        // Return an appropriate response for no logs
        return "No logs available"
    }</span>

    // Step 3: Calculate the index of the last log entry and access it
    <span class="cov1" title="1">lastLogIndex := len(h.Logs) - 1
    lastLog := h.Logs[lastLogIndex]

    // Step 4: Return the Response of the last log entry
    return lastLog.Response</span>
}

// PrintLatest prints the latest HTTP request log entry.
func (h *HttpRequestLogs) PrintLatest() <span class="cov0" title="0">{
        if len(h.Logs) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No logs available")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(blue("Latest Log Entry:"))
                h.Logs[len(h.Logs)-1].PrettyPrint()
        }</span>
}

// AddToLog adds a new HTTP request log entry to the HttpRequestLogs.
//
// This method creates a new HttpRequestLog entry based on the provided parameters and appends it to the HttpRequestLogs.
// If the request URL starts with "https://api.marketdata.app/user/", the log entry is not added, and the method returns nil.
// After adding a new log entry, it trims the log to ensure the total memory usage and the number of log entries are below their limits.
//
// Parameters:
// - h *HttpRequestLogs: A pointer to the HttpRequestLogs to which the new log entry will be added.
// - timestamp time.Time: The timestamp of the HTTP request.
// - rayID string: The unique identifier for the request.
// - request string: The URL of the HTTP request.
// - rateLimitConsumed int: The amount of rate limit consumed by the request.
// - delay int64: The delay experienced during the request, in milliseconds.
// - status int: The HTTP status code of the response.
// - body string: The body of the HTTP response.
// - reqHeaders http.Header: The HTTP headers of the request.
// - resHeaders http.Header: The HTTP headers of the response.
//
// Returns:
// - *HttpRequestLog: A pointer to the newly added HttpRequestLog entry. Returns nil if the log entry is not added.
func AddToLog(h *HttpRequestLogs, timestamp time.Time, rayID string, request string, rateLimitConsumed int, delay int64, status int, body string, reqHeaders http.Header, resHeaders http.Header) *HttpRequestLog <span class="cov5" title="7">{
        if request == "https://api.marketdata.app/user/" </span><span class="cov4" title="4">{
                // If the URL starts with https://api.marketdata.app/user/ do not add it to the log.
                // Just return without doing anything in this case.
                return nil
        }</span>

        <span class="cov3" title="3">log := NewHttpRequestLog(timestamp, rayID, request, rateLimitConsumed, delay, status, body, reqHeaders, resHeaders)

        h.Logs = append(h.Logs, log)

        // Trim the log to ensure the total memory usage and the number of log entries are below their limits
        h.trimLog()

        // Return a pointer to the new log entry
        return &amp;h.Logs[len(h.Logs)-1]</span>
}

// trimLog trims the HttpRequestLogs to ensure that the total memory usage and the number of log entries do not exceed their respective limits.
// It iteratively removes the oldest log entry until the memory usage is below the MemoryLimit and the number of entries is less than or equal to MaxLogEntries.
func (h *HttpRequestLogs) trimLog() <span class="cov3" title="3">{
        // While the total memory usage is above the limit or there are too many log entries, remove the oldest log entry
        for (h.totalMemoryUsage() &gt; MemoryLimit || len(h.Logs) &gt; MaxLogEntries) &amp;&amp; len(h.Logs) &gt; 0 </span><span class="cov0" title="0">{
                h.Logs = h.Logs[1:]
        }</span>
}
// init initializes the logging system for the application.
//
// This function performs the following operations:
// - Initializes the Logs variable with an empty HttpRequestLogs.
// - Checks if the logs directory exists, and creates it if it does not.
// - Opens or creates the success, client error, and server error log files.
// - Sets up a zapcore.Core for each log file to enable structured logging.
//
// The log files are named success.log, client_error.log, and server_error.log respectively.
// Each log file is opened with append mode, so new log entries are added to the end of the file.
// The logging level for all log files is set to InfoLevel, and the logs are encoded in JSON format.
// The time encoding for log entries is set to ISO8601 format.
func init() <span class="cov2" title="2">{
        // Initialize the Logs variable
        Logs = &amp;HttpRequestLogs{
                Logs: []HttpRequestLog{},
        }

        // Create the logs directory if it does not exist
        if _, err := os.Stat("logs"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.MkdirAll("logs", 0755)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create logs directory: %v", err)
                }</span>
        }

        // Open the log files. If they do not exist, create them.
        <span class="cov2" title="2">successLogFile, err := os.OpenFile("logs/success.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open success log file: %v", err)
        }</span>

        <span class="cov2" title="2">clientErrorLogFile, err := os.OpenFile("logs/client_error.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open client error log file: %v", err)
        }</span>

        <span class="cov2" title="2">serverErrorLogFile, err := os.OpenFile("logs/server_error.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open server error log file: %v", err)
        }</span>

        // Create a zapcore.Core that writes to the log files
        <span class="cov2" title="2">encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

        successCore := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(successLogFile),
                zap.InfoLevel,
        )

        clientErrorCore := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(clientErrorLogFile),
                zap.InfoLevel,
        )

        serverErrorCore := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(serverErrorLogFile),
                zap.InfoLevel,
        )

        // Create a zap.Logger from the Core
        SuccessLogger = zap.New(successCore)
        ClientErrorLogger = zap.New(clientErrorCore)
        ServerErrorLogger = zap.New(serverErrorCore)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// MarketStatusRequest represents a request for market status information.
// It encapsulates parameters for country, universal, and date to be used in the request.
// This struct provides methods such as Country(), Date(), From(), To(), and Countback() to set these parameters respectively.
//
// Public Methods:
// - Country(q string) *MarketStatusRequest: Sets the country parameter for the request.
// - Date(q interface{}) *MarketStatusRequest: Sets the date parameter for the request.
// - From(q interface{}) *MarketStatusRequest: Sets the 'from' date parameter for the request.
// - To(q interface{}) *MarketStatusRequest: Sets the 'to' date parameter for the request.
// - Countback(q int) *MarketStatusRequest: Sets the countback parameter for the request.
type MarketStatusRequest struct {
        *baseRequest
        countryParams   *parameters.CountryParams
        universalParams *parameters.UniversalParams
        dateParams      *parameters.DateParams
}

// getParams packs the MarketStatusRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the MarketStatusRequest into a single slice
// for easier manipulation and usage in subsequent requests.
//
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the MarketStatusRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (msr *MarketStatusRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if msr.countryParams == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required struct CountryParams doesn't exist")
        }</span>
        <span class="cov0" title="0">if msr.universalParams == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required struct UniversalParams doesn't exist")
        }</span>
        <span class="cov0" title="0">if msr.dateParams == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required struct DateParams doesn't exist")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{msr.countryParams, msr.universalParams, msr.dateParams}
        return params, nil</span>
}

// Country sets the country parameter of the MarketStatusRequest.
// This method is used to specify the country for which the market status is requested.
// It modifies the countryParams field of the MarketStatusRequest instance to store the country value.
//
// Parameters:
// - q: A string representing the country to be set.
//
// Returns:
// - *MarketStatusRequest: This method returns a pointer to the MarketStatusRequest instance it was called on. This allows for method chaining, where multiple setter methods can be called in a single statement. If the receiver (*MarketStatusRequest) is nil, it returns nil to prevent a panic.
func (msr *MarketStatusRequest) Country(q string) *MarketStatusRequest <span class="cov10" title="3">{
        err := msr.countryParams.SetCountry(q)
        if err != nil </span><span class="cov1" title="1">{
                msr.baseRequest.Error = err
        }</span>
        <span class="cov10" title="3">return msr</span>
}

// Date sets the date parameter of the MarketStatusRequest.
// This method is used to specify the date for which the market status is requested.
// It modifies the dateParams field of the MarketStatusRequest instance to store the date value.
//
// Parameters:
// - q: An interface{} representing the date to be set.
//
// Returns:
// - *MarketStatusRequest: This method returns a pointer to the MarketStatusRequest instance it was called on. This allows for method chaining. If the receiver (*MarketStatusRequest) is nil, it returns nil to prevent a panic.
func (msr *MarketStatusRequest) Date(q interface{}) *MarketStatusRequest <span class="cov1" title="1">{
        err := msr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                msr.baseRequest.Error = err
        }</span>
        <span class="cov1" title="1">return msr</span>
}

// From sets the 'from' date parameter of the MarketStatusRequest.
// This method is used to specify the starting date of the period for which the market status is requested.
// It modifies the dateParams field of the MarketStatusRequest instance to store the 'from' date value.
//
// Parameters:
// - q: An interface{} representing the 'from' date to be set.
//
// Returns:
// - *MarketStatusRequest: This method returns a pointer to the MarketStatusRequest instance it was called on. This allows for method chaining. If the receiver (*MarketStatusRequest) is nil, it returns nil to prevent a panic.
func (msr *MarketStatusRequest) From(q interface{}) *MarketStatusRequest <span class="cov1" title="1">{
        err := msr.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                msr.baseRequest.Error = err
        }</span>
        <span class="cov1" title="1">return msr</span>
}

// To sets the 'to' date parameter of the MarketStatusRequest.
// This method is used to specify the ending date of the period for which the market status is requested.
// It modifies the dateParams field of the MarketStatusRequest instance to store the 'to' date value.
//
// Parameters:
// - q: An interface{} representing the 'to' date to be set.
//
// Returns:
// - *MarketStatusRequest: This method returns a pointer to the MarketStatusRequest instance it was called on. This allows for method chaining. If the receiver (*MarketStatusRequest) is nil, it returns nil to prevent a panic.
func (msr *MarketStatusRequest) To(q interface{}) *MarketStatusRequest <span class="cov1" title="1">{
        err := msr.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                msr.baseRequest.Error = err
        }</span>
        <span class="cov1" title="1">return msr</span>
}

// Countback sets the countback parameter for the MarketStatusRequest. It specifies the number of days to return, counting backwards from the 'to' date.
// Parameters:
// - q: An int representing the number of days to return.
// Returns:
// - *MarketStatusRequest: A pointer to the MarketStatusRequest instance to allow for method chaining.
func (msr *MarketStatusRequest) Countback(q int) *MarketStatusRequest <span class="cov1" title="1">{
        err := msr.dateParams.SetCountback(q)
        if err != nil </span><span class="cov0" title="0">{
                msr.baseRequest.Error = err
        }</span>
        <span class="cov1" title="1">return msr</span>
}

// Packed sends the MarketStatusRequest and returns the MarketStatusResponse.
// This method checks if the MarketStatusRequest receiver is nil, returning an error if true.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Otherwise, it proceeds to send the request and returns the MarketStatusResponse along with any error encountered during the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.MarketStatusResponse: A pointer to the MarketStatusResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (msr *MarketStatusRequest) Packed(optionalClients ...*MarketDataClient) (*models.MarketStatusResponse, error) <span class="cov0" title="0">{
        if msr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MarketStatusRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                msr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var msrResp models.MarketStatusResponse
        _, err := msr.baseRequest.client.GetFromRequest(msr.baseRequest, &amp;msrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;msrResp, nil</span>
}

// Get sends the MarketStatusRequest, unpacks the MarketStatusResponse, and returns a slice of MarketStatusReport.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual market status data
// from the market status request. The method first checks if the MarketStatusRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of MarketStatusReport using the Unpack method from the response.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.MarketStatusReport: A slice of MarketStatusReport containing the unpacked market status data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (msr *MarketStatusRequest) Get(optionalClients ...*MarketDataClient) ([]models.MarketStatusReport, error) <span class="cov0" title="0">{
        if msr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MarketStatusRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">msrResp, err := msr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := msrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// MarketStatus creates a new MarketStatusRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for country, universal, and date, and sets the request path based on
// the predefined endpoints for market status.
// Parameters:
// - clients: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
// Returns:
// - *MarketStatusRequest: A pointer to the newly created MarketStatusRequest with default parameters and associated client.
func MarketStatus(clients ...*MarketDataClient) *MarketStatusRequest <span class="cov1" title="1">{
        baseReq := newBaseRequest(clients...)

        msr := &amp;MarketStatusRequest{
                baseRequest:     baseReq,
                countryParams:   &amp;parameters.CountryParams{},
                universalParams: &amp;parameters.UniversalParams{},
                dateParams:      &amp;parameters.DateParams{},
        }

        baseReq.child = msr

        msr.Country("US") // Set default country value to "US"

        path, ok := endpoints[1]["markets"]["status"]
        if !ok </span><span class="cov0" title="0">{
                msr.baseRequest.Error = fmt.Errorf("path not found for market status")
                return msr
        }</span>
        <span class="cov1" title="1">msr.baseRequest.path = path

        return msr</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// OptionChainRequest represents a request to the /options/chain endpoint.
// It encapsulates parameters for symbol, date, and various option-specific parameters to be used in the request.
// This struct provides methods to set these parameters, such as UnderlyingSymbol(), Date(), Expiration(), and Strike(), among others.
//
// Public Methods:
// - UnderlyingSymbol(q string) *OptionChainRequest: Sets the underlying symbol parameter for the request.
// - Date(q interface{}) *OptionChainRequest: Sets the date parameter for the request.
// - Expiration(q interface{}) *OptionChainRequest: Sets the expiration parameter for the request.
// - Strike(strike float64) *OptionChainRequest: Sets the strike price parameter for the request.
// - and other option-specific parameter setting methods like Month(), Year(), Weekly(), Monthly(), etc.
type OptionChainRequest struct {
        *baseRequest
        symbolParams *parameters.SymbolParams
        dateParams   *parameters.DateParams
        optionParams *parameters.OptionParams
}

// UnderlyingSymbol sets the underlyingSymbol parameter for the OptionChainRequest.
// This method is used to specify the symbol of the underlying asset for which the option chain is requested.
// It modifies the symbolParams field of the OptionChainRequest instance to store the symbol value.
//
// Parameters:
// - q: A string representing the underlying symbol to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining, where multiple setter methods can be called in a single statement. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) UnderlyingSymbol(q string) *OptionChainRequest <span class="cov0" title="0">{
        if ocr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := ocr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Date sets the date parameter for the OptionChainRequest.
// This method is used to specify the date for which the option chain is requested.
// It modifies the dateParams field of the OptionChainRequest instance to store the date value.
//
// Parameters:
// - q: An interface{} representing the date to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Date(q interface{}) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.dateParams == nil </span><span class="cov0" title="0">{
                ocr.dateParams = &amp;parameters.DateParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Expiration sets the expiration parameter for the OptionChainRequest.
// This method is used to specify the expiration date for the options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the expiration value.
//
// Parameters:
// - q: An interface{} representing the expiration date to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Expiration(q interface{}) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetExpiration(q)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Month sets the month parameter for the OptionChainRequest.
// This method is used to specify the month for which the option chain is requested.
// It modifies the optionParams field of the OptionChainRequest instance to store the month value.
//
// Parameters:
// - month: An int representing the month to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Month(month int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMonth(month)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Year sets the year parameter for the OptionChainRequest.
// This method is used to specify the year for which the option chain is requested.
// It modifies the optionParams field of the OptionChainRequest instance to store the year value.
//
// Parameters:
// - year: An int representing the year to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Year(year int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetYear(year)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Weekly sets the weekly parameter for the OptionChainRequest.
// This method is used to specify whether to include weekly options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the weekly value.
//
// Parameters:
// - weekly: A bool indicating whether to include weekly options.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Weekly(weekly bool) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetWeekly(weekly)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Monthly sets the monthly parameter for the OptionChainRequest.
// This method is used to specify whether to include monthly options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the monthly value.
//
// Parameters:
// - monthly: A bool indicating whether to include monthly options.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Monthly(monthly bool) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMonthly(monthly)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Quarterly sets the quarterly parameter for the OptionChainRequest.
// This method is used to specify whether to include quarterly options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the quarterly value.
//
// Parameters:
// - quarterly: A bool indicating whether to include quarterly options.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Quarterly(quarterly bool) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetQuarterly(quarterly)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Nonstandard sets the nonstandard parameter for the OptionChainRequest.
// This method is used to specify whether to include nonstandard options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the nonstandard value.
//
// Parameters:
// - nonstandard: A bool indicating whether to include nonstandard options.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Nonstandard(nonstandard bool) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetNonstandard(nonstandard)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// DTE (Days to Expiration) sets the DTE parameter for the OptionChainRequest.
// This method specifies the number of days to expiration for the options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the DTE value.
//
// Parameters:
// - dte: An int representing the days to expiration to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) DTE(dte int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetDTE(dte)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Delta sets the Delta parameter for the OptionChainRequest.
// This method is used to specify a particular Delta value for the options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the Delta value.
//
// Parameters:
// - delta: A float64 representing the Delta value to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Delta(delta float64) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetDelta(delta)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Side sets the Side parameter for the OptionChainRequest.
// This method is used to specify the side of the market for the options in the option chain (e.g., call or put).
// It modifies the optionParams field of the OptionChainRequest instance to store the side value.
//
// Parameters:
// - side: A string representing the side of the market to be set. Expected values are typically "call" or "put".
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Side(side string) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetSide(side)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Range sets the Range parameter for the OptionChainRequest.
// This method is used to specify the range of options to be included in the option chain based on their strike price.
// It modifies the optionParams field of the OptionChainRequest instance to store the range value.
//
// Parameters:
// - rangeParam: A string representing the range of options to be included. The expected values can vary, such as "ITM" (In The Money), "OTM" (Out of The Money), "ATM" (At The Money), etc.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Range(rangeParam string) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetRange(rangeParam)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// Strike sets the strike price parameter for the OptionChainRequest.
// This method is used to specify a particular strike price for the options in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the strike price value.
//
// Parameters:
// - strike: A float64 representing the strike price to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) Strike(strike float64) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetStrike(strike)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// StrikeLimit sets the StrikeLimit parameter for the OptionChainRequest.
// This method is used to specify the maximum number of strike prices to be included in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the strike limit value.
//
// Parameters:
// - strikeLimit: An int representing the maximum number of strike prices to be included.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) StrikeLimit(strikeLimit int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetStrikeLimit(strikeLimit)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// MinOpenInterest sets the MinOpenInterest parameter for the OptionChainRequest.
// This method is used to specify the minimum open interest for options to be included in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the minimum open interest value.
//
// Parameters:
// - minOpenInterest: An int representing the minimum open interest to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) MinOpenInterest(minOpenInterest int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMinOpenInterest(minOpenInterest)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// MinVolume sets the MinVolume parameter for the OptionChainRequest.
// This method is used to specify the minimum volume for options to be included in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the minimum volume value.
//
// Parameters:
// - minVolume: An int representing the minimum volume to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) MinVolume(minVolume int) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMinVolume(minVolume)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// MaxBidAskSpread sets the MaxBidAskSpread parameter for the OptionChainRequest.
// This method is used to specify the maximum bid-ask spread for options to be included in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the maximum bid-ask spread value.
//
// Parameters:
// - maxBidAskSpread: A float64 representing the maximum bid-ask spread to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) MaxBidAskSpread(maxBidAskSpread float64) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMaxBidAskSpread(maxBidAskSpread)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// MaxBidAskSpreadPct sets the MaxBidAskSpreadPct parameter for the OptionChainRequest.
// This method is used to specify the maximum bid-ask spread percentage for options to be included in the option chain.
// It modifies the optionParams field of the OptionChainRequest instance to store the maximum bid-ask spread percentage value.
//
// Parameters:
// - maxBidAskSpreadPct: A float64 representing the maximum bid-ask spread percentage to be set.
//
// Returns:
// - *OptionChainRequest: This method returns a pointer to the OptionChainRequest instance it was called on. This allows for method chaining. If the receiver (*OptionChainRequest) is nil, it returns nil to prevent a panic.
func (ocr *OptionChainRequest) MaxBidAskSpreadPct(maxBidAskSpreadPct float64) *OptionChainRequest <span class="cov0" title="0">{
        if ocr.optionParams == nil </span><span class="cov0" title="0">{
                ocr.optionParams = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">err := ocr.optionParams.SetMaxBidAskSpreadPct(maxBidAskSpreadPct)
        if err != nil </span><span class="cov0" title="0">{
                ocr.Error = err
        }</span>
        <span class="cov0" title="0">return ocr</span>
}

// getParams packs the OptionChainRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the OptionChainRequest into a single slice
// for easier manipulation and usage in subsequent requests.
//
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the OptionChainRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (ocr *OptionChainRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if ocr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionChainRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{ocr.symbolParams, ocr.dateParams, ocr.optionParams}
        return params, nil</span>
}

// Packed sends the OptionChainRequest and returns the OptionChainResponse.
// This method checks if the OptionChainRequest receiver is nil, returning an error if true.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Otherwise, it proceeds to send the request and returns the OptionChainResponse along with any error encountered during the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.OptionQuotesResponse: A pointer to the OptionQuotesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (ocr *OptionChainRequest) Packed(optionalClients ...*MarketDataClient) (*models.OptionQuotesResponse, error) <span class="cov0" title="0">{
        if ocr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionChainRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                ocr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var ocrResp models.OptionQuotesResponse
        _, err := ocr.baseRequest.client.GetFromRequest(ocr.baseRequest, &amp;ocrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ocrResp, nil</span>
}

// Get sends the OptionChainRequest, unpacks the OptionChainResponse, and returns a slice of OptionQuote.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual option chain data
// from the option chain request. The method first checks if the OptionChainRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of OptionQuote using the Unpack method from the response.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.OptionQuote: A slice of OptionQuote containing the unpacked option chain data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (ocr *OptionChainRequest) Get(optionalClients ...*MarketDataClient) ([]models.OptionQuote, error) <span class="cov0" title="0">{
        if ocr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionChainRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">ocrResp, err := ocr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := ocrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// OptionChain creates a new OptionChainRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for symbol, date, and option-specific parameters, and sets the request path based on
// the predefined endpoints for option chains.
// Parameters:
// - clients: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
// Returns:
// - *OptionChainRequest: A pointer to the newly created OptionChainRequest with default parameters and associated client.
func OptionChain(client ...*MarketDataClient) *OptionChainRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["options"]["chain"]

        ocr := &amp;OptionChainRequest{
                baseRequest:  baseReq,
                symbolParams: &amp;parameters.SymbolParams{},
                optionParams: &amp;parameters.OptionParams{},
                dateParams:   &amp;parameters.DateParams{},
        }

        baseReq.child = ocr

        return ocr
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package client

import (
        "fmt"
        "time"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// OptionsExpirationsRequest represents a request for retrieving options expirations data.
// It encapsulates parameters for the underlying symbol and strike price to be used in the request.
// This struct provides methods such as UnderlyingSymbol() and Strike() to set these parameters respectively.
//
// Public Methods:
// - Strike(strike float64) *OptionsExpirationsRequest: Sets the strike price parameter for the options expirations request.
// - UnderlyingSymbol(symbol string) *OptionsExpirationsRequest: Sets the underlying symbol parameter for the options expirations request.
type OptionsExpirationsRequest struct {
        *baseRequest
        underlyingSymbol *parameters.SymbolParams
        strike           *parameters.OptionParams
}

// Strike sets the strike price parameter for the OptionsExpirationsRequest.
// This method is used to specify a particular strike price for filtering the options expirations.
// Parameters:
// - strike: A float64 representing the strike price to be set.
// Returns:
// - *OptionsExpirationsRequest: This method returns a pointer to the OptionsExpirationsRequest instance it was called on, allowing for method chaining.
func (o *OptionsExpirationsRequest) Strike(strike float64) *OptionsExpirationsRequest <span class="cov0" title="0">{
        if o.strike == nil </span><span class="cov0" title="0">{
                o.strike = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">if err := o.strike.SetStrike(strike); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

// UnderlyingSymbol sets the underlying symbol parameter for the OptionsExpirationsRequest.
// This method is used to specify the symbol of the underlying asset for which the options expirations are requested.
// Parameters:
// - symbol: A string representing the underlying symbol to be set.
// Returns:
// - *OptionsExpirationsRequest: This method returns a pointer to the OptionsExpirationsRequest instance it was called on, allowing for method chaining.
func (o *OptionsExpirationsRequest) UnderlyingSymbol(symbol string) *OptionsExpirationsRequest <span class="cov0" title="0">{
        if err := o.underlyingSymbol.SetSymbol(symbol); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

// getParams packs the OptionsExpirationsRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the OptionsExpirationsRequest into a single slice for easier manipulation and usage in subsequent requests.
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the OptionsExpirationsRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (o *OptionsExpirationsRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsExpirationsRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{o.underlyingSymbol, o.strike}
        return params, nil</span>
}

// Packed sends the OptionsExpirationsRequest and returns the OptionsExpirationsResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.OptionsExpirationsResponse: A pointer to the OptionsExpirationsResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (o *OptionsExpirationsRequest) Packed(optionalClients ...*MarketDataClient) (*models.OptionsExpirationsResponse, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsExpirationsRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                o.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var oResp models.OptionsExpirationsResponse
        _, err := o.baseRequest.client.GetFromRequest(o.baseRequest, &amp;oResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;oResp, nil</span>
}

// Get sends the OptionsExpirationsRequest, unpacks the OptionsExpirationsResponse, and returns a slice of time.Time.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []time.Time: A slice of time.Time containing the unpacked options expirations data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (o *OptionsExpirationsRequest) Get(optionalClients ...*MarketDataClient) ([]time.Time, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsExpirationsRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">oResp, err := o.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := oResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// OptionsExpirations creates a new OptionsExpirationsRequest and associates it with the provided client.
// If no client is provided, it uses the default client.
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided, the default client is used.
// Returns:
// - *OptionsExpirationsRequest: A pointer to the newly created OptionsExpirationsRequest with default parameters and associated client.
func OptionsExpirations(client ...*MarketDataClient) *OptionsExpirationsRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["options"]["expirations"]

        oer := &amp;OptionsExpirationsRequest{
                baseRequest:      baseReq,
                underlyingSymbol: &amp;parameters.SymbolParams{},
                strike:           &amp;parameters.OptionParams{},
        }

        baseReq.child = oer

        return oer
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// OptionsLookupRequest represents a request for retrieving options data based on user input.
// It encapsulates parameters for user input to be used in the request.
//
// Public Methods:
// - UserInput(userInput string) *OptionLookupRequest: Sets the user input parameter for the request.
type OptionLookupRequest struct {
        *baseRequest
        userInput *parameters.UserInputParams
}

// UserInput sets the user input parameter for the OptionsLookupRequest.
// This method is used to specify the user input for which the options data is requested.
// Parameters:
// - userInput: A string representing the user input to be set.
// Returns:
// - *OptionsLookupRequest: This method returns a pointer to the OptionsLookupRequest instance it was called on, allowing for method chaining.
func (o *OptionLookupRequest) UserInput(userInput string) *OptionLookupRequest <span class="cov0" title="0">{
        if o.userInput == nil </span><span class="cov0" title="0">{
                o.userInput = &amp;parameters.UserInputParams{}
        }</span>
        <span class="cov0" title="0">if err := o.userInput.SetUserInput(userInput); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

// getParams packs the OptionsLookupRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the OptionsLookupRequest into a single slice for easier manipulation and usage in subsequent requests.
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the OptionsLookupRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (o *OptionLookupRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionLookupRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{o.userInput}
        return params, nil</span>
}

// Packed sends the OptionLookupRequest and returns the OptionsLookupResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.OptionsLookupResponse: A pointer to the OptionsLookupResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (o *OptionLookupRequest) Packed(optionalClients ...*MarketDataClient) (*models.OptionLookupResponse, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsLookupRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                o.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var oResp models.OptionLookupResponse
        _, err := o.baseRequest.client.GetFromRequest(o.baseRequest, &amp;oResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;oResp, nil</span>
}

// Get sends the OptionLookupRequest, unpacks the OptionsLookupResponse, and returns the unpacked data as a string.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - string: A string containing the unpacked options data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (o *OptionLookupRequest) Get(optionalClients ...*MarketDataClient) (string, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("OptionsLookupRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">oResp, err := o.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := oResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// OptionLookup creates a new OptionsLookupRequest and associates it with the provided client.
// If no client is provided, it uses the default client.
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided, the default client is used.
// Returns:
// - *OptionsLookupRequest: A pointer to the newly created OptionsLookupRequest with default parameters and associated client.
func OptionLookup(client ...*MarketDataClient) *OptionLookupRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["options"]["lookup"]

        olr := &amp;OptionLookupRequest{
                baseRequest: baseReq,
                userInput:   &amp;parameters.UserInputParams{},
        }

        baseReq.child = olr

        return olr
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// OptionQuotesRequest represents a request for retrieving options quotes.
// It encapsulates parameters for symbol, expiration, and strike to be used in the request.
//
// Public Methods:
// - OptionSymbol(symbol string) *OptionQuoteRequest: Sets the symbol parameter for the request.
// - Date(date interface{}) *OptionQuoteRequest: Sets the date parameter for the request, accepting flexible date input.
// - From(from interface{}) *OptionQuoteRequest: Sets the start date of a date range for the request, accepting flexible date input.
// - To(from interface{}) *OptionQuoteRequest: Sets the start date of a date range for the request, accepting flexible date input.
type OptionQuoteRequest struct {
        *baseRequest
        symbolParams *parameters.SymbolParams
        dateParams   *parameters.DateParams
}

// OptionSymbol sets the symbol parameter for the OptionQuotesRequest.
// This method is used to specify the symbol of the option for which the quote is requested.
// Parameters:
// - symbol: A string representing the symbol to be set.
// Returns:
// - *OptionQuotesRequest: This method returns a pointer to the OptionQuotesRequest instance it was called on, allowing for method chaining.
func (oqr *OptionQuoteRequest) OptionSymbol(q string) *OptionQuoteRequest <span class="cov0" title="0">{
        if oqr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := oqr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                oqr.Error = err
        }</span>
        <span class="cov0" title="0">return oqr</span>
}

// Date sets the date parameter for the OptionQuotesRequest.
// This method is used to specify the date for which the option quote is requested.
// It allows for flexibility in the type of date input (e.g., string, time.Time) through the use of an interface{} parameter.
// Parameters:
// - date: An interface{} representing the date to be set. The actual type accepted can vary (e.g., string, time.Time), depending on implementation.
// Returns:
// - *OptionQuotesRequest: This method returns a pointer to the OptionQuotesRequest instance it was called on, allowing for method chaining. If the receiver (*OptionQuotesRequest) is nil, it returns nil to prevent a panic.
func (oqr *OptionQuoteRequest) Date(q interface{}) *OptionQuoteRequest <span class="cov0" title="0">{
        if oqr.dateParams == nil </span><span class="cov0" title="0">{
                oqr.dateParams = &amp;parameters.DateParams{}
        }</span>
        <span class="cov0" title="0">err := oqr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                oqr.Error = err
        }</span>
        <span class="cov0" title="0">return oqr</span>
}

// From sets the from parameter for the OptionQuotesRequest.
// This method is used to specify the start date of a date range for which the option quote is requested.
// Similar to the Date method, it accepts a flexible date input through an interface{} parameter.
// Parameters:
// - from: An interface{} representing the start date of the range to be set. The actual type accepted can vary, depending on implementation.
// Returns:
// - *OptionQuotesRequest: This method returns a pointer to the OptionQuotesRequest instance it was called on, allowing for method chaining. If the receiver (*OptionQuotesRequest) is nil, it returns nil to prevent a panic.
func (oqr *OptionQuoteRequest) From(q interface{}) *OptionQuoteRequest <span class="cov0" title="0">{
        if oqr.dateParams == nil </span><span class="cov0" title="0">{
                oqr.dateParams = &amp;parameters.DateParams{}
        }</span>
        <span class="cov0" title="0">err := oqr.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                oqr.Error = err
        }</span>
        <span class="cov0" title="0">return oqr</span>
}

// To sets the to parameter for the OptionQuotesRequest.
// This method is used to specify the end date of a date range for which the option quote is requested.
// It accepts a flexible date input through an interface{} parameter, similar to the From method.
// Parameters:
// - to: An interface{} representing the end date of the range to be set. The actual type accepted can vary, depending on implementation.
// Returns:
// - *OptionQuotesRequest: This method returns a pointer to the OptionQuotesRequest instance it was called on, allowing for method chaining. If the receiver (*OptionQuotesRequest) is nil, it returns nil to prevent a panic.
func (oqr *OptionQuoteRequest) To(q interface{}) *OptionQuoteRequest <span class="cov0" title="0">{
        if oqr.dateParams == nil </span><span class="cov0" title="0">{
                oqr.dateParams = &amp;parameters.DateParams{}
        }</span>
        <span class="cov0" title="0">err := oqr.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                oqr.Error = err
        }</span>
        <span class="cov0" title="0">return oqr</span>
}

// getParams packs the OptionQuotesRequest struct into a slice of interface{} and returns it.
// This method is used to gather all the parameters set in the OptionQuotesRequest into a single slice for easier manipulation and usage in subsequent requests.
// Returns:
// - []parameters.MarketDataParam: A slice containing all the parameters set in the OptionQuotesRequest.
// - error: An error object indicating failure to pack the parameters, nil if successful.
func (oqr *OptionQuoteRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if oqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionQuoteRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{oqr.symbolParams}
        return params, nil</span>
}

// Packed sends the OptionQuoteRequest and returns the OptionQuotesResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.OptionQuotesResponse: A pointer to the OptionQuotesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (oqr *OptionQuoteRequest) Packed(optionalClients ...*MarketDataClient) (*models.OptionQuotesResponse, error) <span class="cov0" title="0">{
        if oqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionQuoteRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                oqr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var oqrResp models.OptionQuotesResponse
        _, err := oqr.baseRequest.client.GetFromRequest(oqr.baseRequest, &amp;oqrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;oqrResp, nil</span>
}

// Get sends the OptionQuoteRequest, unpacks the OptionQuotesResponse, and returns a slice of OptionQuote.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.OptionQuote: A slice of OptionQuote containing the unpacked options quotes data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (oqr *OptionQuoteRequest) Get(optionalClients ...*MarketDataClient) ([]models.OptionQuote, error) <span class="cov0" title="0">{
        if oqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionQuoteRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">oqrResp, err := oqr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := oqrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// OptionQuotes creates a new OptionQuotesRequest and associates it with the provided client.
// If no client is provided, it uses the default client.
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided, the default client is used.
// Returns:
// - *OptionQuotesRequest: A pointer to the newly created OptionQuotesRequest with default parameters and associated client.
func OptionQuote(client ...*MarketDataClient) *OptionQuoteRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["options"]["quotes"]

        oqr := &amp;OptionQuoteRequest{
                baseRequest:  baseReq,
                symbolParams: &amp;parameters.SymbolParams{},
        }

        baseReq.child = oqr

        return oqr
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// OptionsStrikesRequest represents a request to the options strikes endpoint.
// It encapsulates parameters for underlying symbol, expiration, and date to be used in the request.
// This struct provides methods such as UnderlyingSymbol(), Expiration(), and Date() to set these parameters respectively.
//
// Public Methods:
// - UnderlyingSymbol(symbol string) *OptionsStrikesRequest: Sets the underlying symbol parameter for the request.
// - Expiration(expiration string) *OptionsStrikesRequest: Sets the expiration parameter for the request.
// - Date(date string) *OptionsStrikesRequest: Sets the date parameter for the request.
// - Packed() (*models.OptionsStrikesResponse, error): Sends the OptionsStrikesRequest and returns the OptionsStrikesResponse.
// - Get() ([]models.OptionsStrikes, error): Sends the OptionsStrikesRequest, unpacks the OptionsStrikesResponse, and returns a slice of OptionsStrikes.
type OptionsStrikesRequest struct {
        *baseRequest
        underlyingSymbol *parameters.SymbolParams
        expiration       *parameters.OptionParams
        date             *parameters.DateParams
}

// UnderlyingSymbol sets the underlying symbol parameter for the OptionsStrikesRequest.
// This method is used to specify the symbol of the underlying asset for which options strikes data is requested.
//
// Parameters:
// - underlyingSymbol: A string representing the symbol to be set.
//
// Returns:
// - *OptionsStrikesRequest: This method returns a pointer to the OptionsStrikesRequest instance it was called on. This allows for method chaining.
func (o *OptionsStrikesRequest) UnderlyingSymbol(underlyingSymbol string) *OptionsStrikesRequest <span class="cov0" title="0">{
        if o.underlyingSymbol == nil </span><span class="cov0" title="0">{
                o.underlyingSymbol = &amp;parameters.SymbolParams{}
        }</span>
        <span class="cov0" title="0">if err := o.underlyingSymbol.SetSymbol(underlyingSymbol); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

// Expiration sets the expiration parameter for the OptionsStrikesRequest.
// This method is used to specify the expiration date of the options for which strikes data is requested.
//
// Parameters:
// - expiration: A string representing the expiration date to be set.
//
// Returns:
// - *OptionsStrikesRequest: This method returns a pointer to the OptionsStrikesRequest instance it was called on. This allows for method chaining.
func (o *OptionsStrikesRequest) Expiration(expiration string) *OptionsStrikesRequest <span class="cov0" title="0">{
        if o.expiration == nil </span><span class="cov0" title="0">{
                o.expiration = &amp;parameters.OptionParams{}
        }</span>
        <span class="cov0" title="0">if err := o.expiration.SetExpiration(expiration); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

// Date sets the date parameter for the OptionsStrikesRequest.
// This method is used to specify the date for which the options strikes data is requested.
//
// Parameters:
// - date: A string representing the date to be set.
//
// Returns:
// - *OptionsStrikesRequest: This method returns a pointer to the OptionsStrikesRequest instance it was called on. This allows for method chaining.
func (o *OptionsStrikesRequest) Date(date string) *OptionsStrikesRequest <span class="cov0" title="0">{
        if o.date == nil </span><span class="cov0" title="0">{
                o.date = &amp;parameters.DateParams{}
        }</span>
        <span class="cov0" title="0">if err := o.date.SetDate(date); err != nil </span><span class="cov0" title="0">{
                o.Error = err
        }</span>
        <span class="cov0" title="0">return o</span>
}

func (o *OptionsStrikesRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsStrikesRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{o.underlyingSymbol, o.expiration, o.date}
        return params, nil</span>
}

// Packed sends the OptionsStrikesRequest and returns the OptionsStrikesResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.OptionsStrikesResponse: A pointer to the OptionsStrikesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (osr *OptionsStrikesRequest) Packed(optionalClients ...*MarketDataClient) (*models.OptionsStrikesResponse, error) <span class="cov0" title="0">{
        if osr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsStrikesRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                osr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var osrResp models.OptionsStrikesResponse
        _, err := osr.baseRequest.client.GetFromRequest(osr.baseRequest, &amp;osrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;osrResp, nil</span>
}

// Get sends the OptionsStrikesRequest, unpacks the OptionsStrikesResponse, and returns a slice of OptionsStrikes.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.OptionsStrikes: A slice of OptionsStrikes containing the unpacked options strikes data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (osr *OptionsStrikesRequest) Get(optionalClients ...*MarketDataClient) ([]models.OptionsStrikes, error) <span class="cov0" title="0">{
        if osr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OptionsStrikesRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">osrResp, err := osr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := osrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// OptionsStrikes creates a new OptionsStrikesRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for underlying symbol, expiration, and date, and sets the request path based on
// the predefined endpoints for options strikes.
//
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
//
// Returns:
// - *OptionsStrikesRequest: A pointer to the newly created OptionsStrikesRequest with default parameters and associated client.
func OptionsStrikes(client ...*MarketDataClient) *OptionsStrikesRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["options"]["strikes"]

        osr := &amp;OptionsStrikesRequest{
                baseRequest:      baseReq,
                underlyingSymbol: &amp;parameters.SymbolParams{},
                expiration:       &amp;parameters.OptionParams{},
                date:             &amp;parameters.DateParams{},
        }

        baseReq.child = osr

        return osr
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// StockCandlesRequest represents a request to the /v1/stocks/candles endpoint.
// It encapsulates parameters for resolution, symbol, date, and additional stock-specific parameters to be used in the request.
// This struct provides methods such as Resolution(), Symbol(), Date(), From(), To(), Countback(), AdjustSplits(), AdjustDividends(), Extended(), and Exchange() to set these parameters respectively.
//
// Public Methods:
// - Resolution(q string) *StockCandlesRequest: Sets the resolution parameter for the request.
// - Symbol(q string) *StockCandlesRequest: Sets the symbol parameter for the request.
// - Date(q interface{}) *StockCandlesRequest: Sets the date parameter for the request.
// - From(q interface{}) *StockCandlesRequest: Sets the 'from' date parameter for the request.
// - To(q interface{}) *StockCandlesRequest: Sets the 'to' date parameter for the request.
// - Countback(q int) *StockCandlesRequest: Sets the countback parameter for the request.
// - AdjustSplits(q bool) *StockCandlesRequest: Sets the adjust splits parameter for the request.
// - AdjustDividends(q bool) *StockCandlesRequest: Sets the adjust dividends parameter for the request.
// - Extended(q bool) *StockCandlesRequest: Sets the extended hours data parameter for the request.
// - Exchange(q string) *StockCandlesRequest: Sets the exchange parameter for the request.
// - Packed() (*models.StockCandlesResponse, error): Sends the StockCandlesRequest and returns the StockCandlesResponse.
// - Get() ([]models.StockCandle, error): Sends the StockCandlesRequest, unpacks the StockCandlesResponse, and returns a slice of StockCandle.
type StockCandlesRequest struct {
        *baseRequest
        stockCandleParams *parameters.StockCandleParams
        resolutionParams  *parameters.ResolutionParams
        symbolParams      *parameters.SymbolParams
        dateParams        *parameters.DateParams
}

// Resolution sets the resolution parameter for the StockCandlesRequest.
// This method is used to specify the granularity of the candle data to be retrieved.
//
// Parameters:
// - q: A string representing the resolution to be set.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (cr *StockCandlesRequest) Resolution(q string) *StockCandlesRequest <span class="cov8" title="1">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := cr.resolutionParams.SetResolution(q)
        if err != nil </span><span class="cov0" title="0">{
                cr.Error = err
        }</span>
        <span class="cov8" title="1">return cr</span>
}

// Symbol sets the symbol parameter for the StockCandlesRequest.
// This method is used to specify the stock symbol for which candle data is requested.
//
// Parameters:
// - q: A string representing the stock symbol to be set.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (cr *StockCandlesRequest) Symbol(q string) *StockCandlesRequest <span class="cov8" title="1">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := cr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                cr.Error = err
        }</span>
        <span class="cov8" title="1">return cr</span>
}

// Date sets the date parameter for the StockCandlesRequest.
// This method is used to specify the date for which the stock candle data is requested.
//
// Parameters:
// - q: An interface{} representing the date to be set.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) Date(q interface{}) *StockCandlesRequest <span class="cov8" title="1">{
        err := scr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                scr.baseRequest.Error = err
        }</span>
        <span class="cov8" title="1">return scr</span>
}

// From sets the 'from' date parameter for the StockCandlesRequest.
// This method is used to specify the starting point of the date range for which the stock candle data is requested.
//
// Parameters:
// - q: An interface{} representing the starting date.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) From(q interface{}) *StockCandlesRequest <span class="cov0" title="0">{
        err := scr.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                scr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return scr</span>
}

// To sets the 'to' date parameter for the StockCandlesRequest.
// This method is used to specify the ending point of the date range for which the stock candle data is requested.
//
// Parameters:
// - q: An interface{} representing the ending date.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on
func (scr *StockCandlesRequest) To(q interface{}) *StockCandlesRequest <span class="cov0" title="0">{
        err := scr.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                scr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return scr</span>
}

// Countback sets the countback parameter for the StockCandlesRequest.
// This method specifies the number of candles to return, counting backwards from the 'to' date.
//
// Parameters:
// - q: An int representing the number of candles to return.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) Countback(q int) *StockCandlesRequest <span class="cov0" title="0">{
        err := scr.dateParams.SetCountback(q)
        if err != nil </span><span class="cov0" title="0">{
                scr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return scr</span>
}

// AdjustSplits sets the adjust splits parameter for the StockCandlesRequest.
// This method indicates whether the returned data should be adjusted for stock splits.
//
// Parameters:
// - q: A bool indicating whether to adjust for splits.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) AdjustSplits(q bool) *StockCandlesRequest <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">scr.stockCandleParams.SetAdjustSplits(q)
        return scr</span>
}

// AdjustDividends sets the adjust dividends parameter for the StockCandlesRequest.
// This method indicates whether the returned data should be adjusted for dividends.
//
// Parameters:
// - q: A bool indicating whether to adjust for dividends.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) AdjustDividends(q bool) *StockCandlesRequest <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">scr.stockCandleParams.SetAdjustDividends(q)
        return scr</span>
}

// Extended sets the extended hours data parameter for the StockCandlesRequest.
// This method indicates whether the returned data should include extended hours trading data.
//
// Parameters:
// - q: A bool indicating whether to include extended hours data.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) Extended(q bool) *StockCandlesRequest <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">scr.stockCandleParams.SetExtended(q)
        return scr</span>
}

// Exchange sets the exchange parameter for the StockCandlesRequest.
// This method is used to specify the exchange from which the stock candle data is requested.
//
// Parameters:
// - q: A string representing the exchange to be set.
//
// Returns:
// - *StockCandlesRequest: This method returns a pointer to the StockCandlesRequest instance it was called on. This allows for method chaining.
func (scr *StockCandlesRequest) Exchange(q string) *StockCandlesRequest <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := scr.stockCandleParams.SetExchange(q)
        if err != nil </span><span class="cov0" title="0">{
                scr.baseRequest.Error = err
        }</span>
        <span class="cov0" title="0">return scr</span>
}

// getParams packs the CandlesRequest struct into a slice of interface{} and returns it.
func (scr *StockCandlesRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov8" title="1">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockCandlesRequest is nil")
        }</span>
        <span class="cov8" title="1">params := []parameters.MarketDataParam{scr.dateParams, scr.symbolParams, scr.resolutionParams, scr.stockCandleParams}
        return params, nil</span>
}

// Packed sends the StockCandlesRequest and returns the StockCandlesResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.StockCandlesResponse: A pointer to the StockCandlesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (scr *StockCandlesRequest) Packed(optionalClients ...*MarketDataClient) (*models.StockCandlesResponse, error) <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockCandlesRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                scr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var scrResp models.StockCandlesResponse
        _, err := scr.baseRequest.client.GetFromRequest(scr.baseRequest, &amp;scrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;scrResp, nil</span>
}

// Get sends the StockCandlesRequest, unpacks the StockCandlesResponse, and returns a slice of StockCandle.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual stock candle data
// from the stock candles request. The method first checks if the StockCandlesRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of StockCandle using the Unpack method from the response.
//
// Returns:
// - []models.StockCandle: A slice of StockCandle containing the unpacked candle data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func StockCandles(client ...*MarketDataClient) *StockCandlesRequest <span class="cov8" title="1">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["stocks"]["candles"]

        scr := &amp;StockCandlesRequest{
                baseRequest:       baseReq,
                dateParams:        &amp;parameters.DateParams{},
                resolutionParams:  &amp;parameters.ResolutionParams{},
                symbolParams:      &amp;parameters.SymbolParams{},
                stockCandleParams: &amp;parameters.StockCandleParams{},
        }

        // Set the date to the current time
        baseReq.child = scr

        return scr
}</span>

// Get sends the StockCandlesRequest, unpacks the StockCandlesResponse, and returns a slice of StockCandle.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.StockCandle: A slice of StockCandle containing the unpacked candle data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (scr *StockCandlesRequest) Get(optionalClients ...*MarketDataClient) ([]models.StockCandle, error) <span class="cov0" title="0">{
        if scr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockCandlesRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">scrResp, err := scr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := scrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockCandlesRequestV2 represents a request to the /v2/stocks/candles endpoint.
type StockCandlesRequestV2 struct {
        *baseRequest
        dateKey          *parameters.DateKeyParam
        resolutionParams *parameters.ResolutionParams
        symbolParams     *parameters.SymbolParams
}

// Resolution sets the resolution parameter for the CandlesRequest.
func (cr *StockCandlesRequestV2) Resolution(q string) *StockCandlesRequestV2 <span class="cov0" title="0">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := cr.resolutionParams.SetResolution(q)
        if err != nil </span><span class="cov0" title="0">{
                cr.Error = err
        }</span>
        <span class="cov0" title="0">return cr</span>
}

// Symbol sets the symbol parameter for the CandlesRequest.
func (cr *StockCandlesRequestV2) Symbol(q string) *StockCandlesRequestV2 <span class="cov0" title="0">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := cr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                cr.Error = err
        }</span>
        <span class="cov0" title="0">return cr</span>
}

// Date sets the date parameter for the CandlesRequest.
func (cr *StockCandlesRequestV2) DateKey(q string) *StockCandlesRequestV2 <span class="cov0" title="0">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := cr.dateKey.SetDateKey(q)
        if err != nil </span><span class="cov0" title="0">{
                cr.Error = err
        }</span>
        <span class="cov0" title="0">return cr</span>
}

// GetParams packs the CandlesRequest struct into a slice of interface{} and returns it.
func (cr *StockCandlesRequestV2) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if cr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CandlesRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{cr.dateKey, cr.resolutionParams, cr.symbolParams}
        return params, nil</span>
}

// Packed sends the StockCandlesRequestV2 and returns the StockCandlesResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.StockCandlesResponse: A pointer to the StockCandlesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (scrV2 *StockCandlesRequestV2) Packed(optionalClients ...*MarketDataClient) (*models.StockCandlesResponse, error) <span class="cov0" title="0">{
        if scrV2 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockCandlesRequestV2 is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                scrV2.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var scrResp models.StockCandlesResponse
        _, err := scrV2.baseRequest.client.GetFromRequest(scrV2.baseRequest, &amp;scrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;scrResp, nil</span>
}

// Get sends the StockCandlesRequestV2, unpacks the StockCandlesResponse, and returns a slice of StockCandle.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.StockCandle: A slice of StockCandle containing the unpacked candle data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (scrV2 *StockCandlesRequestV2) Get(optionalClients ...*MarketDataClient) ([]models.StockCandle, error) <span class="cov0" title="0">{
        if scrV2 == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockCandlesRequestV2 is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">scrResp, err := scrV2.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := scrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockCandles creates a new CandlesRequest and associates it with the provided client.
// If no client is provided, it uses the default client.
func StockCandlesV2(client ...*MarketDataClient) *StockCandlesRequestV2 <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[2]["stocks"]["candles"]

        cr := &amp;StockCandlesRequestV2{
                baseRequest:      baseReq,
                dateKey:          &amp;parameters.DateKeyParam{},
                resolutionParams: &amp;parameters.ResolutionParams{},
                symbolParams:     &amp;parameters.SymbolParams{},
        }

        // Set the date to the current time
        baseReq.child = cr

        return cr
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// StockEarningsRequest represents a request to the /stocks/earnings endpoint.
// It encapsulates parameters for symbol, report type, and date to be used in the request.
// This struct provides methods such as Report(), Symbol(), Date(), From(), To(), and Countback() to set these parameters respectively.
//
// Public Methods:
// - Report(q string) *StockEarningsRequest: Sets the report type parameter for the request.
// - Symbol(q string) *StockEarningsRequest: Sets the symbol parameter for the request.
// - Date(q interface{}) *StockEarningsRequest: Sets the date parameter for the request.
// - From(q interface{}) *StockEarningsRequest: Sets the 'from' date parameter for the request.
// - To(q interface{}) *StockEarningsRequest: Sets the 'to' date parameter for the request.
// - Countback(q int) *StockEarningsRequest: Sets the countback parameter for the request.
// - Packed() (*models.StockEarningsResponse, error): Sends the StockEarningsRequest and returns the StockEarningsResponse.
// - Get() ([]models.StockEarningsReport, error): Sends the StockEarningsRequest, unpacks the StockEarningsResponse, and returns a slice of StockEarningsReport.
type StockEarningsRequest struct {
        *baseRequest
        symbolParams        *parameters.SymbolParams
        stockEarningsParams *parameters.StockEarningsParams
        dateParams          *parameters.DateParams
}

// Report sets the report type parameter for the StockEarningsRequest.
// This method is used to specify which earnings report to be retrieved.
//
// Parameters:
// - q: A string representing which report to be returned.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) Report(q string) *StockEarningsRequest <span class="cov0" title="0">{
        if ser == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := ser.stockEarningsParams.SetReport(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// Symbol sets the symbol parameter for the StockEarningsRequest.
// This method is used to specify the stock symbol for which earnings data is requested.
//
// Parameters:
// - q: A string representing the stock symbol to be set.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) Symbol(q string) *StockEarningsRequest <span class="cov0" title="0">{
        if ser == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := ser.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// Date sets the date parameter for the StockEarningsRequest.
// This method is used to specify the date for which the stock earnings data is requested.
//
// Parameters:
// - q: An interface{} representing the date to be set.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) Date(q interface{}) *StockEarningsRequest <span class="cov0" title="0">{
        err := ser.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// From sets the 'from' date parameter for the StockEarningsRequest.
// This method is used to specify the starting point of the date range for which the stock earnings data is requested.
//
// Parameters:
// - q: An interface{} representing the starting date.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) From(q interface{}) *StockEarningsRequest <span class="cov0" title="0">{
        err := ser.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// To sets the 'to' date parameter for the StockEarningsRequest.
// This method is used to specify the ending point of the date range for which the stock earnings data is requested.
//
// Parameters:
// - q: An interface{} representing the ending date.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) To(q interface{}) *StockEarningsRequest <span class="cov0" title="0">{
        err := ser.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// Countback sets the countback parameter for the StockEarningsRequest.
// This method specifies the number of periods to return, counting backwards from the 'to' date.
//
// Parameters:
// - q: An int representing the number of periods to return.
//
// Returns:
// - *StockEarningsRequest: This method returns a pointer to the StockEarningsRequest instance it was called on. This allows for method chaining.
func (ser *StockEarningsRequest) Countback(q int) *StockEarningsRequest <span class="cov0" title="0">{
        err := ser.dateParams.SetCountback(q)
        if err != nil </span><span class="cov0" title="0">{
                ser.Error = err
        }</span>
        <span class="cov0" title="0">return ser</span>
}

// GetParams packs the StockEarningsRequest struct into a slice of interface{} and returns it.
func (ser *StockEarningsRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if ser == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockEarningsRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{ser.symbolParams, ser.dateParams, ser.stockEarningsParams}
        return params, nil</span>
}

// Packed sends the StockEarningsRequest and returns the StockEarningsResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.StockEarningsResponse: A pointer to the StockEarningsResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (ser *StockEarningsRequest) Packed(optionalClients ...*MarketDataClient) (*models.StockEarningsResponse, error) <span class="cov0" title="0">{
        if ser == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockEarningsRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                ser.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var serResp models.StockEarningsResponse
        _, err := ser.baseRequest.client.GetFromRequest(ser.baseRequest, &amp;serResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;serResp, nil</span>
}

// Get sends the StockEarningsRequest, unpacks the StockEarningsResponse, and returns a slice of StockEarningsReport.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.StockEarningsReport: A slice of StockEarningsReport containing the unpacked earnings data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (ser *StockEarningsRequest) Get(optionalClients ...*MarketDataClient) ([]models.StockEarningsReport, error) <span class="cov0" title="0">{
        if ser == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockEarningsRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">serResp, err := ser.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := serResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockEarnings creates a new StockEarningsRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for symbol, report type, and date, and sets the request path based on
// the predefined endpoints for stock earnings.
//
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
//
// Returns:
// - *StockEarningsRequest: A pointer to the newly created StockEarningsRequest with default parameters and associated client.
func StockEarnings(client ...*MarketDataClient) *StockEarningsRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["stocks"]["earnings"]

        ser := &amp;StockEarningsRequest{
                baseRequest:         baseReq,
                dateParams:          &amp;parameters.DateParams{},
                symbolParams:        &amp;parameters.SymbolParams{},
                stockEarningsParams: &amp;parameters.StockEarningsParams{},
        }

        baseReq.child = ser

        return ser
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// StockNewsRequest represents a request to the /stocks/news endpoint.
// It encapsulates parameters for symbol, date, and additional news-specific parameters to be used in the request.
// This struct provides methods such as Symbol(), Date(), From(), To(), and Countback() to set these parameters respectively.
//
// Public Methods:
// - Symbol(q string) *StockNewsRequest: Sets the symbol parameter for the request.
// - Date(q interface{}) *StockNewsRequest: Sets the date parameter for the request.
// - From(q interface{}) *StockNewsRequest: Sets the 'from' date parameter for the request.
// - To(q interface{}) *StockNewsRequest: Sets the 'to' date parameter for the request.
// - Countback(q int) *StockNewsRequest: Sets the countback parameter for the request.
type StockNewsRequest struct {
        *baseRequest
        symbolParams *parameters.SymbolParams
        dateParams   *parameters.DateParams
}


// Symbol sets the symbol parameter for the StockNewsRequest.
// This method is used to specify the stock symbol for which news data is requested.
//
// Parameters:
// - q: A string representing the stock symbol to be set.
//
// Returns:
// - *StockNewsRequest: This method returns a pointer to the StockNewsRequest instance it was called on. This allows for method chaining.
func (snr *StockNewsRequest) Symbol(q string) *StockNewsRequest <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := snr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                snr.Error = err
        }</span>
        <span class="cov0" title="0">return snr</span>
}

// Date sets the date parameter for the StockNewsRequest.
// This method is used to specify the date for which the stock news data is requested.
//
// Parameters:
// - q: An interface{} representing the date to be set.
//
// Returns:
// - *StockNewsRequest: This method returns a pointer to the StockNewsRequest instance it was called on. This allows for method chaining.
func (snr *StockNewsRequest) Date(q interface{}) *StockNewsRequest <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := snr.dateParams.SetDate(q)
        if err != nil </span><span class="cov0" title="0">{
                snr.Error = err
        }</span>
        <span class="cov0" title="0">return snr</span>
}

// From sets the 'from' date parameter for the StockNewsRequest.
// This method is used to specify the starting point of the date range for which the stock news data is requested.
//
// Parameters:
// - q: An interface{} representing the starting date.
//
// Returns:
// - *StockNewsRequest: This method returns a pointer to the StockNewsRequest instance it was called on. This allows for method chaining.
func (snr *StockNewsRequest) From(q interface{}) *StockNewsRequest <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := snr.dateParams.SetFrom(q)
        if err != nil </span><span class="cov0" title="0">{
                snr.Error = err
        }</span>
        <span class="cov0" title="0">return snr</span>
}

// To sets the 'to' date parameter for the StockNewsRequest.
// This method is used to specify the ending point of the date range for which the stock news data is requested.
//
// Parameters:
// - q: An interface{} representing the ending date.
//
// Returns:
// - *StockNewsRequest: This method returns a pointer to the StockNewsRequest instance it was called on. This allows for method chaining.
func (snr *StockNewsRequest) To(q interface{}) *StockNewsRequest <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := snr.dateParams.SetTo(q)
        if err != nil </span><span class="cov0" title="0">{
                snr.Error = err
        }</span>
        <span class="cov0" title="0">return snr</span>
}

// Countback sets the countback parameter for the StockNewsRequest.
// This method specifies the number of news items to return, counting backwards from the 'to' date.
//
// Parameters:
// - q: An int representing the number of news items to return.
//
// Returns:
// - *StockNewsRequest: This method returns a pointer to the StockNewsRequest instance it was called on. This allows for method chaining.
func (snr *StockNewsRequest) Countback(q int) *StockNewsRequest <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := snr.dateParams.SetCountback(q)
        if err != nil </span><span class="cov0" title="0">{
                snr.Error = err
        }</span>
        <span class="cov0" title="0">return snr</span>
}

// getParams packs the StockNewsRequest struct into a slice of interface{} and returns it.
func (snr *StockNewsRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockNewsRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{snr.symbolParams, snr.dateParams}
        return params, nil</span>
}

// Packed sends the StockNewsRequest and returns the StockNewsResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.StockNewsResponse: A pointer to the StockNewsResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (snr *StockNewsRequest) Packed(optionalClients ...*MarketDataClient) (*models.StockNewsResponse, error) <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockNewsRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                snr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var snrResp models.StockNewsResponse
        _, err := snr.baseRequest.client.GetFromRequest(snr.baseRequest, &amp;snrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;snrResp, nil</span>
}

// Get sends the StockNewsRequest, unpacks the StockNewsResponse, and returns a slice of StockNews.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.StockNews: A slice of StockNews containing the unpacked news data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (snr *StockNewsRequest) Get(optionalClients ...*MarketDataClient) ([]models.StockNews, error) <span class="cov0" title="0">{
        if snr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockNewsRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">snrResp, err := snr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := snrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockNews creates a new StockNewsRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for symbol, date, and additional news-specific parameters, and sets the request path based on
// the predefined endpoints for stock news.
//
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
//
// Returns:
// - *StockNewsRequest: A pointer to the newly created StockNewsRequest with default parameters and associated client.
func StockNews(client ...*MarketDataClient) *StockNewsRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["stocks"]["news"]

        snr := &amp;StockNewsRequest{
                baseRequest:  baseReq,
                symbolParams: &amp;parameters.SymbolParams{},
                dateParams:   &amp;parameters.DateParams{},
        }

        baseReq.child = snr

        return snr
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// StockQuoteRequest represents a request to the /stocks/quote endpoint.
// It encapsulates parameters for symbol and fifty-two-week data to be used in the request.
// This struct provides methods such as Symbol() and FiftyTwoWeek() to set these parameters respectively.
//
// Public Methods:
// - Symbol(q string) *StockQuoteRequest: Sets the symbol parameter for the request.
// - FiftyTwoWeek(q bool) *StockQuoteRequest: Sets the fifty-two-week data parameter for the request.
type StockQuoteRequest struct {
        *baseRequest
        symbolParams       *parameters.SymbolParams
        fiftyTwoWeekParams *parameters.FiftyTwoWeekParams
}

// Symbol sets the symbol parameter for the StockQuoteRequest.
// This method is used to specify the stock symbol for which quote data is requested.
//
// Parameters:
// - q: A string representing the stock symbol to be set.
//
// Returns:
// - *StockQuoteRequest: This method returns a pointer to the StockQuoteRequest instance it was called on. This allows for method chaining.
func (sqr *StockQuoteRequest) Symbol(q string) *StockQuoteRequest <span class="cov0" title="0">{
        if sqr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err := sqr.symbolParams.SetSymbol(q)
        if err != nil </span><span class="cov0" title="0">{
                sqr.Error = err
        }</span>
        <span class="cov0" title="0">return sqr</span>
}

// FiftyTwoWeek sets the fifty-two-week data parameter for the StockQuoteRequest.
// This method indicates whether to include fifty-two-week high and low data in the quote.
//
// Parameters:
// - q: A bool indicating whether to include fifty-two-week data.
//
// Returns:
// - *StockQuoteRequest: This method returns a pointer to the StockQuoteRequest instance it was called on. This allows for method chaining.
func (sqr *StockQuoteRequest) FiftyTwoWeek(q bool) *StockQuoteRequest <span class="cov0" title="0">{
        if sqr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sqr.fiftyTwoWeekParams.SetFiftyTwoWeek(q)
        return sqr</span>
}

// getParams packs the StockQuoteRequest struct into a slice of interface{} and returns it.
func (sqr *StockQuoteRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov0" title="0">{
        if sqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockQuoteRequest is nil")
        }</span>
        <span class="cov0" title="0">params := []parameters.MarketDataParam{sqr.symbolParams, sqr.fiftyTwoWeekParams}
        return params, nil</span>
}

// Packed sends the StockQuoteRequest and returns the StockQuotesResponse.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - *models.StockQuotesResponse: A pointer to the StockQuotesResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (sqr *StockQuoteRequest) Packed(optionalClients ...*MarketDataClient) (*models.StockQuotesResponse, error) <span class="cov0" title="0">{
        if sqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockQuoteRequest is nil")
        }</span>

        // Replace the client if an optional client is provided
        <span class="cov0" title="0">if len(optionalClients) &gt; 0 &amp;&amp; optionalClients[0] != nil </span><span class="cov0" title="0">{
                sqr.baseRequest.client = optionalClients[0]
        }</span>

        <span class="cov0" title="0">var sqrResp models.StockQuotesResponse
        _, err := sqr.baseRequest.client.GetFromRequest(sqr.baseRequest, &amp;sqrResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;sqrResp, nil</span>
}

// Get sends the StockQuoteRequest, unpacks the StockQuotesResponse, and returns a slice of StockQuote.
// It returns an error if the request or unpacking fails.
// An optional MarketDataClient can be passed to replace the client used in the request.
// Parameters:
// - optionalClients: A variadic parameter that can accept zero or one MarketDataClient pointer. If a client is provided,
//   it replaces the current client for this request.
// Returns:
// - []models.StockQuote: A slice of StockQuote containing the unpacked quote data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (sqr *StockQuoteRequest) Get(optionalClients ...*MarketDataClient) ([]models.StockQuote, error) <span class="cov0" title="0">{
        if sqr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("StockQuoteRequest is nil")
        }</span>
        
        // Use the Packed method to make the request, passing along any optional client
        <span class="cov0" title="0">sqrResp, err := sqr.Packed(optionalClients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := sqrResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockQuote creates a new StockQuoteRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with default parameters for symbol and fifty-two-week data, and sets the request path based on
// the predefined endpoints for stock quotes.
//
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
//
// Returns:
// - *StockQuoteRequest: A pointer to the newly created StockQuoteRequest with default parameters and associated client.
func StockQuote(client ...*MarketDataClient) *StockQuoteRequest <span class="cov0" title="0">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[1]["stocks"]["quotes"]

        sqr := &amp;StockQuoteRequest{
                baseRequest:        baseReq,
                symbolParams:       &amp;parameters.SymbolParams{},
                fiftyTwoWeekParams: &amp;parameters.FiftyTwoWeekParams{},
        }

        baseReq.child = sqr

        return sqr
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package stocks provides the /stocks endpoints
package client

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/parameters"
        "github.com/MarketDataApp/sdk-go/models"
)

// TickersRequest represents a request to the /stocks/tickers endpoint.
// It encapsulates the date parameter to be used in the request.
// This struct provides the method DateKey() to set this parameter.
//
// Public Methods:
// - DateKey(q string) *TickersRequest: Sets the date parameter for the TickersRequest.
type TickersRequest struct {
        *baseRequest
        dateKey *parameters.DateKeyParam
}

// DateKey sets the date parameter for the TickersRequest.
// This method is used to specify the date for which the stock tickers data is requested.
//
// Parameters:
// - q: A string representing the date to be set.
//
// Returns:
// - *TickersRequest: This method returns a pointer to the TickersRequest instance it was called on. This allows for method chaining.
func (tr *TickersRequest) DateKey(q string) *TickersRequest <span class="cov8" title="1">{
        if tr == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := tr.dateKey.SetDateKey(q)
        if err != nil </span><span class="cov0" title="0">{
                tr.Error = err
        }</span>
        <span class="cov8" title="1">return tr</span>
}

// getParams packs the TickersRequest struct into a slice of interface{} and returns it.
func (tr *TickersRequest) getParams() ([]parameters.MarketDataParam, error) <span class="cov8" title="1">{
        if tr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TickersRequest is nil")
        }</span>
        <span class="cov8" title="1">params := []parameters.MarketDataParam{tr.dateKey}
        return params, nil</span>
}

// Packed sends the TickersRequest and returns the TickersResponse.
// This method checks if the TickersRequest receiver is nil, returning an error if true.
// Otherwise, it proceeds to send the request and returns the TickersResponse along with any error encountered during the request.
//
// Returns:
// - *models.TickersResponse: A pointer to the TickersResponse obtained from the request.
// - error: An error object that indicates a failure in sending the request.
func (tr *TickersRequest) Packed() (*models.TickersResponse, error) <span class="cov8" title="1">{
        if tr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TickersRequest is nil")
        }</span>
        <span class="cov8" title="1">var trResp models.TickersResponse
        _, err := tr.baseRequest.client.GetFromRequest(tr.baseRequest, &amp;trResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;trResp, nil</span>
}

// Get sends the TickersRequest, unpacks the TickersResponse, and returns a slice of Ticker.
// It returns an error if the request or unpacking fails. This method is crucial for obtaining the actual stock tickers data
// from the stock tickers request. The method first checks if the TickersRequest receiver is nil, which would
// result in an error as the request cannot be sent. It then proceeds to send the request using the Packed method.
// Upon receiving the response, it unpacks the data into a slice of Ticker using the Unpack method from the response.
//
// Returns:
// - []models.Ticker: A slice of Ticker containing the unpacked tickers data from the response.
// - error: An error object that indicates a failure in sending the request or unpacking the response.
func (tr *TickersRequest) Get() ([]models.Ticker, error) <span class="cov0" title="0">{
        if tr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TickersRequest is nil")
        }</span>
        
        // Use the Packed method to make the request
        <span class="cov0" title="0">trResp, err := tr.Packed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unpack the data using the Unpack method in the response
        <span class="cov0" title="0">data, err := trResp.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// StockTickers creates a new TickersRequest and associates it with the provided client.
// If no client is provided, it uses the default client. This function initializes the request
// with the default date parameter and sets the request path based on
// the predefined endpoints for stock tickers.
//
// Parameters:
// - client: A variadic parameter that can accept zero or one MarketDataClient pointer. If no client is provided,
//   the default client is used.
//
// Returns:
// - *TickersRequest: A pointer to the newly created TickersRequest with default parameters and associated client.
func StockTickers(client ...*MarketDataClient) *TickersRequest <span class="cov8" title="1">{
        baseReq := newBaseRequest(client...)
        baseReq.path = endpoints[2]["stocks"]["tickers"]

        tr := &amp;TickersRequest{
                baseRequest: baseReq,
                dateKey:     &amp;parameters.DateKeyParam{},
        }

        // Set the date to the current time
        baseReq.child = tr

        return tr
}</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "fmt"

        api "github.com/MarketDataApp/sdk-go/client"
)

func rawHttpResponseExample() <span class="cov0" title="0">{
        resp, err := api.StockQuote().Symbol("AAPL").Raw()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(resp)</span>
}

func logExample() <span class="cov0" title="0">{
        _, err := api.IndexQuotes().Symbol("VIX").FiftyTwoWeek(true).Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(api.GetLogs())</span>

}

func marketStatusExample() <span class="cov0" title="0">{

        msr, err := api.MarketStatus().From("2022-01-01").To("2022-01-10").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(msr)</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "fmt"
        "time"

        api "github.com/MarketDataApp/sdk-go/client"
)

func indexQuoteExample() <span class="cov0" title="0">{
        iqe, err := api.IndexQuotes().Symbol("VIX").FiftyTwoWeek(true).Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Index Quote Response...")
        fmt.Println(iqe)

        unpacked, err := iqe.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Unpacked Index Quotes...")
        for _, quote := range unpacked </span><span class="cov0" title="0">{
                fmt.Println(quote)
        }</span>

}

func indexCandlesExample() <span class="cov0" title="0">{
        oneWeekAgo := time.Now().AddDate(0, 0, -7)
        ice, err := api.IndexCandles().Resolution("D").Symbol("VIX").From(oneWeekAgo).To("today").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Index Candles Response...")
        fmt.Println(ice)

        unpacked, err := ice.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Unpacked Index Candles...")
        for _, candle := range unpacked </span><span class="cov0" title="0">{
                fmt.Println(candle)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "fmt"

        api "github.com/MarketDataApp/sdk-go/client"
)

func optionsChainExample() <span class="cov0" title="0">{
        resp, err := api.OptionChain().UnderlyingSymbol("AAPL").Side("call").DTE(60).StrikeLimit(2).Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, contract := range resp </span><span class="cov0" title="0">{
                fmt.Println(contract)
        }</span>

}

func optionsQuotesExample() <span class="cov0" title="0">{
        resp, err := api.OptionQuote().OptionSymbol("AAPL250117C00150000").Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(resp)</span>

}

func optionsStrikesExample() <span class="cov0" title="0">{
        resp, err := api.OptionsStrikes().UnderlyingSymbol("AAPL").Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, expiration := range resp </span><span class="cov0" title="0">{
                fmt.Println(expiration)
        }</span>
}

func optionsLookupExample() <span class="cov0" title="0">{
        resp, err := api.OptionLookup().UserInput("AAPL 7/28/2023 200 Call").Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(resp)</span>
}

func optionsExpirationsExample() <span class="cov0" title="0">{
        resp, err := api.OptionsExpirations().UnderlyingSymbol("AAPL").Strike(200).Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, expirations := range resp </span><span class="cov0" title="0">{
                fmt.Println(expirations)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "fmt"

        api "github.com/MarketDataApp/sdk-go/client"
)

func stockQuoteExample() <span class="cov0" title="0">{
        sqe, err := api.StockQuote().Symbol("AAPL").FiftyTwoWeek(true).Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Stock Quote Response...")
        fmt.Println(sqe)

        unpacked, err := sqe.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Unpacked Stock Quotes...")
        for _, quote := range unpacked </span><span class="cov0" title="0">{
                fmt.Println(quote)
        }</span>
}

func stockCandlesExample() <span class="cov0" title="0">{

        sce, err := api.StockCandles().Resolution("1").Symbol("AAPL").From("2023-01-01").To("2023-01-04").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">candles, err := sce.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, candle := range candles </span><span class="cov0" title="0">{
                fmt.Println(candle)
        }</span>

}

func stockEarningsExample() <span class="cov0" title="0">{
        see, err := api.StockEarnings().Symbol("AAPL").From("2022-01-01").To("2022-12-31").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Printing Earnings Response...")
        fmt.Println(see)

        unpacked, err := see.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Priting Unpacked Earnings Reports...")
        for _, report := range unpacked </span><span class="cov0" title="0">{
                fmt.Println(report)
        }</span>
}


func stockNewsExample() <span class="cov0" title="0">{
        resp, err := api.StockNews().Symbol("AAPL").Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, news := range resp </span><span class="cov0" title="0">{
                fmt.Println(news)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "fmt"
        "log"
        "sort"
        "time"

        api "github.com/MarketDataApp/sdk-go/client"
        md "github.com/MarketDataApp/sdk-go/models"
)

func stockCandlesV2Example() <span class="cov0" title="0">{

        sce, err := api.StockCandlesV2().Resolution("1").Symbol("AAPL").DateKey("2023-01").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">candles, err := sce.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">for _, candle := range candles </span><span class="cov0" title="0">{
                fmt.Println(candle)
        }</span>
}

func stocksTickersV2Example() <span class="cov0" title="0">{
        tickers, err := api.StockTickers().DateKey("2023-01-05").Packed()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Print(err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println(tickers)</span>
}

func SaveTickersToCSV(startDate, endDate string, filename string) error <span class="cov0" title="0">{
        // Initialize the markets client

        marketStatusResp, err := api.MarketStatus().From(startDate).To(endDate).Packed()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get market status: %v", err)
        }</span>
        // Print out marketStatusResp for test run visibility
        <span class="cov0" title="0">fmt.Printf("Market Status Response: %v\n", marketStatusResp)

        openDates, err := marketStatusResp.GetOpenDates()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get open dates: %v", err)
        }</span>
        // Print out openDates for test run visibility
        <span class="cov0" title="0">fmt.Println("Open dates:")
        for _, date := range openDates </span><span class="cov0" title="0">{
                fmt.Printf("%v\n", date)
        }</span>

        // Sort dates in ascending order
        <span class="cov0" title="0">sort.Slice(openDates, func(i, j int) bool </span><span class="cov0" title="0">{
                return openDates[i].Before(openDates[j])
        }</span>)

        // Initialize the stocks client
        <span class="cov0" title="0">tickers := api.StockTickers()

        // Get TickersResponse for each date and combine them into a map
        tickerMap := make(map[string]md.Ticker)
        for _, date := range openDates </span><span class="cov0" title="0">{
                // Convert date to string in the format "YYYY-MM-DD"
                dateStr := date.Format("2006-01-02")

                // Get the TickersResponse for the date
                response, err := tickers.DateKey(dateStr).Packed()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert the response to a map
                <span class="cov0" title="0">responseMap, err := response.ToMap()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Merge the map into the combined map
                <span class="cov0" title="0">for key, value := range responseMap </span><span class="cov0" title="0">{
                        tickerMap[key] = value
                }</span>
        }

        // Get the keys of the tickerMap
        <span class="cov0" title="0">keys := make([]string, 0, len(tickerMap))
        for key := range tickerMap </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        // Sort the keys in alphabetical order
        <span class="cov0" title="0">sort.Strings(keys)

        // Create a new map with sorted keys
        sortedTickerMap := make(map[string]md.Ticker)
        for _, key := range keys </span><span class="cov0" title="0">{
                sortedTickerMap[key] = tickerMap[key]
        }</span>

        // Save the sorted map to a CSV file
        <span class="cov0" title="0">err = md.SaveToCSV(sortedTickerMap, filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func SaveSingleDayTickersToCSV(date time.Time, filename string) error <span class="cov8" title="1">{
        // Initialize the markets client

        // Initialize the stocks client
        tickers := api.StockTickers()

        // Convert date to string in the format "YYYY-MM-DD"
        dateStr := date.Format("2006-01-02")

        // Get the TickersResponse for the date
        response, err := tickers.DateKey(dateStr).Packed()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert the response to a map
        <span class="cov8" title="1">responseMap, err := response.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save the map to a CSV file
        <span class="cov8" title="1">err = md.SaveToCSV(responseMap, filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package dates

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// GenerateDateKeys generates a list of date keys between the provided start and end dates based on the provided keyType.
// The keyType can be "days", "weeks", "months", or "years".
// If the keyType is not recognized, the function returns an error.
// The function returns a slice of strings, each representing a date key, and an error.
func GenerateDateKeys(start, end time.Time, keyType string) ([]string, error) <span class="cov6" title="4">{
        var keys []string // Declare keys here

        switch keyType </span>{
        case "days":<span class="cov1" title="1">
                keys = GenerateDailyDateKeys(start, end)</span>
        case "weeks":<span class="cov1" title="1">
                keys = GenerateWeeklyDateKeys(start, end)</span>
        case "months":<span class="cov1" title="1">
                keys = GenerateMonthlyDateKeys(start, end)</span>
        case "years":<span class="cov1" title="1">
                keys = GenerateYearlyDateKeys(start, end)</span>
        default:<span class="cov0" title="0">
                // If the keyType is not recognized, return an error
                return nil, fmt.Errorf("invalid keyType: %s", keyType)</span>
        }

        <span class="cov6" title="4">return keys, nil</span>
}

// GenerateDailyDateKeys generates a list of date keys for each day between the start and end dates.
// The date keys are in the format "YYYY-MM-DD".
// The function includes the end date in the list of keys.
// The start and end dates should be in the same timezone.
func GenerateDailyDateKeys(startDate, endDate time.Time) []string <span class="cov1" title="1">{
        keys := []string{}

        // Loop over each day between the start and end dates, inclusive.
        for d := startDate; d.Before(endDate) || d.Equal(endDate); d = d.AddDate(0, 0, 1) </span><span class="cov5" title="3">{
                year, month, day := d.Date()
                // Generate a date key for the day and add it to the list.
                keys = append(keys, fmt.Sprintf("%d-%02d-%02d", year, month, day))
        }</span>

        // Return the list of date keys.
        <span class="cov1" title="1">return keys</span>
}

// GenerateWeeklyDateKeys generates a list of date keys for each week between the start and end dates.
// The date keys are in the format "YYYY-Www", where YYYY is the year and ww is the week number.
// The function includes the end date in the list of keys.
// The start and end dates should be in the same timezone.
// The start date is adjusted to the start of its week (Sunday) and the end date is adjusted to the end of its week (Saturday).
// If the start date is in the first week of the year, it is set to January 1st.
// If the end date is in the last week of the year, it is set to December 31st.
func GenerateWeeklyDateKeys(startDate, endDate time.Time) []string <span class="cov1" title="1">{
        keys := []string{}

        start := startDate.Add(-time.Duration(startDate.Weekday()) * 24 * time.Hour)
        if start.Year() &lt; startDate.Year() </span><span class="cov1" title="1">{
                start = time.Date(startDate.Year(), time.January, 1, 0, 0, 0, 0, startDate.Location())
        }</span>

        <span class="cov1" title="1">end := endDate
        if endDate.Weekday() != time.Saturday </span><span class="cov0" title="0">{
                end = endDate.Add(time.Duration(6-int(endDate.Weekday())) * 24 * time.Hour)
        }</span>
        <span class="cov1" title="1">if end.Year() &gt; endDate.Year() </span><span class="cov0" title="0">{
                end = time.Date(endDate.Year(), time.December, 31, 23, 59, 59, 999999999, endDate.Location())
        }</span>

        <span class="cov1" title="1">for d := start; !d.After(end); d = d.AddDate(0, 0, 7) </span><span class="cov5" title="3">{
                year, week := d.Year(), d.YearDay()/7+1
                keys = append(keys, fmt.Sprintf("%d-W%02d", year, week))
        }</span>

        <span class="cov1" title="1">return keys</span>
}

// GenerateMonthlyDateKeys generates a list of date keys for each month between the start and end dates.
// The date keys are in the format "YYYY-MM".
// The function includes the end date's month in the list of keys.
// The start and end dates should be in the same timezone.
func GenerateMonthlyDateKeys(startDate, endDate time.Time) []string <span class="cov1" title="1">{
        // Initialize an empty slice to hold the keys.
        keys := []string{}

        // Set the start date to the first day of the start month and the end date to the first day of the month following the end date.
        start := time.Date(startDate.Year(), startDate.Month(), 1, 0, 0, 0, 0, startDate.Location())
        end := time.Date(endDate.Year(), endDate.Month()+1, 1, 0, 0, 0, 0, endDate.Location())

        // Loop over each month between the start and end dates, inclusive.
        for d := start; d.Before(end); d = d.AddDate(0, 1, 0) </span><span class="cov6" title="4">{
                // Extract the year and month from the current date.
                year, month, _ := d.Date()
                // Generate a date key for the month and add it to the list.
                keys = append(keys, fmt.Sprintf("%d-%02d", year, month))
        }</span>

        // Return the list of date keys.
        <span class="cov1" title="1">return keys</span>
}

// GenerateYearlyDateKeys generates a list of date keys for each year between the start and end dates.
// The date keys are in the format "YYYY", where YYYY is the year.
// The function includes the end date in the list of keys.
// The start and end dates should be in the same timezone.
// The start date is adjusted to the start of its year (January 1st) and the end date is adjusted to the start of the next year.
// The function returns a slice of strings, each representing a date key for a year.
func GenerateYearlyDateKeys(startDate, endDate time.Time) []string <span class="cov1" title="1">{
        // Initialize an empty slice to hold the date keys
        keys := []string{}

        // Adjust the start date to the start of its year and the end date to the start of the next year
        start := time.Date(startDate.Year(), 1, 1, 0, 0, 0, 0, startDate.Location())
        end := time.Date(endDate.Year()+1, 1, 1, 0, 0, 0, 0, endDate.Location())

        // Generate a date key for each year between the start and end dates
        for d := start; d.Before(end); d = d.AddDate(1, 0, 0) </span><span class="cov6" title="4">{
                year, _, _ := d.Date()
                keys = append(keys, fmt.Sprintf("%d", year))
        }</span>

        // Return the list of date keys
        <span class="cov1" title="1">return keys</span>
}

// FromDailyDateKey converts a date key into a DateRange.
// The date key is expected to be in the format "YYYY-MM-DD".
// The function returns a DateRange with the StartDate and EndDate being the same day.
// If the key is not in the expected format or contains invalid date components, an error is returned.
func FromDailyDateKey(key string, loc *time.Location) (DateRange, error) <span class="cov6" title="4">{
        parts := strings.Split(key, "-")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid key format")
        }</span>

        <span class="cov6" title="4">year, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid year in key: %v", err)
        }</span>

        <span class="cov6" title="4">month, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid month in key: %v", err)
        }</span>

        <span class="cov6" title="4">day, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid day in key: %v", err)
        }</span>

        <span class="cov6" title="4">startDate := time.Date(year, time.Month(month), day, 0, 0, 0, 0, loc)
        endDate := time.Date(year, time.Month(month), day, 23, 59, 59, 999999999, loc)

        return DateRange{StartDate: startDate, EndDate: endDate}, nil</span>
}

// FromWeeklyDateKey takes a date key and a location as input and returns a DateRange and an error.
// The date key should be in the format "YYYY-Www", where YYYY is the year and ww is the week number (e.g., 2020-W01).
// The location is used to set the timezone for the start and end dates in the DateRange.
// The function calculates the start and end dates of the week specified in the date key.
// The start date is the Sunday of the week and the end date is the Saturday of the week.
// If the date key is not in the correct format or if the week number is not between 1 and 53, the function returns an error.
func FromWeeklyDateKey(key string, loc *time.Location) (DateRange, error) <span class="cov5" title="3">{
        parts := strings.Split(key, "-W")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid key format")
        }</span>

        <span class="cov5" title="3">year, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid year in key: %v", err)
        }</span>

        <span class="cov5" title="3">week, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid week in key: %v", err)
        }</span>

        <span class="cov5" title="3">if week &lt; 1 || week &gt; 53 </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("week must be between 1 and 53")
        }</span>

        // Calculate the start date of the year
        <span class="cov5" title="3">startDate := time.Date(year, time.January, 1, 0, 0, 0, 0, loc)

        // If January 1st is not a Sunday, adjust the start date to the next Sunday
        if startDate.Weekday() != time.Sunday </span><span class="cov5" title="3">{
                daysToNextSunday := 7 - int(startDate.Weekday())
                startDate = startDate.AddDate(0, 0, daysToNextSunday)
        }</span>

        // Calculate the start date of the week
        <span class="cov5" title="3">startDate = startDate.AddDate(0, 0, (week-1)*7)

        // Calculate the end date of the week
        endDate := startDate.AddDate(0, 0, 6)
        endDate = time.Date(endDate.Year(), endDate.Month(), endDate.Day(), 23, 59, 59, 999999999, loc)
        return DateRange{StartDate: startDate, EndDate: endDate}, nil</span>
}

// FromMonthlyDateKey converts a date key into a DateRange.
// The date key is expected to be in the format "YYYY-MM".
// The function returns a DateRange with the StartDate being the first day of the month and the EndDate being the last day of the same month.
// If the key is not in the expected format or contains invalid date components, an error is returned.
func FromMonthlyDateKey(key string, loc *time.Location) (DateRange, error) <span class="cov6" title="4">{
        parts := strings.Split(key, "-")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid key format")
        }</span>

        <span class="cov6" title="4">year, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov1" title="1">{
                return DateRange{}, fmt.Errorf("invalid year in key: %v", err)
        }</span>

        <span class="cov5" title="3">month, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("invalid month in key: %v", err)
        }</span>

        <span class="cov5" title="3">if month &lt; 1 || month &gt; 12 </span><span class="cov0" title="0">{
                return DateRange{}, fmt.Errorf("month must be between 1 and 12")
        }</span>

        <span class="cov5" title="3">startDate := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, loc)
        endDate := time.Date(year, time.Month(month+1), 0, 23, 59, 59, 999999999, loc)

        return DateRange{StartDate: startDate, EndDate: endDate}, nil</span>
}

// FromYearlyDateKey converts a date key into a DateRange.
// The date key is expected to be in the format "YYYY".
// The function returns a DateRange with the StartDate being the first day of the year and the EndDate being the last day of the same year.
// If the key is not in the expected format or contains an invalid year, an error is returned.
func FromYearlyDateKey(key string, loc *time.Location) (DateRange, error) <span class="cov6" title="4">{
        year, err := strconv.Atoi(key)
        if err != nil </span><span class="cov1" title="1">{
                return DateRange{}, fmt.Errorf("invalid year in key: %v", err)
        }</span>

        <span class="cov5" title="3">startDate := time.Date(year, time.January, 1, 0, 0, 0, 0, loc)
        endDate := time.Date(year, time.December, 31, 23, 59, 59, 999999999, loc)

        return DateRange{StartDate: startDate, EndDate: endDate}, nil</span>
}

// DateKeyToDateRange creates a new DateRange instance from a date key.
// It accepts a date key of type string and an optional time zone.
// If the time zone is not provided, the default time zone is used.
// The function returns a pointer to the new DateRange instance and any errors that occurred during the creation.
func DateKeyToDateRange(dateKey string, tz ...*time.Location) (*DateRange, error) <span class="cov10" title="11">{
        // Define the location
        var loc *time.Location
        if len(tz) &gt; 0 </span><span class="cov0" title="0">{
                loc = tz[0]
        }</span> else<span class="cov10" title="11"> {
                loc = DefaultTZ // replace with your default time zone
        }</span>

        // Create a new DateRange instance
        <span class="cov10" title="11">dateRange := &amp;DateRange{}
        // Set the DateRange from the date key
        err := dateRange.SetFromDateKey(dateKey, loc)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="9">return dateRange, nil</span>
}

// GetDateKeyType identifies the type of the date key.
// It accepts a date key of type string.
// The function returns the type of the date key and any errors that occurred during the identification.
// The possible types are "days", "months", "years", and "weeks".
// If the date key is not valid or its type is unknown, an error is returned.
func GetDateKeyType(dateKey string) (string, error) <span class="cov7" title="5">{
        if !IsValidDateKey(dateKey) </span><span class="cov1" title="1">{
                return "", fmt.Errorf("invalid date key")
        }</span>
        <span class="cov6" title="4">switch </span>{
        case len(dateKey) == 10 &amp;&amp; dateKey[4] == '-' &amp;&amp; dateKey[7] == '-':<span class="cov1" title="1">
                return "days", nil</span>
        case len(dateKey) == 7 &amp;&amp; dateKey[4] == '-':<span class="cov1" title="1">
                return "months", nil</span>
        case len(dateKey) == 4:<span class="cov1" title="1">
                return "years", nil</span>
        case len(dateKey) &gt; 4 &amp;&amp; strings.Contains(dateKey, "-W"):<span class="cov1" title="1">
                return "weeks", nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unknown date key type")</span>
        }
}

// IsValidDateKey checks if the provided date key is valid.
// It accepts a date key of type string.
// The function returns true if the date key is valid, false otherwise.
func IsValidDateKey(dateKey string) bool <span class="cov10" title="11">{
        // Try to convert the date key into a DateRange
        _, err := DateKeyToDateRange(dateKey)
        // If the conversion is successful, the date key is valid
        return err == nil
}</pre>
		
		<pre class="file" id="file23" style="display: none">// Package dates provides utilities for parsing, formatting, and manipulating dates and times.
// It includes functions to parse dates with or without time zones, handle date ranges,
// and convert dates to various formats. It also defines constants for different time precisions
// and initializes default time zones and date formats.
package dates

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"
)

// TimeInterval represents a duration object
type TimeInterval struct {
        Duration      time.Duration
        IntervalType  string
        IntervalValue int
}

func (ti *TimeInterval) SetInterval(interval string) error <span class="cov5" title="13">{
        // Check if interval matches any of the regular expressions
        for _, regexType := range regexes </span><span class="cov10" title="119">{
                if matches := regexType.regex.FindStringSubmatch(interval); matches != nil </span><span class="cov5" title="12">{
                        intervalValue, err := strconv.Atoi(matches[1]) // Get the numeric part of the interval
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid interval value: %v", err)
                        }</span>

                        // Set the IntervalValue field
                        <span class="cov5" title="12">ti.IntervalValue = intervalValue

                        switch regexType.timeUnit </span>{
                        case "second":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * time.Second</span>
                        case "minute":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * time.Minute</span>
                        case "hour":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * time.Hour</span>
                        case "day":<span class="cov0" title="0">
                                if matches[1] == "" </span><span class="cov0" title="0">{
                                        ti.Duration = 24 * time.Hour
                                }</span> else<span class="cov0" title="0"> {
                                        intervalValue, err := strconv.Atoi(matches[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid interval value: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">ti.Duration = time.Duration(intervalValue) * 24 * time.Hour</span>
                                }
                        case "week":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * 7 * 24 * time.Hour</span>
                        case "month":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * 30 * 24 * time.Hour</span> // Approximation
                        case "year":<span class="cov2" title="2">
                                ti.Duration = time.Duration(intervalValue) * 365 * 24 * time.Hour</span> // Approximation
                        }
                        <span class="cov5" title="12">ti.IntervalType = regexType.timeUnit
                        return nil</span>
                }
        }

        // If no match found, return an error
        <span class="cov1" title="1">return fmt.Errorf("invalid interval parameter: %s", interval)</span>
}

// DateRange represents a range of dates with a start and end date.
type DateRange struct {
        StartDate time.Time
        EndDate   time.Time
}

// UnixTimestamps returns the start and end dates as Unix timestamps.
func (dr *DateRange) UnixTimestamps() (int64, int64) <span class="cov0" title="0">{
        return dr.StartDate.Unix(), dr.EndDate.Unix()
}</span>

func (dr *DateRange) StopwatchStart() <span class="cov0" title="0">{
        dr.StartDate = time.Now()
}</span>

func (dr *DateRange) StopwatchEnd() <span class="cov0" title="0">{
        dr.EndDate = time.Now()
}</span>

func StopwatchStart() *DateRange <span class="cov0" title="0">{
        return &amp;DateRange{
                StartDate: time.Now(),
        }
}</span>

// SetDates sets the start and end dates of the DateRange.
// It accepts two parameters for the start and end dates, which can be of type time.Time or string.
// If the dates are strings, they are parsed using the ParseDateInput function.
// An optional time zone can be provided as the third parameter. If not provided, the default time zone is used.
// The function returns an error if the start or end date is invalid or if they cannot be parsed.
func (dr *DateRange) SetDates(startDate, endDate interface{}, defaultTZ ...*time.Location) error <span class="cov6" title="19">{
        var start, end time.Time
        var err error
        var tz *time.Location

        if len(defaultTZ) &gt; 0 </span><span class="cov4" title="6">{
                tz = defaultTZ[0]
        }</span> else<span class="cov5" title="13"> {
                tz = DefaultTZ
        }</span>

        <span class="cov6" title="19">if startDate != nil </span><span class="cov6" title="19">{
                switch v := startDate.(type) </span>{
                case time.Time:<span class="cov5" title="12">
                        start = v</span>
                default:<span class="cov4" title="7">
                        start, _, err = ParseDateInput(startDate, tz)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid start date: %v", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("start date cannot be nil")
        }</span>

        <span class="cov6" title="19">if endDate != nil </span><span class="cov6" title="19">{
                switch v := endDate.(type) </span>{
                case time.Time:<span class="cov5" title="12">
                        end = v</span>
                default:<span class="cov4" title="7">
                        end, _, err = ParseDateInput(endDate, tz)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid end date: %v", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("end date cannot be nil")
        }</span>

        <span class="cov6" title="19">dr.StartDate = start
        dr.EndDate = end

        return nil</span>
}

// DurationInMs returns the duration of the DateRange in milliseconds.
// It throws an error if either the start or end date is null.
func (dr *DateRange) DurationInMs() (int, error) <span class="cov0" title="0">{
        if dr.StartDate.IsZero() || dr.EndDate.IsZero() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("start date and end date cannot be nil")
        }</span>

        <span class="cov0" title="0">duration := dr.EndDate.Sub(dr.StartDate)
        return int(duration.Milliseconds()), nil</span>
}

// Duration returns the duration of the DateRange.
func (dr *DateRange) Duration() time.Duration <span class="cov0" title="0">{
        return dr.EndDate.Sub(dr.StartDate)
}</span>

// ValidateTimestamps checks if the provided timestamps are contained within the current DateRange.
// It returns two slices of timestamps: the first one contains valid timestamps, the second one contains invalid timestamps.
func (dr *DateRange) ValidateTimestamps(timestamps ...int64) (validTimestamps, invalidTimestamps []int64) <span class="cov3" title="3">{
        for _, ts := range timestamps </span><span class="cov5" title="12">{
                t, _, err := ParseDateInput(ts)
                if err != nil </span><span class="cov0" title="0">{
                        invalidTimestamps = append(invalidTimestamps, ts)
                        continue</span>
                }
                <span class="cov5" title="12">if dr.Contains(t) </span><span class="cov4" title="6">{
                        validTimestamps = append(validTimestamps, ts)
                }</span> else<span class="cov4" title="6"> {
                        invalidTimestamps = append(invalidTimestamps, ts)
                }</span>
        }
        <span class="cov3" title="3">return validTimestamps, invalidTimestamps</span>
}


// GenerateDateKeys generates a list of date keys for a DateRange based on the provided keyType.
// The keyType can be "days", "weeks", "months", or "years".
// The function uses the StartDate and EndDate of the DateRange to generate the keys.
// If the keyType is not recognized, the function returns an empty slice.
// The function returns a slice of strings, each representing a date key.
func (dr *DateRange) GenerateDateKeys(keyType string) ([]string, error) <span class="cov3" title="4">{
        return GenerateDateKeys(dr.StartDate, dr.EndDate, keyType)
}</span>


// Contains checks if the provided time or DateRange (the argument) is wholly contained within the DateRange on which the method is called (the reference DateRange).
func (dr *DateRange) Contains(t interface{}) bool <span class="cov7" title="30">{
        if t == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="30">var timeToCheckStart, timeToCheckEnd time.Time

        switch v := t.(type) </span>{
        case time.Time:<span class="cov6" title="24">
                timeToCheckStart = v
                timeToCheckEnd = v</span>
        case DateRange:<span class="cov4" title="6">
                timeToCheckStart = v.StartDate
                timeToCheckEnd = v.EndDate</span>
        default:<span class="cov0" title="0">
                var err error
                timeToCheckStart, _, err = ParseDateInput(v)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">timeToCheckEnd = timeToCheckStart</span>
        }

        <span class="cov7" title="30">return !dr.StartDate.After(timeToCheckStart) &amp;&amp; !dr.EndDate.Before(timeToCheckEnd)</span>
}

// DoesNotContain checks if the provided time or DateRange (the argument) is entirely outside the DateRange on which the method is called (the reference DateRange).
func (dr *DateRange) DoesNotContain(t interface{}) bool <span class="cov5" title="10">{
        if t == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="10">var timeToCheckStart, timeToCheckEnd time.Time

        switch v := t.(type) </span>{
        case time.Time:<span class="cov2" title="2">
                timeToCheckStart = v
                timeToCheckEnd = v</span>
        case DateRange:<span class="cov4" title="8">
                timeToCheckStart = v.StartDate
                timeToCheckEnd = v.EndDate</span>
        default:<span class="cov0" title="0">
                var err error
                timeToCheckStart, _, err = ParseDateInput(v)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">timeToCheckEnd = timeToCheckStart</span>
        }

        <span class="cov5" title="10">return dr.StartDate.After(timeToCheckEnd) || dr.EndDate.Before(timeToCheckStart)</span>
}

// PartiallyContains checks if the provided DateRange (the argument) partially intersects with the DateRange on which the method is called (the reference DateRange).
func (dr *DateRange) PartiallyContains(other DateRange) bool <span class="cov3" title="3">{
        // Check if the times are entirely within or entirely without one another
        if dr.Contains(other) || dr.DoesNotContain(other) </span><span class="cov2" title="2">{
                return false
        }</span>

        // If neither of the above conditions is met, the times partially intersect
        <span class="cov1" title="1">return true</span>
}

// NewDateRange is a function that creates a new DateRange instance.
// It accepts two parameters for the start and end dates, which can be of type time.Time or string.
// An optional time zone can be provided as the third parameter. If not provided, the default time zone is used.
// The function returns a pointer to the new DateRange instance and any errors that occurred during the creation.
func NewDateRange(startDate, endDate interface{}, defaultTZ ...*time.Location) (*DateRange, error) <span class="cov5" title="13">{
        dr := &amp;DateRange{}
        err := dr.SetDates(startDate, endDate, defaultTZ...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="13">return dr, nil</span>
}

// SetFromDateKey sets the DateRange from a date key.
// The date key can be in the format "YYYY-Www" for weekly, "YYYY-MM-DD" for daily, "YYYY-MM" for monthly, or "YYYY" for yearly.
// The function uses the provided location to set the timezone for the start and end dates in the DateRange.
// If the date key is not in the correct format or contains invalid date components, the function returns an error.
func (dr *DateRange) SetFromDateKey(key string, loc *time.Location) error <span class="cov6" title="15">{
        var err error
        if strings.Contains(key, "-W") </span><span class="cov3" title="3">{
                *dr, err = FromWeeklyDateKey(key, loc)
        }</span> else<span class="cov5" title="12"> if strings.Count(key, "-") == 2 </span><span class="cov3" title="4">{
                *dr, err = FromDailyDateKey(key, loc)
        }</span> else<span class="cov4" title="8"> if strings.Count(key, "-") == 1 </span><span class="cov3" title="4">{
                *dr, err = FromMonthlyDateKey(key, loc)
        }</span> else<span class="cov3" title="4"> {
                *dr, err = FromYearlyDateKey(key, loc)
        }</span>
        <span class="cov6" title="15">return err</span>
}

func (dr DateRange) String() string <span class="cov2" title="2">{
        return fmt.Sprintf("StartDate: RFC3339: %s\nEndDate: RFC3339: %s\n",
                dr.StartDate.Format(time.RFC3339),
                dr.EndDate.Format(time.RFC3339))
}</span>

// IsEarlierThan is a method that takes a parameter of type interface.
// It converts the parameter to a Time when necessary and compares if the start date of the value is earlier than the start date of our reference DateRange.
func (dr *DateRange) IsEarlierThan(date interface{}) (bool, error) <span class="cov3" title="4">{
        var compareDate time.Time
        switch date := date.(type) </span>{
        case int, int64, string, float32, float64:<span class="cov1" title="1">
                parsedDate, _, err := ParseDateInput(date)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov0" title="0">compareDate = parsedDate</span>
        case time.Time:<span class="cov3" title="3">
                compareDate = date</span>
        case *DateRange:<span class="cov0" title="0">
                compareDate = date.StartDate</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid type for date: IsEarlierThan")</span>
        }
        <span class="cov3" title="3">return dr.StartDate.Before(compareDate), nil</span>
}

// IsLaterThan is a method that takes a parameter of type interface.
// It converts the parameter to a Time when necessary and compares if the end date of the DateRange is later than the end date of the paramter passed.
func (dr *DateRange) IsLaterThan(date interface{}) (bool, error) <span class="cov3" title="4">{
        var compareDate time.Time
        switch date := date.(type) </span>{
        case int, int64, string, float32, float64:<span class="cov1" title="1">
                parsedDate, _, err := ParseDateInput(date)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov0" title="0">compareDate = parsedDate</span>
        case time.Time:<span class="cov3" title="3">
                compareDate = date</span>
        case *DateRange:<span class="cov0" title="0">
                compareDate = date.EndDate</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid type for date: IsLaterThan")</span>
        }
        <span class="cov3" title="3">return dr.EndDate.After(compareDate), nil</span>
}

// GetDateRange is a function that takes in a timezone, dateInput, fromInput, and toInput as strings.
// It returns a DateRange and an error.
// The function converts the date inputs to a DateRange,
// and returns the DateRange and any errors that occurred during the conversion.
func GetDateRange(defaultTZ *time.Location, dateInput, fromInput, toInput string) (DateRange, error) <span class="cov3" title="3">{
        var dr DateRange

        // If a single date is provided, convert it to a DateRange
        if dateInput != "" </span><span class="cov2" title="2">{
                singleDate, _, err := ParseDateInput(dateInput, defaultTZ)
                if err != nil </span><span class="cov1" title="1">{
                        return dr, err
                }</span>
                // Set the start and end dates of the DateRange to the single date
                <span class="cov1" title="1">dr.StartDate = singleDate
                dr.EndDate = time.Date(singleDate.Year(), singleDate.Month(), singleDate.Day(), 23, 59, 59, 999999999, defaultTZ)</span>
        } else<span class="cov1" title="1"> if fromInput != "" &amp;&amp; toInput != "" </span><span class="cov1" title="1">{
                // If a date range is provided, convert the start and end dates to a DateRange
                fromDate, _, err := ParseDateInput(fromInput, defaultTZ)
                if err != nil </span><span class="cov0" title="0">{
                        return dr, err
                }</span>
                <span class="cov1" title="1">toDate, _, err := ParseDateInput(toInput, defaultTZ)
                if err != nil </span><span class="cov0" title="0">{
                        return dr, err
                }</span>
                // Set the start and end dates of the DateRange to the provided range
                <span class="cov1" title="1">dr.StartDate = fromDate
                dr.EndDate = toDate</span>
        } else<span class="cov0" title="0"> {
                // If no valid date or date range is provided, return an error
                return dr, fmt.Errorf("invalid date input provided")
        }</span>

        // Return the DateRange and any errors
        <span class="cov2" title="2">return dr, nil</span>
}

// CombineDateRanges is a function that takes multiple DateRange objects or a slice of DateRange objects
// and uses the Earliest and Latest functions to generate a new DateRange object that covers the entire time range of the original objects.
func CombineDateRanges(dates ...interface{}) (DateRange, error) <span class="cov2" title="2">{
        var combined DateRange

        // Check if the first argument is a slice of DateRange
        if len(dates) == 1 </span><span class="cov1" title="1">{
                if dateRanges, ok := dates[0].([]DateRange); ok </span><span class="cov1" title="1">{
                        // Convert the slice of DateRange to a slice of interface{}
                        dates = make([]interface{}, len(dateRanges))
                        for i, dr := range dateRanges </span><span class="cov3" title="3">{
                                dates[i] = dr
                        }</span>
                }
        }

        <span class="cov2" title="2">earliestDate, err1 := Earliest(dates...)
        latestDate, err2 := Latest(dates...)
        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return combined, fmt.Errorf("error calculating date ranges: %v, %v", err1, err2)
        }</span>

        <span class="cov2" title="2">combined.StartDate = earliestDate
        combined.EndDate = latestDate

        return combined, nil</span>
}

func Earliest(dates ...interface{}) (time.Time, error) <span class="cov5" title="12">{
        var earliest time.Time

        // Check if the first argument is a slice of DateRange or a slice of int64
        if len(dates) == 1 </span><span class="cov5" title="9">{
                switch v := dates[0].(type) </span>{
                case []DateRange:<span class="cov0" title="0">
                        // Convert the slice of DateRange to a slice of interface{}
                        dates = make([]interface{}, len(v))
                        for i, dr := range v </span><span class="cov0" title="0">{
                                dates[i] = dr
                        }</span>
                case []int64:<span class="cov5" title="9">
                        // Convert the slice of int64 to a slice of time.Time
                        dates = make([]interface{}, len(v))
                        for i, timestamp := range v </span><span class="cov9" title="73">{
                                dates[i] = time.Unix(timestamp, 0)
                        }</span>
                }
        }

        <span class="cov5" title="12">for _, date := range dates </span><span class="cov9" title="84">{
                var t time.Time
                var err error
                switch v := date.(type) </span>{
                case time.Time:<span class="cov9" title="76">
                        t = v</span>
                case DateRange:<span class="cov4" title="7">
                        t = v.StartDate</span>
                default:<span class="cov1" title="1">
                        t, _, err = ParseDateInput(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return time.Time{}, err
                        }</span>
                }
                <span class="cov9" title="84">if earliest.IsZero() || t.Before(earliest) </span><span class="cov5" title="12">{
                        earliest = t
                }</span>
        }
        <span class="cov5" title="12">if earliest.IsZero() </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("no valid dates provided")
        }</span>
        <span class="cov5" title="12">return earliest, nil</span>
}

func Latest(dates ...interface{}) (time.Time, error) <span class="cov5" title="12">{
        var latest time.Time

        // Check if the first argument is a slice of DateRange or a slice of int64
        if len(dates) == 1 </span><span class="cov5" title="9">{
                switch v := dates[0].(type) </span>{
                case []DateRange:<span class="cov0" title="0">
                        // Convert the slice of DateRange to a slice of interface{}
                        dates = make([]interface{}, len(v))
                        for i, dr := range v </span><span class="cov0" title="0">{
                                dates[i] = dr
                        }</span>
                case []int64:<span class="cov5" title="9">
                        // Convert the slice of int64 to a slice of time.Time
                        dates = make([]interface{}, len(v))
                        for i, timestamp := range v </span><span class="cov9" title="73">{
                                dates[i] = time.Unix(timestamp, 0)
                        }</span>
                }
        }

        <span class="cov5" title="12">for _, date := range dates </span><span class="cov9" title="84">{
                var t time.Time
                var err error
                switch v := date.(type) </span>{
                case time.Time:<span class="cov9" title="76">
                        t = v</span>
                case DateRange:<span class="cov4" title="7">
                        t = v.EndDate</span>
                default:<span class="cov1" title="1">
                        t, _, err = ParseDateInput(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return time.Time{}, err
                        }</span>
                }
                <span class="cov9" title="84">if latest.IsZero() || t.After(latest) </span><span class="cov9" title="84">{
                        latest = t
                }</span>
        }
        <span class="cov5" title="12">if latest.IsZero() </span><span class="cov0" title="0">{
                return time.Time{}, errors.New("no valid dates provided")
        }</span>
        <span class="cov5" title="12">return latest, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package dates

import (
        "time"
        "os"
        "regexp"
)

// Constants for different time precisions
const (
        YearPrecision        = "year"        // Represents year precision
        MonthPrecision       = "month"       // Represents month precision
        DayPrecision         = "day"         // Represents day precision
        HourPrecision        = "hour"        // Represents hour precision
        MinutePrecision      = "minute"      // Represents minute precision
        SecondPrecision      = "second"      // Represents second precision
        MillisecondPrecision = "millisecond" // Represents millisecond precision
        MicrosecondPrecision = "microsecond" // Represents microsecond precision
        NanosecondPrecision  = "nanosecond"  // Represents nanosecond precision
)

// excelEpoch represents the start date for Excel's epoch which is December 30, 1899
var excelEpoch = time.Date(1899, time.December, 30, 0, 0, 0, 0, time.UTC)

// timeFormatsNoTZ is a slice of TimeFormats that stores the date formats without timezone.
var timeFormatsNoTZ []TimeFormats

// timeFormatsWithTZ is a slice of TimeFormats that stores the date formats with timezone.
var timeFormatsWithTZ []TimeFormats

// DefaultTZ is a pointer to a time.Location that stores the default timezone.
var DefaultTZ *time.Location

// RegexType is used for storing a regular expression and the timeUnit it parses to.
type RegexType struct {
        regex    *regexp.Regexp // The regular expression to match a time string
        timeUnit string                        // The time unit that the regular expression represents
}

// regexes is a slice of RegexType structs that store regular expressions and their corresponding time units.
var regexes []RegexType

// setRegexes initializes the regexes slice with regular expressions and their corresponding time units.
func setRegexes() <span class="cov3" title="5">{
        regexes = []RegexType{
                {regexp.MustCompile(`^(\d+)\s*$`), "minute"}, // Matches a string of digits followed by optional whitespace
                {regexp.MustCompile(`^(\d+)\s*(min|minutes)?$`), "minute"}, // Matches a string of digits followed by optional "min" or "minutes"
                {regexp.MustCompile(`^(\d+)\s*s$`), "second"}, // Matches a string of digits followed by a "s"
                {regexp.MustCompile(`(?i)^(\d+)\s*(sec|second|seconds)?$`), "second"}, // Matches a string of digits followed by optional "sec", "second", or "seconds"
                {regexp.MustCompile(`^(\d+)\s*H$`), "hour"}, // Matches a string of digits followed by a "H"
                {regexp.MustCompile(`(?i)^(\d+)\s*hour(s)?$`), "hour"}, // Matches a string of digits followed by optional "hour" or "hours"
                {regexp.MustCompile(`^(?i)d$`), "day"}, // Matches a "d" or "D"
                {regexp.MustCompile(`(?i)^(\d+)\s*D$`), "day"}, // Matches a string of digits followed by a "D"
                {regexp.MustCompile(`^(\d+)\s*D$`), "day"}, // Matches a string of digits followed by a "D"
                {regexp.MustCompile(`(?i)^(\d+)\s*day(s)?$`), "day"}, // Matches a string of digits followed by optional "day" or "days"
                {regexp.MustCompile(`^(\d+)\s*W$`), "week"}, // Matches a string of digits followed by a "W"
                {regexp.MustCompile(`(?i)^(\d+)\s*week(s)?$`), "week"}, // Matches a string of digits followed by optional "week" or "weeks"
                {regexp.MustCompile(`(?i)^(\d+)\s*M$`), "month"}, // Matches a string of digits followed by a "M"
                {regexp.MustCompile(`(?i)^(\d+)\s*month(s)?$`), "month"}, // Matches a string of digits followed by optional "month" or "months"
                {regexp.MustCompile(`(?i)^(\d+)\s*Y$`), "year"}, // Matches a string of digits followed by a "Y"
                {regexp.MustCompile(`(?i)^(\d+)\s*year(s)?$`), "year"}, // Matches a string of digits followed by optional "year" or "years"
        }
}</span>

// TimeFormats is a struct that holds information about a time format.
// Format is a string that represents the time format.
// Precision is a string that represents the precision of the time format.
// Timezone is a boolean that indicates whether the time format includes a timezone.
type TimeFormats struct {
        Format    string // The time format
        Precision string // The precision of the time format
        Timezone  bool   // Whether the time format includes a timezone
}

var timeFormats = []TimeFormats{
        // Dates without timezones are set to false
        {"3:04PM",                          "minute", false},
        {"Monday, January 2, 2006 3:04 PM", "minute", false},
        {"1/2/06",                          "day", false},
        {"1/2/2006",                        "day", false},
        {"01/02/2006",                      "day", false},
        {"2006-01-02",                      "day", false},
        {"2006-1-2",                        "day", false},
        {"January 2, 2006",                 "day", false},
        {"Jan 2, 2006",                     "day", false},
        {"Monday, Jan 2, 2006",             "day", false},
        {"02-Jan-2006",                     "day", false},
        {"02 January 2006",                 "day", false},
        {"01/02/2006 3:04 PM",              "minute", false},
        {"01/02/2006 15:04",                "minute", false},
        {"2006-01-02T15:04",                "minute", false},
        {"Mon Jan _2 15:04:05 2006",        "second", false},
        {"01/02/2006 3:04:05 PM",           "second", false},
        {"01/02/2006 15:04:05",             "second", false},
        {"2006-01-02 15:04:05",             "second", false},
        {"2006-01-02T15:04:05",             "second", false},
        {"20060102T150405",                 "second", false},
        {"Jan 2, 2006 15:04:05",            "second", false},
        {"January 2, 2006 15:04:05.999",    "milisecond", false},
        {"01/02/2006 3:04:05.999 PM",       "millisecond", false},
        {"01/02/2006 15:04:05.999",         "millisecond", false},
        {"2006-01-02 15:04:05.999",         "millisecond", false},
        {"2006-01-02T15:04:05.999",         "millisecond", false},
        {"01/02/2006 3:04:05.999999 PM",    "microsecond", false},
        {"01/02/2006 15:04:05.999999",      "microsecond", false},
        {"2006-01-02 15:04:05.999999",      "microsecond", false},
        {"2006-01-02T15:04:05.999999",      "microsecond", false},
        {"01/02/2006 3:04:05.999999999 PM", "nanosecond", false},
        {"01/02/2006 15:04:05.999999999",   "nanosecond", false},
        {"2006-01-02 15:04:05.999999999",   "nanosecond", false},
        {"2006-01-02T15:04:05.999999999",   "nanosecond", false},

        // Dates with timezones are set to true
        {"01/02/2006 3:04 PM MST",             "minute", true},
        {"2006-01-02T15:04Z0700",              "minute", true},
        {"20060102T1504Z0700",                 "minute", true},
        {"2006-01-02T15:04-07:00",             "minute", true},
        {"2006-01-02T15:04Z",                  "minute", true},
        {"Mon Jan _2 15:04 MST 2006",          "minute", true},     // time.UnixDate
        {"Mon Jan 02 15:04 -0700 2006",        "minute", true},     // time.RubyDate
        {"02 Jan 06 15:04 MST",                "minute", true},     // time.RFC822
        {"02 Jan 06 15:04 -0700",              "minute", true},     // time.RFC822Z
        {"Monday, 02-Jan-06 15:04 MST",        "minute", true},     // time.RFC850
        {"Mon, 02 Jan 2006 15:04 MST",         "minute", true},     // time.RFC1123
        {"Mon, 02 Jan 2006 15:04 -0700",       "minute", true},     // time.RFC1123Z
        {"2006-01-02T15:04Z-07:00",            "minute", true},     // time.RFC3339
        {"01/02/2006 3:04:05 MST",             "second", true},
        {"2006-01-02T15:04:05Z0700",           "second", true},
        {"20060102T150405Z0700",               "second", true},
        {"2006-01-02T15:04:05-07:00",          "second", true},
        {"2006-01-02T15:04:05Z",               "second", true},
        {"Mon Jan _2 15:04:05 MST 2006",       "second", true},     // time.UnixDate
        {"Mon Jan 02 15:04:05 -0700 2006",     "second", true},     // time.RubyDate
        {"02 Jan 06 15:04 MST",                "second", true},     // time.RFC822
        {"02 Jan 06 15:04 -0700",              "second", true},     // time.RFC822Z
        {"Monday, 02-Jan-06 15:04:05 MST",     "second", true},     // time.RFC850
        {"Mon, 02 Jan 2006 15:04:05 MST",      "second", true},     // time.RFC1123
        {"Mon, 02 Jan 2006 15:04:05 -0700",    "second", true},     // time.RFC1123Z
        {"2006-01-02T15:04:05Z-07:00",         "second", true},     // time.RFC3339
        {"2006-01-02T15:04:05.999999999Z07:00","nanosecond", true}, // time.RFC3339Nano
}

// filterTimeFormats is a function that filters the provided time formats based on the provided precision and timezone.
// The function takes in a slice of TimeFormats, a precision string, and an optional timezone boolean.
// It returns a slice of TimeFormats that match the provided precision and timezone.
// If no timezone is provided, it will return formats regardless of their timezone.
// If no precision is provided, it will return formats regardless of their precision.
func filterTimeFormats(formatStrings []TimeFormats, precision string, timezone ...bool) []TimeFormats <span class="cov4" title="12">{
        // Initialize an empty slice to store the filtered time formats
        var filteredTimeFormats []TimeFormats
        
        // Iterate over the provided time formats
        for _, timeFormats := range formatStrings </span><span class="cov10" title="642">{
                // If no timezone is provided or if the timezone matches the provided timezone
                if len(timezone) == 0 || timeFormats.Timezone == timezone[0] </span><span class="cov9" title="321">{
                        // If no precision is provided or if the precision matches the provided precision
                        if precision == "" || timeFormats.Precision == precision </span><span class="cov8" title="312">{
                                // Append the time format to the filtered time formats
                                filteredTimeFormats = append(filteredTimeFormats, timeFormats)
                        }</span>
                }
        }
        
        // Return the filtered time formats
        <span class="cov4" title="12">return filteredTimeFormats</span>
}

// init is a special function in Go that is called when the package is initialized.
// This function initializes several package-level variables.
func init() <span class="cov3" title="5">{
        timeFormatsNoTZ = filterTimeFormats(timeFormats, "", false)
        timeFormatsWithTZ = filterTimeFormats(timeFormats, "", true)

        // Load the default timezone from an environment variable
        // If there is no environment variable, use "America/New_York"
        tz := os.Getenv("TZ")
        if tz == "" </span><span class="cov3" title="5">{
                tz = "America/New_York"
        }</span>

        // Set the regular expressions for precision parsing
        <span class="cov3" title="5">setRegexes()
        
        // Load the timezone
        var err error
        DefaultTZ, err = time.LoadLocation(tz)
        if err != nil </span><span class="cov0" title="0">{
                // If there is an error loading the timezone, panic
                panic(err)</span>
        }
}


</pre>
		
		<pre class="file" id="file25" style="display: none">package dates

import (
        "errors"
        "time"
        "reflect"
)

// ToDayString takes an interface and returns the date in YYYY-MM-DD format and an error
func ToDayString(dateInput interface{}, tz ...*time.Location) (string, error) <span class="cov5" title="7">{
        parsedDate, _, err := ParseDateInput(dateInput, tz...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="7">return parsedDate.Format("2006-01-02"), nil</span>
}


// ToTime takes an interface and returns just the time.Time and an error
func ToTime(dateInput interface{}, tz ...*time.Location) (time.Time, error) <span class="cov7" title="22">{
        parsedDate, _, err := ParseDateInput(dateInput, tz...)
        return parsedDate, err
}</span>

// ParseDateInput tries to parse the dateInput in various formats.
// It returns the parsed time, the precision, and any error encountered.
func ParseDateInput(dateInput interface{}, tz ...*time.Location) (time.Time, string, error) <span class="cov10" title="74">{
        var loc *time.Location

        // If the user has not given us a timezone, we use the default timezone
        if len(tz) &gt; 0 </span><span class="cov8" title="42">{
                loc = tz[0]
        }</span> else<span class="cov8" title="32"> {
                loc = DefaultTZ
        }</span>

        // If the user has provided us with a string input of a number, convert to int64 or float64, as appropriate.
        <span class="cov10" title="74">dateInput = convertStringToNumber(dateInput)

        // Use parsePrimitives to parse the dateInput
        parsedDate, precision, err := parsePrimitives(dateInput, loc)
        if err != nil </span><span class="cov6" title="12">{
                return time.Time{}, "", err
        }</span>

        <span class="cov9" title="62">return parsedDate, precision, nil</span>
}

// IdentifyDateInputPrimitiveType identifies the primitive type of the date input.
func parsePrimitives(dateInput interface{}, tz *time.Location) (time.Time, string, error) <span class="cov10" title="74">{
        switch v := dateInput.(type) </span>{
        case int:<span class="cov5" title="7">
                return int64DateParser(int64(v), tz)</span>
        case *int:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for int")
                }</span>
                <span class="cov0" title="0">return int64DateParser(int64(*v), tz)</span>
        case int32:<span class="cov0" title="0">
                return parsePrimitives(int64(v), tz)</span>
        case *int32:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for int32")
                }</span>
                <span class="cov0" title="0">return parsePrimitives(int64(*v), tz)</span>
        case int64:<span class="cov7" title="18">
                return int64DateParser(v, tz)</span>
        case *int64:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for int64")
                }</span>
                <span class="cov0" title="0">return int64DateParser(*v, tz)</span>
        case string:<span class="cov8" title="35">
                return stringDateParser(v, tz)</span>
        case *string:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for string")
                }</span>
                <span class="cov0" title="0">return stringDateParser(*v, tz)</span>
        case float32:<span class="cov0" title="0">
                return parsePrimitives(float64(v), tz)</span>
        case *float32:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for float32")
                }</span>
                <span class="cov0" title="0">return parsePrimitives(float64(*v), tz)</span>
        case float64:<span class="cov5" title="10">
                return float64DateParser(v, tz)</span>
        case *float64:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for float64")
                }</span>
                <span class="cov0" title="0">return float64DateParser(*v, tz)</span>
        case bool, *bool:<span class="cov0" title="0">
                return time.Time{}, "", errors.New("boolean values cannot be parsed as dates")</span>
        case time.Time:<span class="cov0" title="0">
                return timeDateParser(v, tz)</span>
        case *time.Time:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for time.Time")
                }</span>
                <span class="cov0" title="0">return timeDateParser(*v, tz)</span>
        case DateRange:<span class="cov1" title="1">
                return dateRangeParser(v, tz)</span>
        case *DateRange:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for DateRange")
                }</span>
                <span class="cov0" title="0">return dateRangeParser(*v, tz)</span>
        case func() time.Time:<span class="cov0" title="0">
                return parsePrimitives(v(), tz)</span>
        case *func() time.Time:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", errors.New("nil pointer passed for func() time.Time")
                }</span>
                <span class="cov0" title="0">return parsePrimitives((*v)(), tz)</span>
        default:<span class="cov3" title="3">
                rv := reflect.ValueOf(dateInput)
                if rv.Kind() == reflect.Func &amp;&amp; rv.Type().NumIn() == 0 &amp;&amp; rv.Type().NumOut() == 1 &amp;&amp; rv.Type().Out(0) == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        return parsePrimitives(rv.Call(nil)[0].Interface(), tz)
                }</span>
                <span class="cov3" title="3">return time.Time{}, "", errors.New("value cannot be parsed as a date")</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package dates

import (
        "time"
        "math"
)

// float64DateParser attempts to parse an Excel timestamp and determine its precision.
// The function accepts a float64 and a timezone as input.
func float64DateParser(excelTimestampFloat float64, tz *time.Location) (time.Time, string, error) <span class="cov8" title="13">{
        // Use the FromExcelTime helper function to convert the Excel timestamp to a time.Time
        parsedDate, err := FromExcelTime(excelTimestampFloat, tz)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, "", err
        }</span>

        // Calculate the number of days and the fraction of a day
        <span class="cov8" title="13">_, fraction := math.Modf(excelTimestampFloat)

        // Determine the smallest unit of precision based on the fraction.
        precision := DayPrecision // Default precision if there's no fractional part.
        if fraction &gt; 0 </span><span class="cov3" title="2">{
                // Determine the precision of the timestamp.
                if fraction*math.Pow(10, 9) == math.Floor(fraction*math.Pow(10, 9)) </span><span class="cov3" title="2">{
                        precision = SecondPrecision
                }</span> else<span class="cov0" title="0"> if fraction*math.Pow(10, 6) == math.Floor(fraction*math.Pow(10, 6)) </span><span class="cov0" title="0">{
                        precision = MillisecondPrecision
                }</span> else<span class="cov0" title="0"> if fraction*math.Pow(10, 3) == math.Floor(fraction*math.Pow(10, 3)) </span><span class="cov0" title="0">{
                        precision = MicrosecondPrecision
                }</span> else<span class="cov0" title="0"> {
                        precision = NanosecondPrecision
                }</span>
        }

        <span class="cov8" title="13">return parsedDate, precision, nil</span>
}

// FromExcelTime converts Excel time, which is the number of days since 1900-01-01, to a time.Time.
// The function takes the Excel time as a float64 and an optional timezone. If no timezone is provided, it uses the default timezone.
func FromExcelTime(excelTime float64, tz *time.Location) (time.Time, error) <span class="cov9" title="17">{
        days, fracDays := math.Modf(excelTime)

        duration := time.Duration(fracDays * 24 * float64(time.Hour))
        date := excelEpoch.AddDate(0, 0, int(days)).Add(duration)

        // Get the offset from UTC
        offset := getTimezoneOffset(date, tz)

        // Adjust the date by the offset
        date = utcToTZ(date, offset)

        // Set the timezone of the Time object
        date = date.In(tz)

        return date, nil
}</span>

// ToExcelTime converts a time.Time to Excel time, which is the number of days since 1900-01-01.
// The function returns the Excel time as a float64.
// The function now takes a timezone as input and adjusts the Excel timestamp based on the timezone of the time.Time object.
func ToExcelTime(t time.Time, tz *time.Location) float64 <span class="cov5" title="4">{
    // Adjust the time by the timezone offset
    offset := getTimezoneOffset(t, tz)
    t = tzToUTC(t, offset)

    durationSinceExcelEpoch := t.Sub(excelEpoch)
    excelTime := float64(durationSinceExcelEpoch.Hours() / 24)

    return excelTime
}</span>

func getTimezoneOffset(t time.Time, tz *time.Location) time.Duration <span class="cov10" title="21">{
    // Get the time in the specified timezone
    t = t.In(tz)

    // Get the name of the time zone and its offset from UTC in seconds
    _, offset := t.Zone()

    // Convert the offset to a time.Duration and return it
    return time.Duration(offset) * time.Second
}</span>

func utcToTZ(utcTime time.Time, offset time.Duration) time.Time <span class="cov9" title="17">{
    // Adjust the time by the offset
    adjustedTime := utcTime.Add(-offset)

    return adjustedTime
}</span>

func tzToUTC(utcTime time.Time, offset time.Duration) time.Time <span class="cov5" title="4">{
    // Adjust the time by the offset
    adjustedTime := utcTime.Add(offset)

    return adjustedTime
}</pre>
		
		<pre class="file" id="file27" style="display: none">package dates

import (
        "strings"
    "strconv"
        "time"
        "fmt"
)

// stringDateParser attempts to parse a date string without timezone, with timezone, and special cases.
// It returns the parsed time, the precision, and any error encountered.
func stringDateParser(dateStr string, tz *time.Location) (time.Time, string, error) <span class="cov6" title="35">{
    t, precision, err := tryParseAttemptNoTZ(dateStr, tz)
    if err == nil </span><span class="cov5" title="23">{
        return t, precision, nil
    }</span>

    <span class="cov4" title="12">t, precision, err = tryParseAttemptWithTZ(dateStr)
    if err == nil </span><span class="cov2" title="3">{
        return t, precision, nil
    }</span>

        <span class="cov4" title="9">parsedDate, precision, found := tryParseSpecialCases(dateStr, tz)
    if found </span><span class="cov0" title="0">{
        return parsedDate, precision, nil
    }</span>
    <span class="cov4" title="9">return time.Time{}, "", fmt.Errorf("unable to parse date string: %s", dateStr)</span>
}

// tryParseSpecialCases tries to parse special date strings like "today", "yesterday", and "now".
// It returns the parsed time, the precision, and a boolean indicating if the parsing was successful.
// It accepts a location parameter to use for the parsed time.
func tryParseSpecialCases(dateStr string, loc *time.Location) (time.Time, string, bool) <span class="cov4" title="13">{
    now := time.Now().In(loc)
    switch strings.ToLower(dateStr) </span>{
    case "today":<span class="cov1" title="1">
        return time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc), "day", true</span>
    case "yesterday":<span class="cov1" title="1">
        yesterday := now.AddDate(0, 0, -1)
        return time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 0, 0, 0, 0, loc), "day", true</span>
    case "now":<span class="cov1" title="1">
        return now, "second", true</span>
    default:<span class="cov4" title="10">
        return time.Time{}, "", false</span>
    }
}

// tryParseAttemptNoTZ tries to parse a date string without timezone.
// It returns the parsed time, the precision, and any error encountered.
func tryParseAttemptNoTZ(dateStr string, tz *time.Location) (time.Time, string, error) <span class="cov6" title="35">{
    var loc *time.Location
    if tz != nil </span><span class="cov6" title="35">{
        loc = tz
    }</span> else<span class="cov0" title="0"> {
        loc = DefaultTZ
    }</span>

    <span class="cov6" title="35">for _, timeFormat := range timeFormatsNoTZ </span><span class="cov10" title="566">{
        var t time.Time
        var err error
        t, err = time.ParseInLocation(timeFormat.Format, dateStr, loc)
        if err == nil </span><span class="cov5" title="23">{
            return t, timeFormat.Precision, nil
        }</span>
    }
    <span class="cov4" title="12">return time.Time{}, "", fmt.Errorf("unable to parse date string: %s", dateStr)</span>
}

// tryParseAttemptWithTZ tries to parse a date string with timezone.
// It returns the parsed time, the precision, and any error encountered.
func tryParseAttemptWithTZ(dateInput string) (time.Time, string, error) <span class="cov4" title="12">{
    for _, timeFormat := range timeFormatsWithTZ </span><span class="cov9" title="310">{
        var t time.Time
        var err error
        t, err = time.Parse(timeFormat.Format, dateInput)
        if err == nil </span><span class="cov2" title="3">{
            return t, timeFormat.Precision, nil
        }</span>
    }
    <span class="cov4" title="9">return time.Time{}, "", fmt.Errorf("unable to parse date string: %s", dateInput)</span>
}

// convertStringToNumber attempts to convert a string input to a number.
// If the input is a string that can be parsed to an int64, it returns the int64.
// If the input is a string that can be parsed to a float64, it returns the float64.
// If the input is not a string or cannot be parsed to a number, it returns the original input.
func convertStringToNumber(dateInput interface{}) interface{} <span class="cov7" title="74">{
    switch v := dateInput.(type) </span>{
    case string:<span class="cov6" title="39">
        if val, err := strconv.ParseInt(v, 10, 64); err == nil </span><span class="cov2" title="3">{
            return int64(val)
        }</span> else<span class="cov6" title="36"> if val, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov1" title="1">{
            return float64(val)
        }</span>
    }
    <span class="cov7" title="70">return dateInput</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">// Package dates provides helper functions for date and time parsing.
package dates

import (
        "time"
)

// precisionOrder is a map that assigns an order of precision to date and time components.
var precisionOrder = map[string]int{
        YearPrecision:        1,
        MonthPrecision:       2,
        DayPrecision:         3,
        HourPrecision:        4,
        MinutePrecision:      5,
        SecondPrecision:      6,
        MillisecondPrecision: 7,
        MicrosecondPrecision: 8,
        NanosecondPrecision:  9,
}

// dateRangeParser parses the start and end dates of a DateRange and returns the start time, precision, and any error that occurred.
func dateRangeParser(dr DateRange, tz *time.Location) (time.Time, string, error) <span class="cov1" title="1">{
    // Parse the StartDate of the DateRange
    parsedStartTime, startPrecision, err := timeDateParser(dr.StartDate, tz)
    if err != nil </span><span class="cov0" title="0">{
        return time.Time{}, "", err
    }</span>

    // Parse the EndDate of the DateRange
    <span class="cov1" title="1">_, endPrecision, err := timeDateParser(dr.EndDate, tz)
    if err != nil </span><span class="cov0" title="0">{
        return time.Time{}, "", err
    }</span>

    // Determine the smallest precision
    <span class="cov1" title="1">precision := startPrecision
    if precisionOrder[startPrecision] &lt; precisionOrder[endPrecision] </span><span class="cov1" title="1">{
        precision = endPrecision
    }</span>

    // Return the parsed start and end times, precision, and no error
    <span class="cov1" title="1">return parsedStartTime, precision, nil</span>
}

// timeDateParser converts a time to a specified timezone and infers its precision.
func timeDateParser(t time.Time, tz *time.Location) (time.Time, string, error) <span class="cov3" title="2">{
    // Convert the time to the specified timezone
    t = t.In(tz)

    // Infer the precision
    precision, err := inferPrecision(t)
    if err != nil </span><span class="cov0" title="0">{
        return time.Time{}, "", err
    }</span>

    // Return the time, precision, and no error
    <span class="cov3" title="2">return t, precision, nil</span>
}

// inferPrecision infers the precision of a time by checking its components from smallest to largest.
func inferPrecision(t time.Time) (string, error) <span class="cov10" title="9">{
        if t.Nanosecond() != 0 </span><span class="cov1" title="1">{
                return NanosecondPrecision, nil
        }</span> else<span class="cov9" title="8"> if t.Second() != 0 </span><span class="cov1" title="1">{
                return SecondPrecision, nil
        }</span> else<span class="cov8" title="7"> if t.Minute() != 0 </span><span class="cov1" title="1">{
                return MinutePrecision, nil
        }</span> else<span class="cov8" title="6"> if t.Hour() != 0 </span><span class="cov1" title="1">{
                return HourPrecision, nil
        }</span> else<span class="cov7" title="5"> {
                // The time is at 00:00:00, so check the day, month, and year
                _, month, day := t.Date()
                if day != 1 </span><span class="cov3" title="2">{
                        return DayPrecision, nil
                }</span> else<span class="cov5" title="3"> if month != time.January </span><span class="cov1" title="1">{
                        return MonthPrecision, nil
                }</span> else<span class="cov3" title="2"> {
                        return YearPrecision, nil
                }</span>
        }
}</pre>
		
		<pre class="file" id="file29" style="display: none">package dates

import (
        "time"
        "math"
        "fmt"
)

func int64DateParser(unixTime int64, tz *time.Location) (time.Time, string, error) <span class="cov10" title="25">{
        numDigits := int(math.Log10(float64(unixTime))) + 1
        precision := ""
        var parsedTime time.Time
        switch </span>{
        case numDigits &lt;= 5:<span class="cov4" title="3"> // Excel timestamps
                parsedTime, precision, err := float64DateParser(float64(unixTime), tz)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, "", err
                }</span>
                <span class="cov4" title="3">return parsedTime, precision, nil</span>
        case numDigits &gt; 5 &amp;&amp; numDigits &lt;= 10:<span class="cov9" title="21"> // Unix timestamps with 5 to 10 digits
                parsedTime = time.Unix(unixTime, 0)
                precision = SecondPrecision</span>
        case numDigits == 13:<span class="cov1" title="1"> // milliseconds
                parsedTime = time.Unix(0, unixTime*int64(time.Millisecond))
                precision = MillisecondPrecision</span>
        case numDigits == 16:<span class="cov0" title="0"> // microseconds
                parsedTime = time.Unix(0, unixTime*int64(time.Microsecond))
                precision = MicrosecondPrecision</span>
        case numDigits == 19:<span class="cov0" title="0"> // nanoseconds
                parsedTime = time.Unix(0, unixTime)
                precision = NanosecondPrecision</span>
        default:<span class="cov0" title="0">
                return time.Time{}, "", fmt.Errorf("unknown Unix timestamp length: %d digits", numDigits)</span>
        }
        <span class="cov9" title="22">return parsedTime, precision, nil</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package parameters

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/types"
        "github.com/go-resty/resty/v2"
)

// CountryParams represents the parameters for a country.
// It includes a country code that is used in various requests.
type CountryParams struct {
        Country string `query:"country"`
}

// SetCountry sets the country parameter for the CountryParams.
// It validates the country code to be of length 2 and only contain alphabets.
// If the validation fails, it returns an error.
func (cp *CountryParams) SetCountry(q string) error <span class="cov10" title="3">{
        if len(q) != 2 || !types.IsAlpha(q) </span><span class="cov1" title="1">{
                err := fmt.Errorf("invalid country code")
                return err
        }</span>
        <span class="cov6" title="2">cp.Country = q
        return nil</span>
}

// SetParams sets the parameters for the CountryParams in the request.
// If the parsing and setting of parameters fail, it returns an error.
func (cp *CountryParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(cp, request)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package parameters

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
        "github.com/go-resty/resty/v2"
)

// DateKeyParam represents the date key parameter for a request.
// It includes a date key that is used in various requests and is required for V2 requests.
type DateKeyParam struct {
        DateKey string `path:"datekey" validate:"required"`
}

// SetDateKey sets the date key parameter for the TickersRequest.
// It validates the date key using the IsValidDateKey function from the dates package.
func (dk *DateKeyParam) SetDateKey(q string) error <span class="cov8" title="1">{
        if !dates.IsValidDateKey(q) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid date key format")
        }</span>
        <span class="cov8" title="1">dk.DateKey = q
        return nil</span>
}

// SetParams sets the parameters for the DateKeyParam.
// It uses the parseAndSetParams function to parse and set the parameters.
func (dk *DateKeyParam) SetParams(request *resty.Request) error <span class="cov8" title="1">{
        return ParseAndSetParams(dk, request)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package parameters

import (
        "github.com/MarketDataApp/sdk-go/helpers/dates"
        "github.com/go-resty/resty/v2"
)

// DateParams represents the parameters for a date request.
// It includes a date, from, to, and countback, which are used in various requests.
type DateParams struct {
        Date      string `query:"date"`
        From      string `query:"from"`
        To        string `query:"to"`
        Countback *int   `query:"countback"`
}

// SetDate sets the date parameter of the DateParams.
// It validates the date using the ToDayString function from the dates package.
// If the validation fails, it returns an error.
func (dp *DateParams) SetDate(q interface{}) error <span class="cov10" title="2">{
        date, err := dates.ToDayString(q)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">dp.Date = date
        if dp.Date != "" </span><span class="cov10" title="2">{
                dp.From = ""
                dp.To = ""
                if dp.Countback != nil </span><span class="cov0" title="0">{
                        dp.Countback = nil
                }</span>
        }
        <span class="cov10" title="2">return nil</span>
}

// SetFrom sets the from parameter of the DateParams.
// It validates the from date using the ToDayString function from the dates package.
// If the validation fails, it returns an error.
func (dp *DateParams) SetFrom(q interface{}) error <span class="cov10" title="2">{
        date, err := dates.ToDayString(q)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">dp.From = date
        if dp.From != "" </span><span class="cov10" title="2">{
                if dp.Date != "" </span><span class="cov1" title="1">{
                        dp.Date = ""
                }</span>
                <span class="cov10" title="2">if dp.Countback != nil </span><span class="cov0" title="0">{
                        dp.Countback = nil
                }</span>
        }
        <span class="cov10" title="2">return nil</span>
}

// SetTo sets the to parameter of the DateParams.
// It validates the to date using the ToDayString function from the dates package.
// If the validation fails, it returns an error.
func (dp *DateParams) SetTo(q interface{}) error <span class="cov10" title="2">{
        date, err := dates.ToDayString(q)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="2">dp.To = date
        if dp.To != "" </span><span class="cov10" title="2">{
                if dp.Date != "" </span><span class="cov0" title="0">{
                        dp.Date = ""
                }</span>
                <span class="cov10" title="2">if dp.Countback != nil </span><span class="cov0" title="0">{
                        dp.Countback = nil
                }</span>
        }
        <span class="cov10" title="2">return nil</span>
}

// SetCountback sets the countback parameter of the DateParams.
// If countback is not nil, it clears the date and from parameters.
func (dp *DateParams) SetCountback(q int) error <span class="cov1" title="1">{
        dp.Countback = &amp;q
        if dp.Countback != nil </span><span class="cov1" title="1">{
                if dp.Date != "" </span><span class="cov0" title="0">{
                        dp.Date = ""
                }</span>
                <span class="cov1" title="1">if dp.From != "" </span><span class="cov1" title="1">{
                        dp.From = ""
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// SetParams sets the parameters for the DateParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (dp *DateParams) SetParams(request *resty.Request) error <span class="cov10" title="2">{
        return ParseAndSetParams(dp, request)
}</span>

</pre>
		
		<pre class="file" id="file33" style="display: none">package parameters

import "github.com/go-resty/resty/v2"

// FiftyTwoWeekParams represents the unique parameters for a StockQuoteRequest
type FiftyTwoWeekParams struct {
        FiftyTwoWeek bool `query:"52week"`
}

// SetFiftyTwoWeek sets the FiftyTwoWeek parameter for the FiftyTwoWeekParams.
func (sqp *FiftyTwoWeekParams) SetFiftyTwoWeek(q bool) <span class="cov0" title="0">{
        sqp.FiftyTwoWeek = q
}</span>

// SetParams sets the FiftyTwoWeek parameter for the FiftyTwoWeekParams.
// If the parsing and setting of parameters fail, it returns an error.
func (sqp *FiftyTwoWeekParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(sqp, request)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package parameters

import (
        "fmt"
        "strings"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
        "github.com/go-resty/resty/v2"
)

// OptionParams represents the parameters for an options request.
type OptionParams struct {
        Expiration         string  `query:"expiration" validate:"optional"` // ISO 8601, unix, spreadsheet, or "all"
        Month              int     `query:"month" validate:"optional"`      // 1-12
        Year               int     `query:"year" validate:"optional"`
        Weekly             *bool   `query:"weekly" validate:"optional"`
        Monthly            *bool   `query:"monthly" validate:"optional"`
        Quarterly          *bool   `query:"quarterly" validate:"optional"`
        Nonstandard        *bool   `query:"nonstandard" validate:"optional"`
        DTE                *int    `query:"dte" validate:"optional"` // Days to expiry
        Delta              float64 `query:"delta" validate:"optional"`
        Side               string  `query:"side" validate:"optional"`  // "call" or "put"
        Range              string  `query:"range" validate:"optional"` // "itm", "otm", "atm", "all"
        Strike             float64 `query:"strike" validate:"optional"`
        StrikeLimit        int     `query:"strikeLimit" validate:"optional"`
        MinOpenInterest    int     `query:"minOpenInterest" validate:"optional"`
        MinVolume          int     `query:"minVolume" validate:"optional"`
        MaxBidAskSpread    float64 `query:"maxBidAskSpread" validate:"optional"`
        MaxBidAskSpreadPct float64 `query:"maxBidAskSpreadPct" validate:"optional"` // Percent relative to the underlying
}

// SetExpiration sets the Expiration parameter for the OptionParams.
// It checks if the input is the special case "all" (case insensitive) and sets it directly.
// Otherwise, it validates the expiration date using the ToDayString function from the dates package.
// If the validation fails, it returns an error.
func (op *OptionParams) SetExpiration(q interface{}) error <span class="cov8" title="1">{
        if str, ok := q.(string); ok &amp;&amp; strings.EqualFold(str, "all") </span><span class="cov0" title="0">{
                op.Expiration = str
                return nil
        }</span>

        <span class="cov8" title="1">expiration, err := dates.ToDayString(q)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">op.Expiration = expiration
        return nil</span>
}

// SetMonth sets the Month parameter for the OptionParams.
// It validates that the month is within the 1-12 range.
// If the validation fails, it returns an error.
func (op *OptionParams) SetMonth(month int) error <span class="cov0" title="0">{
        if month &lt; 1 || month &gt; 12 </span><span class="cov0" title="0">{
                return fmt.Errorf("month must be between 1 and 12")
        }</span>
        <span class="cov0" title="0">op.Month = month
        return nil</span>
}

// SetYear sets the Year parameter for the OptionParams.
// It validates that the year is after 2000.
// If the validation fails, it returns an error.
func (op *OptionParams) SetYear(year int) error <span class="cov0" title="0">{
        if year &lt;= 2000 </span><span class="cov0" title="0">{
                return fmt.Errorf("year must be after 2000")
        }</span>
        <span class="cov0" title="0">op.Year = year
        return nil</span>
}

// SetWeekly sets the Weekly parameter for the OptionParams.
func (op *OptionParams) SetWeekly(weekly bool) error <span class="cov0" title="0">{
        op.Weekly = &amp;weekly
        return nil
}</span>

// SetMonthly sets the Monthly parameter for the OptionParams.
func (op *OptionParams) SetMonthly(monthly bool) error <span class="cov0" title="0">{
        op.Monthly = &amp;monthly
        return nil
}</span>

// SetQuarterly sets the Quarterly parameter for the OptionParams.
func (op *OptionParams) SetQuarterly(quarterly bool) error <span class="cov0" title="0">{
        op.Quarterly = &amp;quarterly
        return nil
}</span>

// SetNonstandard sets the Nonstandard parameter for the OptionParams.
func (op *OptionParams) SetNonstandard(nonstandard bool) error <span class="cov0" title="0">{
        op.Nonstandard = &amp;nonstandard
        return nil
}</span>

// SetDTE sets the Days to Expiry parameter for the OptionParams.
// It validates that the DTE is not negative.
func (op *OptionParams) SetDTE(dte int) error <span class="cov0" title="0">{
        if dte &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("DTE cannot be negative")
        }</span>
        <span class="cov0" title="0">dtePtr := &amp;dte  // Create a pointer to dte
        op.DTE = dtePtr // Assign the pointer to op.DTE
        return nil</span>
}

// SetDelta sets the Delta parameter for the OptionParams.
func (op *OptionParams) SetDelta(delta float64) error <span class="cov0" title="0">{
        op.Delta = delta
        return nil
}</span>

// SetSide sets the Side parameter for the OptionParams allowing case-insensitive input.
func (op *OptionParams) SetSide(side string) error <span class="cov0" title="0">{
        sideLower := strings.ToLower(side)
        if sideLower != "call" &amp;&amp; sideLower != "put" &amp;&amp; sideLower != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("side must be 'call', 'put', or an empty string")
        }</span>
        <span class="cov0" title="0">op.Side = sideLower
        return nil</span>
}

// SetRange sets the Range parameter for the OptionParams allowing case-insensitive input.
func (op *OptionParams) SetRange(rangeParam string) error <span class="cov0" title="0">{
        rangeParamLower := strings.ToLower(rangeParam)
        if rangeParamLower != "itm" &amp;&amp; rangeParamLower != "otm" &amp;&amp; rangeParamLower != "atm" &amp;&amp; rangeParamLower != "all" &amp;&amp; rangeParamLower != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("range must be 'itm', 'otm', 'atm', 'all', or an empty string")
        }</span>
        <span class="cov0" title="0">op.Range = rangeParamLower
        return nil</span>
}

// SetStrike sets the Strike parameter for the OptionParams.
// It validates that the strike is between &gt;0 and &lt;99999.99.
func (op *OptionParams) SetStrike(strike float64) error <span class="cov0" title="0">{
        if strike &lt;= 0 || strike &gt;= 99999.99 </span><span class="cov0" title="0">{
                return fmt.Errorf("strike must be between &gt;0 and &lt;99999.99")
        }</span>
        <span class="cov0" title="0">op.Strike = strike
        return nil</span>
}

// SetStrikeLimit sets the StrikeLimit parameter for the OptionParams.
// It validates that the StrikeLimit is not negative.
func (op *OptionParams) SetStrikeLimit(strikeLimit int) error <span class="cov0" title="0">{
        if strikeLimit &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("strikeLimit cannot be negative")
        }</span>
        <span class="cov0" title="0">op.StrikeLimit = strikeLimit
        return nil</span>
}

// SetMinOpenInterest sets the MinOpenInterest parameter for the OptionParams.
// It validates that the MinOpenInterest is not negative.
func (op *OptionParams) SetMinOpenInterest(minOpenInterest int) error <span class="cov0" title="0">{
        if minOpenInterest &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("minOpenInterest cannot be negative")
        }</span>
        <span class="cov0" title="0">op.MinOpenInterest = minOpenInterest
        return nil</span>
}

// SetMinVolume sets the MinVolume parameter for the OptionParams.
// It validates that the MinVolume is not negative.
func (op *OptionParams) SetMinVolume(minVolume int) error <span class="cov0" title="0">{
        if minVolume &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("minVolume cannot be negative")
        }</span>
        <span class="cov0" title="0">op.MinVolume = minVolume
        return nil</span>
}

// SetMaxBidAskSpread sets the MaxBidAskSpread parameter for the OptionParams.
// It validates that the MaxBidAskSpread is not negative.
func (op *OptionParams) SetMaxBidAskSpread(maxBidAskSpread float64) error <span class="cov0" title="0">{
        if maxBidAskSpread &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxBidAskSpread cannot be negative")
        }</span>
        <span class="cov0" title="0">op.MaxBidAskSpread = maxBidAskSpread
        return nil</span>
}

// SetMaxBidAskSpreadPct sets the MaxBidAskSpreadPct parameter for the OptionParams.
// It validates that the MaxBidAskSpreadPct is not negative.
func (op *OptionParams) SetMaxBidAskSpreadPct(maxBidAskSpreadPct float64) error <span class="cov0" title="0">{
        if maxBidAskSpreadPct &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxBidAskSpreadPct cannot be negative")
        }</span>
        <span class="cov0" title="0">op.MaxBidAskSpreadPct = maxBidAskSpreadPct
        return nil</span>
}

// SetParams sets the parameters for the OptionParams.
// If the parsing and setting of parameters fail, it returns an error.
func (op *OptionParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(op, request)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package parameters

import (
        "fmt"

        "github.com/go-resty/resty/v2"
)

type ResolutionParams struct {
        Resolution string `path:"resolution" validate:"required"`
}

// SetResolution sets the resolution parameter for the ResolutionParams.
// It validates that the resolution is not an empty string.
// If the validation fails, it returns an error.
func (rp *ResolutionParams) SetResolution(resolution string) error <span class="cov10" title="2">{
        if resolution == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("resolution is required")
        }</span>
        <span class="cov10" title="2">rp.Resolution = resolution
        return nil</span>
}

// SetParams sets the parameters for the CandleParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (rp *ResolutionParams) SetParams(request *resty.Request) error <span class="cov10" title="2">{
        return ParseAndSetParams(rp, request)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package parameters

import (
        "fmt"

        "github.com/go-resty/resty/v2"
)

// CandleParams represents the parameters for a stock candle request.
type StockCandleParams struct {
        AdjustSplits    bool   `query:"adjustsplits" validate:"optional"`
        AdjustDividends bool   `query:"adjustdividends" validate:"optional"` // Not yet implemented in the API
        Extended        bool   `query:"extended" validate:"optional"`
        Exchange        string `query:"exchange" validate:"optional"` // Not needed until non-US exchanges are added
}

// SetAdjustSplits sets the AdjustSplits parameter for the StockCandleParams.
func (scp *StockCandleParams) SetAdjustSplits(adjustSplits bool) <span class="cov0" title="0">{
        scp.AdjustSplits = adjustSplits
}</span>

// SetAdjustDividends sets the AdjustDividends parameter for the StockCandleParams.
func (scp *StockCandleParams) SetAdjustDividends(adjustDividends bool) <span class="cov0" title="0">{
        scp.AdjustDividends = adjustDividends
}</span>

// SetExtended sets the Extended parameter for the StockCandleParams.
func (scp *StockCandleParams) SetExtended(extended bool) <span class="cov0" title="0">{
        scp.Extended = extended
}</span>

// SetExchange sets the Exchange parameter for the StockCandleParams.
// It validates that the exchange is not an empty string.
// If the validation fails, it returns an error.
func (scp *StockCandleParams) SetExchange(exchange string) error <span class="cov0" title="0">{
        if exchange == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("nil value set for exchange")
        }</span>
        <span class="cov0" title="0">scp.Exchange = exchange
        return nil</span>
}

// SetParams sets the parameters for the StockCandleParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (scp *StockCandleParams) SetParams(request *resty.Request) error <span class="cov8" title="1">{
        return ParseAndSetParams(scp, request)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package parameters

import (
        "fmt"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
        "github.com/go-resty/resty/v2"
)

type StockEarningsParams struct {
        Report string `query:"report"`
}

// SetReport sets the report parameter for the EarningsParams.
// It validates the report parameter using the IsValidDateKey function from the dates package.
func (ep *StockEarningsParams) SetReport(q string) error <span class="cov0" title="0">{
        if !dates.IsValidDateKey(q) </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid report parameter")
                return err
        }</span>
        <span class="cov0" title="0">ep.Report = q
        return nil</span>
}

// SetParams sets the parameters for the StockEarningsParams.
// If the parsing and setting of parameters fail, it returns an error.
func (sep *StockEarningsParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(sep, request)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package parameters

import (
        "fmt"

        "github.com/go-resty/resty/v2"
)

type SymbolParams struct {
        Symbol string `path:"symbol" validate:"required"`
}

// SetSymbol sets the symbol parameter for the SymbolParams.
// It validates that the symbol is not an empty string.
// If the validation fails, it returns an error.
func (sp *SymbolParams) SetSymbol(symbol string) error <span class="cov10" title="2">{
        if symbol == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("symbol is required")
        }</span>
        <span class="cov10" title="2">sp.Symbol = symbol
        return nil</span>
}

// SetParams sets the parameters for the CandleParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (sp *SymbolParams) SetParams(request *resty.Request) error <span class="cov10" title="2">{
        return ParseAndSetParams(sp, request)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package parameters

import (
        "github.com/go-resty/resty/v2"
)

// UniversalParams represents the universal parameters for a request.
// It includes limit, date format, offset, format, headers, columns, human, and error.
type UniversalParams struct {
        Limit      int    `query:"limit"`
        DateFormat string `query:"dateformat"`
        Offset     int    `query:"offset"`
        Format     string `query:"format"`
        Headers    bool   `query:"headers"`
        Columns    string `query:"columns"`
        Human      bool   `query:"human"`
        Error      error
}

// SetParams sets the parameters for the UniversalParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (up *UniversalParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(up, request)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package parameters

import (
        "fmt"

        "github.com/go-resty/resty/v2"
)

// UserInputParams represents the user input parameter for a request.
// It includes a user input that is used in various requests and is required.
type UserInputParams struct {
        UserInput string `path:"userInput" validate:"required"`
}

// SetUserInput sets the user input parameter for the OptionsLookupRequest.
// It validates that the user input is not empty.
func (u *UserInputParams) SetUserInput(q string) error <span class="cov0" title="0">{
        if q == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user input cannot be empty")
        }</span>
        <span class="cov0" title="0">u.UserInput = q
        return nil</span>
}

// SetParams sets the parameters for the UserInputParams.
// It uses the parseAndSetParams function to parse and set the parameters.
func (u *UserInputParams) SetParams(request *resty.Request) error <span class="cov0" title="0">{
        return ParseAndSetParams(u, request)
}</pre>
		
		<pre class="file" id="file41" style="display: none">// Package parameters defines structures and functions for handling request parameters across various API endpoints.
// It includes types for universal parameters, specific request types like stock quotes, options, and user inputs,
// and utilities for parsing and setting these parameters in API requests. The package leverages reflection
// for dynamic parameter parsing and validation, ensuring that API requests are constructed correctly.
package parameters

import (
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/go-resty/resty/v2"
        "github.com/MarketDataApp/sdk-go/helpers/types" // Ensure you import the package where IsZeroValue is defined
)

// MarketDataParam defines an interface for setting parameters on a resty.Request.
// Implementations of this interface should provide logic to modify a given resty.Request
// by setting necessary parameters for making API calls to fetch market data.
type MarketDataParam interface {
        SetParams(*resty.Request) error
}
func ParseAndSetParams(params MarketDataParam, request *resty.Request) error <span class="cov6" title="9">{

    if params == nil </span><span class="cov0" title="0">{
        return errors.New("params cannot be nil")
    }</span>
    <span class="cov6" title="9">kind := reflect.TypeOf(params).Kind()

    if kind != reflect.Struct &amp;&amp; kind != reflect.Ptr </span><span class="cov0" title="0">{
        return fmt.Errorf("params must be a struct or a pointer to a struct, got %v", kind)
    }</span>
    <span class="cov6" title="9">v := reflect.ValueOf(params)

    if v.Kind() == reflect.Ptr </span><span class="cov6" title="9">{
        v = v.Elem()
    }</span>

    <span class="cov6" title="9">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
        return fmt.Errorf("dereferenced value of params must be a struct, got %v", v.Kind())
    }</span>

    <span class="cov6" title="9">t := v.Type()

    for i := 0; i &lt; t.NumField(); i++ </span><span class="cov10" title="34">{
        field := t.Field(i)
        value := v.Field(i)
        tag := field.Tag

        // Determine if the parameter is required or optional based on the 'validate' tag.
        validationTag := tag.Get("validate")
        isRequired := strings.Contains(validationTag, "required")

        // Handle missing required parameters.
        if isRequired &amp;&amp; (value.Kind() == reflect.Ptr &amp;&amp; value.IsNil() || types.IsZeroValue(value.Interface())) </span><span class="cov0" title="0">{
            return fmt.Errorf("required parameter %s is missing", field.Name)
        }</span>

        // Skip optional parameters that are not set.
        <span class="cov10" title="34">if !isRequired &amp;&amp; (value.Kind() == reflect.Ptr &amp;&amp; value.IsNil() || types.IsZeroValue(value.Interface())) </span><span class="cov9" title="25">{
            continue</span>
        }

        // Prepare the value for setting, handling pointers correctly.
        <span class="cov6" title="9">var valueInterface interface{}
        if value.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
            valueInterface = reflect.Indirect(value).Interface()
        }</span> else<span class="cov6" title="9"> {
            valueInterface = value.Interface()
        }</span>

        // Set the field to the appropriate part of the request.
        <span class="cov6" title="9">if pathTag := tag.Get("path"); pathTag != "" </span><span class="cov5" title="5">{
            request.SetPathParam(pathTag, fmt.Sprint(valueInterface))
        }</span> else<span class="cov4" title="4"> if queryTag := tag.Get("query"); queryTag != "" </span><span class="cov4" title="4">{
            request.SetQueryParam(queryTag, fmt.Sprint(valueInterface))
        }</span>
    }

    <span class="cov6" title="9">return nil</span>
}</pre>
		
		<pre class="file" id="file42" style="display: none">// Package types provides utility functions for checking the type and value of variables.
// It includes methods for determining if a value is a "zero" value for its type,
// such as empty strings, nil pointers, zero numeric values, and more. This package
// is essential for validation and conditional logic based on variable states across
// the application. It leverages the reflect package to inspect types at runtime.
package types

import (
        "reflect"
        "time"
)

// IsZeroValue checks if the provided interface{} 'i' holds a value that is considered "zero" or "empty" for its type.
// This includes:
// - nil pointers
// - empty strings
// - false for booleans
// - zero for numeric types (integers, unsigned integers, floats)
// - nil for slices, maps, interfaces, and channels
// - time.Time structs representing the zero time
// - structs where all fields are "zero" values
// For pointers, it also checks if the pointed-to value is a zero value, except for pointers to integers or booleans.
func IsZeroValue(i interface{}) bool <span class="cov10" title="60">{
        // Check if the interface is nil, which is considered a zero value.
        if i == nil </span><span class="cov1" title="1">{
                return true
        }</span>

        // Get the reflection Value of the interface.
        <span class="cov9" title="59">v := reflect.ValueOf(i)

        // Switch on the kind of the value to handle different types.
        switch v.Kind() </span>{
        case reflect.String:<span class="cov7" title="18">
                // For strings, check if the length is zero.
                return v.Len() == 0</span>
        case reflect.Bool:<span class="cov4" title="5">
                // For booleans, check if the value is false.
                return !v.Bool()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov5" title="9">
                // For integers, check if the value is zero.
                return v.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov2" title="2">
                // For unsigned integers, check if the value is zero.
                return v.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov4" title="6">
                // For floats, check if the value is zero.
                return v.Float() == 0</span>
        case reflect.Ptr:<span class="cov5" title="9">
                // For pointers, first check if the pointer itself is nil.
                if v.IsNil() </span><span class="cov3" title="3">{
                        return true
                }</span>
                // Get the element the pointer points to.
                <span class="cov4" title="6">elem := v.Elem()
                // Special cases: if the pointer points to an int or bool, do not consider it a zero value.
                // First, check for all integer types.
                if elem.Kind() == reflect.Int || elem.Kind() == reflect.Int8 || elem.Kind() == reflect.Int16 || elem.Kind() == reflect.Int32 || elem.Kind() == reflect.Int64 </span><span class="cov4" title="4">{
                        return false
                }</span>
                // Subsequent check for bool.
                <span class="cov2" title="2">if elem.Kind() == reflect.Bool </span><span class="cov2" title="2">{
                        return false
                }</span>
                // Otherwise, check if the pointed-to value is a zero value.
                <span class="cov0" title="0">return IsZeroValue(elem.Interface())</span>
        case reflect.Slice, reflect.Map, reflect.Interface, reflect.Chan:<span class="cov4" title="6">
                // For slices, maps, interfaces, and channels, check if they are nil.
                if v.IsNil() </span><span class="cov2" title="2">{
                        return true
                }</span>
                // Additionally, for slices and maps, check if they are non-nil but empty.
                <span class="cov4" title="4">return v.Len() == 0</span>
        case reflect.Struct:<span class="cov4" title="4">
                // Check if the struct has an IsZero method.
        if method := v.MethodByName("IsZero"); method.IsValid() </span><span class="cov2" title="2">{
            // Ensure the method has the correct signature: func() bool
            if method.Type().NumIn() == 0 &amp;&amp; method.Type().NumOut() == 1 &amp;&amp; method.Type().Out(0).Kind() == reflect.Bool </span><span class="cov2" title="2">{
                // Call the IsZero method and return its result.
                result := method.Call(nil)
                if len(result) == 1 &amp;&amp; result[0].Kind() == reflect.Bool </span><span class="cov2" title="2">{
                    return result[0].Bool()
                }</span>
            }
        }
                // Special case for time.Time: check if it represents the zero time.
                <span class="cov2" title="2">if t, ok := v.Interface().(time.Time); ok </span><span class="cov0" title="0">{
                        return t.IsZero()
                }</span>
                // For other structs, check each field. If any field is not a zero value, the struct is not a zero value.
                <span class="cov2" title="2">for i := 0; i &lt; v.NumField(); i++ </span><span class="cov3" title="3">{
                        if !IsZeroValue(v.Field(i).Interface()) </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
                // If all fields are zero values, the struct is a zero value.
                <span class="cov1" title="1">return true</span>
        default:<span class="cov0" title="0">
                // For any other type, consider it not a zero value.
                // This includes types like channels, which are not handled explicitly.
                return false</span>
        }
}

func IsAlpha(s string) bool <span class="cov5" title="9">{
        for _, r := range s </span><span class="cov9" title="49">{
                if !('a' &lt;= r &amp;&amp; r &lt;= 'z' || 'A' &lt;= r &amp;&amp; r &lt;= 'Z') </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov4" title="6">return true</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        "fmt"
        "log"

        api "github.com/MarketDataApp/sdk-go/client"
)

func main() <span class="cov0" title="0">{

        client, err := api.GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get client: %v", err)
        }</span>

        <span class="cov0" title="0">client.Debug(false)</span>

}

/*

        fmt.Println("Staring log example...")
        logExample()

        //fmt.Println("Starting market status request...")
        //marketstatusExample()

        fmt.Println("Staring rawResponse example...")
        rawHttpResponseExample()

*/

func optionsExamples() <span class="cov0" title="0">{
        fmt.Println("Staring Options/Chain example...")
        optionsChainExample()

        fmt.Println("Staring Options/Strikes example...")
        optionsStrikesExample()

        fmt.Println("Staring Options/Quotes example...")
        optionsQuotesExample()

        fmt.Println("Staring Options/Lookup example...")
        optionsLookupExample()

        fmt.Println("Staring Options/Expirations example...")
        optionsExpirationsExample()

}</span>

func stocksExamples() <span class="cov0" title="0">{
        fmt.Println("Staring Stocks/News example...")
        stockNewsExample()

        fmt.Println("Starting stock earnings request...")
        stockEarningsExample()

        fmt.Println("Starting stock quote request...")
        stockQuoteExample()

        fmt.Println("Starting stock candles request...")
        stockCandlesExample()

}</span>

func indexExamples() <span class="cov0" title="0">{
        fmt.Println("Starting index quote request...")
        indexQuoteExample()

        fmt.Println("Starting index candles request...")
        indexCandlesExample()

}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/iancoleman/orderedmap"
)

type IndicesCandlesResponse struct {
        Time  []int64   `json:"t" human:"Date"`
        Open  []float64 `json:"o" human:"Open"`
        High  []float64 `json:"h" human:"High"`
        Low   []float64 `json:"l" human:"Low"`
        Close []float64 `json:"c" human:"Close"`
}

func (icr *IndicesCandlesResponse) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Time: %v, Open: %v, High: %v, Low: %v, Close: %v",
                icr.Time, icr.Open, icr.High, icr.Low, icr.Close)
}</span>

func (icr *IndicesCandlesResponse) checkTimeInAscendingOrder() error <span class="cov1" title="1">{
        for i := 1; i &lt; len(icr.Time); i++ </span><span class="cov4" title="2">{
                if icr.Time[i] &lt; icr.Time[i-1] </span><span class="cov0" title="0">{
                        return fmt.Errorf("time is not in ascending order")
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// checkForEqualSlices checks if all slices in the IndicesCandlesResponse struct have the same length.
// It returns an error if the lengths are not equal.
func (icr *IndicesCandlesResponse) checkForEqualSlices() error <span class="cov4" title="2">{
        // Create a slice of the lengths of the Time, Open, High, Low, and Close slices
        lengths := []int{
                len(icr.Time),
                len(icr.Open),
                len(icr.High),
                len(icr.Low),
                len(icr.Close),
        }

        // Check if all lengths in the lengths slice are equal
        // If they are not, return an error
        for i := 1; i &lt; len(lengths); i++ </span><span class="cov10" title="8">{
                if lengths[i] != lengths[0] </span><span class="cov0" title="0">{
                        return fmt.Errorf("arrays are not of the same length")
                }</span>
        }

        // If all lengths are equal, return nil
        <span class="cov4" title="2">return nil</span>
}

func (icr *IndicesCandlesResponse) checkForEmptySlices() error <span class="cov1" title="1">{
        // Check if any of the slices are empty
        if len(icr.Time) == 0 || len(icr.Open) == 0 || len(icr.High) == 0 || len(icr.Low) == 0 || len(icr.Close) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("one or more slices are empty")
        }</span>

        // If none of the slices are empty, return nil
        <span class="cov1" title="1">return nil</span>
}

type IndexCandle struct {
        Time  time.Time
        Open  float64
        High  float64
        Low   float64
        Close float64
}

func (ic IndexCandle) String() string <span class="cov5" title="3">{
        loc, _ := time.LoadLocation("America/New_York")
        return fmt.Sprintf("Time: %s, Open: %v, High: %v, Low: %v, Close: %v",
                ic.Time.In(loc).Format("2006-01-02 15:04:05 Z07:00"), ic.Open, ic.High, ic.Low, ic.Close)
}</span>

func (icr *IndicesCandlesResponse) Unpack() ([]IndexCandle, error) <span class="cov1" title="1">{
        if err := icr.checkForEqualSlices(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var indexCandles []IndexCandle
        for i := range icr.Time </span><span class="cov5" title="3">{
                indexCandle := IndexCandle{
                        Time:  time.Unix(icr.Time[i], 0),
                        Open:  icr.Open[i],
                        High:  icr.High[i],
                        Low:   icr.Low[i],
                        Close: icr.Close[i],
                }
                indexCandles = append(indexCandles, indexCandle)
        }</span>
        <span class="cov1" title="1">return indexCandles, nil</span>
}

// MarshalJSON is a method on the IndicesCandlesResponse struct.
// It marshals the struct into a JSON object.
// The JSON object is an ordered map with keys "s", "t", "o", "h", "l", and "c".
// The "s" key is always set to "ok".
// The "t", "o", "h", "l", and "c" keys correspond to the Time, Open, High, Low, and Close slices in the struct.
// The method returns the JSON object as a byte slice and any error encountered during the marshaling process.
func (icr *IndicesCandlesResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        // Create a new ordered map
        o := orderedmap.New()

        // Set the "s" key to "ok"
        o.Set("s", "ok")

        // Set the "t", "o", "h", "l", and "c" keys to the corresponding slices in the struct
        o.Set("t", icr.Time)
        o.Set("o", icr.Open)
        o.Set("h", icr.High)
        o.Set("l", icr.Low)
        o.Set("c", icr.Close)

        // Marshal the ordered map into a JSON object and return the result
        return json.Marshal(o)
}</span>

func (icr *IndicesCandlesResponse) UnmarshalJSON(data []byte) error <span class="cov1" title="1">{
        // Define a secondary type to prevent infinite recursion
        type Alias IndicesCandlesResponse
        aux := &amp;struct {
                *Alias
        }{
                Alias: (*Alias)(icr),
        }

        // Unmarshal the data into our auxiliary struct
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Call the Validate method
        <span class="cov1" title="1">if err := icr.Validate(); err != nil </span><span class="cov0" title="0">{
                // Print the contents of the auxiliary struct only if validation fails
                fmt.Println(icr.String())
                return err
        }</span>

        // Return nil if everything went well
        <span class="cov1" title="1">return nil</span>
}

func (icr *IndicesCandlesResponse) Validate() error <span class="cov1" title="1">{
        // Create a channel to handle errors
        errChan := make(chan error, 3)

        // Run each validation function concurrently
        go func() </span><span class="cov1" title="1">{ errChan &lt;- icr.checkTimeInAscendingOrder() }</span>()
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{ errChan &lt;- icr.checkForEqualSlices() }</span>()
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{ errChan &lt;- icr.checkForEmptySlices() }</span>()

        // Wait for all validation functions to finish
        <span class="cov1" title="1">for i := 0; i &lt; 3; i++ </span><span class="cov5" title="3">{
                if err := &lt;-errChan; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Return nil if there were no errors
        <span class="cov1" title="1">return nil</span>
}

func (icr *IndicesCandlesResponse) IsValid() bool <span class="cov0" title="0">{
        if err := icr.Validate(); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"
)

type IndexQuotesResponse struct {
        Symbol    []string   `json:"symbol"`
        Last      []float64  `json:"last"`
        Change    []*float64 `json:"change,omitempty"`
        ChangePct []*float64 `json:"changepct,omitempty"`
        High52    *[]float64 `json:"52weekHigh,omitempty"`
        Low52     *[]float64 `json:"52weekLow,omitempty"`
        Updated   []int64    `json:"updated"`
}

type IndexQuote struct {
        Symbol    string
        Last      float64
        Change    *float64
        ChangePct *float64
        High52    *float64
        Low52     *float64
        Volume    int64
        Updated   time.Time
}

func (iq IndexQuote) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        if iq.High52 != nil &amp;&amp; iq.Low52 != nil &amp;&amp; iq.Change != nil &amp;&amp; iq.ChangePct != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Last: %v, Volume: %v, Updated: %s, High52: %v, Low52: %v, Change: %v, ChangePct: %v",
                        iq.Symbol, iq.Last, iq.Volume, iq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *iq.High52, *iq.Low52, *iq.Change, *iq.ChangePct)
        }</span> else<span class="cov0" title="0"> if iq.High52 != nil &amp;&amp; iq.Low52 != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Last: %v, Volume: %v, Updated: %s, High52: %v, Low52: %v",
                        iq.Symbol, iq.Last, iq.Volume, iq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *iq.High52, *iq.Low52)
        }</span> else<span class="cov0" title="0"> if iq.Change != nil &amp;&amp; iq.ChangePct != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Last: %v, Volume: %v, Updated: %s, Change: %v, ChangePct: %v",
                        iq.Symbol, iq.Last, iq.Volume, iq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *iq.Change, *iq.ChangePct)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("Symbol: %s, Last: %v, Volume: %v, Updated: %s",
                        iq.Symbol, iq.Last, iq.Volume, iq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"))
        }</span>
}

func (iqr *IndexQuotesResponse) Unpack() ([]IndexQuote, error) <span class="cov0" title="0">{
        var indexQuotes []IndexQuote
        for i := range iqr.Symbol </span><span class="cov0" title="0">{
                indexQuote := IndexQuote{
                        Symbol:  iqr.Symbol[i],
                        Last:    iqr.Last[i],
                        Updated: time.Unix(iqr.Updated[i], 0),
                }
                if iqr.Change != nil &amp;&amp; len(iqr.Change) &gt; i </span><span class="cov0" title="0">{
                        indexQuote.Change = iqr.Change[i]
                }</span>
                <span class="cov0" title="0">if iqr.ChangePct != nil &amp;&amp; len(iqr.ChangePct) &gt; i </span><span class="cov0" title="0">{
                        indexQuote.ChangePct = iqr.ChangePct[i]
                }</span>
                <span class="cov0" title="0">if iqr.High52 != nil &amp;&amp; len(*iqr.High52) &gt; i </span><span class="cov0" title="0">{
                        val := (*iqr.High52)[i]
                        indexQuote.High52 = &amp;val
                }</span>
                <span class="cov0" title="0">if iqr.Low52 != nil &amp;&amp; len(*iqr.Low52) &gt; i </span><span class="cov0" title="0">{
                        val := (*iqr.Low52)[i]
                        indexQuote.Low52 = &amp;val
                }</span>
                <span class="cov0" title="0">indexQuotes = append(indexQuotes, indexQuote)</span>
        }
        <span class="cov0" title="0">return indexQuotes, nil</span>
}

func (iqr *IndexQuotesResponse) String() string <span class="cov0" title="0">{
        var result strings.Builder

        fmt.Fprintf(&amp;result, "Symbol: [%v], Last: [%v]", strings.Join(iqr.Symbol, ", "), joinFloat64Slice(iqr.Last))

        if iqr.Change != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", Change: [%v]", joinFloat64PointerSlice(iqr.Change))
        }</span>
        <span class="cov0" title="0">if iqr.ChangePct != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", ChangePct: [%v]", joinFloat64PointerSlice(iqr.ChangePct))
        }</span>
        <span class="cov0" title="0">if iqr.High52 != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", High52: [%v]", joinFloat64Slice(*iqr.High52))
        }</span>
        <span class="cov0" title="0">if iqr.Low52 != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", Low52: [%v]", joinFloat64Slice(*iqr.Low52))
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(&amp;result, ", Updated: [%v]", joinInt64Slice(iqr.Updated))

        return result.String()</span>
}

func joinFloat64Slice(slice []float64) string <span class="cov0" title="0">{
        strs := make([]string, len(slice))
        for i, v := range slice </span><span class="cov0" title="0">{
                strs[i] = fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">return strings.Join(strs, ", ")</span>
}

func joinFloat64PointerSlice(slice []*float64) string <span class="cov0" title="0">{
        strs := make([]string, len(slice))
        for i, v := range slice </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        strs[i] = fmt.Sprintf("%v", *v)
                }</span> else<span class="cov0" title="0"> {
                        strs[i] = "nil"
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(strs, ", ")</span>
}

func joinInt64Slice(slice []int64) string <span class="cov0" title="0">{
        strs := make([]string, len(slice))
        for i, v := range slice </span><span class="cov0" title="0">{
                strs[i] = fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">return strings.Join(strs, ", ")</span>
}</pre>
		
		<pre class="file" id="file46" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
)

// MarketStatusResponse represents the response from a market status request.
type MarketStatusResponse struct {
        Date   []int64   `json:"date"`
        Status *[]string `json:"status,omitempty"`
}

// IsValid checks if there's at least 1 date in the response.
func (msr *MarketStatusResponse) IsValid() bool <span class="cov0" title="0">{
        return len(msr.Date) &gt; 0
}</span>

// String returns a string representation of the MarketStatusResponse.
func (msr *MarketStatusResponse) String() string <span class="cov0" title="0">{
        var parts []string
        if msr.Status != nil &amp;&amp; len(msr.Date) == len(*msr.Status) </span><span class="cov0" title="0">{
                for i, date := range msr.Date </span><span class="cov0" title="0">{
                        t := time.Unix(date, 0)
                        dateStr := t.Format("2006-01-02")
                        status := (*msr.Status)[i]
                        part := fmt.Sprintf("Date: %s, Status: %s", dateStr, status)
                        parts = append(parts, part)
                }</span>
        }
        <span class="cov0" title="0">return "MarketStatusResponse{\n" + strings.Join(parts, ",\n") + "\n}"</span>
}

// String returns a string representation of the MarketStatus.
func (ms MarketStatusReport) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("MarketStatus{Date: %v, Open: %v, Closed: %v}", ms.Date, ms.Open, ms.Closed)
}</span>

// Unpack unpacks the MarketStatusResponse into a slice of MarketStatus.
func (msr *MarketStatusResponse) Unpack() ([]MarketStatusReport, error) <span class="cov5" title="2">{
        if msr.Status == nil || len(msr.Date) != len(*msr.Status) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("date and status slices are not of the same length")
        }</span>

        <span class="cov5" title="2">var marketStatuses []MarketStatusReport
        for i, date := range msr.Date </span><span class="cov10" title="4">{
                status := strings.ToLower((*msr.Status)[i])
                marketStatus := MarketStatusReport{
                        Date:   time.Unix(date, 0),
                        Open:   status == "open",
                        Closed: status == "closed",
                }
                marketStatuses = append(marketStatuses, marketStatus)
        }</span>

        <span class="cov5" title="2">return marketStatuses, nil</span>
}

// GetOpenDates returns a slice of dates when the market was open.
func (msr *MarketStatusResponse) GetOpenDates() ([]time.Time, error) <span class="cov1" title="1">{
        marketStatuses, err := msr.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var openDates []time.Time
        for _, marketStatus := range marketStatuses </span><span class="cov5" title="2">{
                if marketStatus.Open </span><span class="cov1" title="1">{
                        openDates = append(openDates, marketStatus.Date)
                }</span>
        }

        <span class="cov1" title="1">return openDates, nil</span>
}

// GetClosedDates returns a slice of dates when the market was closed.
func (msr *MarketStatusResponse) GetClosedDates() ([]time.Time, error) <span class="cov1" title="1">{
        marketStatuses, err := msr.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var closedDates []time.Time
        for _, marketStatus := range marketStatuses </span><span class="cov5" title="2">{
                if marketStatus.Closed </span><span class="cov1" title="1">{
                        closedDates = append(closedDates, marketStatus.Date)
                }</span>
        }

        <span class="cov1" title="1">return closedDates, nil</span>
}

// GetDateRange returns the date range of the MarketStatusResponse.
func (msr *MarketStatusResponse) GetDateRange() (*dates.DateRange, error) <span class="cov0" title="0">{
        // Use the Earliest and Latest functions to find the earliest and latest dates
        earliest, err := dates.Earliest(msr.Date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">latest, err := dates.Latest(msr.Date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a new DateRange using NewDateRange function
        <span class="cov0" title="0">dr, err := dates.NewDateRange(earliest, latest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return dr, nil</span>
}

// MarketStatusReport represents the status of a market.
type MarketStatusReport struct {
        Date   time.Time
        Open   bool
        Closed bool
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package models

import (
        "fmt"
        "time"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
)

type OptionsExpirationsResponse struct {
        Expirations []string
        Updated     int64
}

func (oer *OptionsExpirationsResponse) IsValid() bool <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        if len(oer.Expirations) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, exp := range oer.Expirations </span><span class="cov0" title="0">{
                _, err := dates.ToTime(exp, loc)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}


func (oer *OptionsExpirationsResponse) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expirations: %v, Updated: %v", oer.Expirations, oer.Updated)
}</span>

func (oer *OptionsExpirationsResponse) Unpack() ([]time.Time, error) <span class="cov0" title="0">{
        expirations := make([]time.Time, len(oer.Expirations))
        loc, err := time.LoadLocation("America/New_York")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for i, exp := range oer.Expirations </span><span class="cov0" title="0">{
                t, err := dates.ToTime(exp, loc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">t = t.Add(time.Duration(16) * time.Hour) // Adding 16 hours to the time after parsing. Options expire 4:00 PM Eastern Time.
                expirations[i] = t</span>
        }
        <span class="cov0" title="0">return expirations, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

import (
        "fmt"
)

type OptionLookupResponse struct {
        OptionSymbol string `json:"optionSymbol"`
}

func (olr *OptionLookupResponse) IsValid() bool <span class="cov0" title="0">{
        if olr.OptionSymbol == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (olr *OptionLookupResponse) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OptionSymbol: %v", olr.OptionSymbol)
}</span>

func (olr *OptionLookupResponse) Unpack() (string, error) <span class="cov0" title="0">{
        if !olr.IsValid() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid OptionLookupResponse")
        }</span>
        <span class="cov0" title="0">return olr.OptionSymbol, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"
)

/* Example Response:
{"s":"ok","optionSymbol":["SPXW240202P04845000"],"underlying":["SPXW"],"expiration":[1706907600],"side":["put"],"strike":[4845.0],"firstTraded":[1703601000],"dte":[1],"updated":[1706811106],"bid":[7.2],"bidSize":[219],"mid":[7.3],"ask":[7.4],"askSize":[154],"last":[7.35],"openInterest":[752],"volume":[2012],"inTheMoney":[false],"intrinsicValue":[0.0],"extrinsicValue":[7.3],"underlyingPrice":[4894.75],"iv":[0.192],"delta":[-0.309],"gamma":[0.007],"theta":[-8.494],"vega":[0.988],"rho":[0.107]}
*/

type OptionQuotesResponse struct {
        OptionSymbol    []string  `json:"optionSymbol"`
        Underlying      []string  `json:"underlying"`
        Expiration      []int64   `json:"expiration"`
        Side            []string  `json:"side"`
        Strike          []float64 `json:"strike"`
        FirstTraded     []int64   `json:"firstTraded"`
        DTE             []int     `json:"dte"`
        Ask             []float64 `json:"ask"`
        AskSize         []int64   `json:"askSize"`
        Bid             []float64 `json:"bid"`
        BidSize         []int64   `json:"bidSize"`
        Mid             []float64 `json:"mid"`
        Last            []float64 `json:"last"`
        Volume          []int64   `json:"volume"`
        OpenInterest    []int64   `json:"openInterest"`
        UnderlyingPrice []float64 `json:"underlyingPrice"`
        InTheMoney      []bool    `json:"inTheMoney"`
        Updated         []int64   `json:"updated"`
        IV              []float64 `json:"iv"`
        Delta           []float64 `json:"delta"`
        Gamma           []float64 `json:"gamma"`
        Theta           []float64 `json:"theta"`
        Vega            []float64 `json:"vega"`
        Rho             []float64 `json:"rho"`
        IntrinsicValue  []float64 `json:"intrinsicValue"`
        ExtrinsicValue  []float64 `json:"extrinsicValue"`
}

type OptionQuote struct {
        OptionSymbol    string
        Underlying      string
        Expiration      time.Time
        Side            string
        Strike          float64
        FirstTraded     time.Time
        DTE             int
        Ask             float64
        AskSize         int64
        Bid             float64
        BidSize         int64
        Mid             float64
        Last            float64
        Volume          int64
        OpenInterest    int64
        UnderlyingPrice float64
        InTheMoney      bool
        Updated         time.Time
        IV              float64
        Delta           float64
        Gamma           float64
        Theta           float64
        Vega            float64
        Rho             float64
        IntrinsicValue  float64
        ExtrinsicValue  float64
}

func (oq OptionQuote) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        return fmt.Sprintf("Option Symbol: %s, Underlying: %s, Expiration: %v, Side: %s, Strike: %v, First Traded: %v, DTE: %v, Ask: %v, Ask Size: %v, Bid: %v, Bid Size: %v, Mid: %v, Last: %v, Volume: %v, Open Interest: %v, Underlying Price: %v, In The Money: %v, Updated: %s, IV: %v, Delta: %v, Gamma: %v, Theta: %v, Vega: %v, Rho: %v, Intrinsic Value: %v, Extrinsic Value: %v",
                oq.OptionSymbol, oq.Underlying, oq.Expiration, oq.Side, oq.Strike, oq.FirstTraded, oq.DTE, oq.Ask, oq.AskSize, oq.Bid, oq.BidSize, oq.Mid, oq.Last, oq.Volume, oq.OpenInterest, oq.UnderlyingPrice, oq.InTheMoney, oq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), oq.IV, oq.Delta, oq.Gamma, oq.Theta, oq.Vega, oq.Rho, oq.IntrinsicValue, oq.ExtrinsicValue)
}</span>

func (oqr *OptionQuotesResponse) Unpack() ([]OptionQuote, error) <span class="cov0" title="0">{
        loc, err := time.LoadLocation("America/New_York") // Load the New York time zone
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load New York time zone: %v", err)
        }</span>
        <span class="cov0" title="0">var optionQuotes []OptionQuote
        for i := range oqr.OptionSymbol </span><span class="cov0" title="0">{
                optionQuote := OptionQuote{
                        OptionSymbol:    oqr.OptionSymbol[i],
                        Underlying:      oqr.Underlying[i],
                        Expiration:      time.Unix(oqr.Expiration[i], 0).In(loc), // Convert to time.Time in America/New_York
                        Side:            oqr.Side[i],
                        Strike:          oqr.Strike[i],
                        FirstTraded:     time.Unix(oqr.FirstTraded[i], 0).In(loc), // Convert to time.Time in America/New_York
                        DTE:             oqr.DTE[i],
                        Ask:             oqr.Ask[i],
                        AskSize:         oqr.AskSize[i],
                        Bid:             oqr.Bid[i],
                        BidSize:         oqr.BidSize[i],
                        Mid:             oqr.Mid[i],
                        Last:            oqr.Last[i],
                        Volume:          oqr.Volume[i],
                        OpenInterest:    oqr.OpenInterest[i],
                        UnderlyingPrice: oqr.UnderlyingPrice[i],
                        InTheMoney:      oqr.InTheMoney[i],
                        Updated:         time.Unix(oqr.Updated[i], 0).In(loc), // Convert to time.Time in America/New_York
                        IV:              oqr.IV[i],
                        Delta:           oqr.Delta[i],
                        Gamma:           oqr.Gamma[i],
                        Theta:           oqr.Theta[i],
                        Vega:            oqr.Vega[i],
                        Rho:             oqr.Rho[i],
                        IntrinsicValue:  oqr.IntrinsicValue[i],
                        ExtrinsicValue:  oqr.ExtrinsicValue[i],
                }
                optionQuotes = append(optionQuotes, optionQuote)
        }</span>
        <span class="cov0" title="0">return optionQuotes, nil</span>
}

func (oqr *OptionQuotesResponse) String() string <span class="cov0" title="0">{
        optionQuotes, err := oqr.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error unpacking OptionQuotesResponse: %v", err)
        }</span>

        <span class="cov0" title="0">var quotesStrings []string
        for _, quote := range optionQuotes </span><span class="cov0" title="0">{
                quotesStrings = append(quotesStrings, quote.String())
        }</span>

        <span class="cov0" title="0">return strings.Join(quotesStrings, "\n")</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"
)

/*

Example API Response JSON:
{
        "s":"ok",
          "updated":1706791474,
        "2024-02-02":[50.0,60.0,65.0,70.0,75.0,80.0,85.0,90.0,95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,152.5,155.0,157.5,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0],
        "2024-02-09":[95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0],
        "2024-02-16":[50.0,55.0,60.0,65.0,70.0,75.0,80.0,85.0,90.0,95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0,270.0,275.0,280.0,285.0,290.0,295.0,300.0,305.0,310.0,315.0,320.0],
        "2024-02-23":[100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,165.0,170.0,175.0,180.0,185.0,190.0,195.0,200.0,205.0,210.0,215.0,220.0,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0]
}

*/

type OptionsStrikes struct {
        Expiration time.Time
        Strikes    []float64
}

type OptionsStrikesResponse struct {
        Updated int                  `json:"updated"`
        Strikes map[string][]float64 `json:"-"`
}

func (osr *OptionsStrikesResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var aux map[string]interface{}
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">osr.Strikes = make(map[string][]float64)
        for key, value := range aux </span><span class="cov0" title="0">{
                if key != "updated" &amp;&amp; key != "s" </span><span class="cov0" title="0">{
                        values := value.([]interface{})
                        floats := make([]float64, len(values))
                        for i, v := range values </span><span class="cov0" title="0">{
                                floats[i] = v.(float64)
                        }</span>
                        <span class="cov0" title="0">osr.Strikes[key] = floats</span>
                } else<span class="cov0" title="0"> if key == "updated" </span><span class="cov0" title="0">{
                        osr.Updated = int(value.(float64))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (os OptionsStrikes) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        dateStr := os.Expiration.In(loc).Format("Jan 02, 2006 15:04 MST")

        var strikesStrBuilder strings.Builder
        strikesStrBuilder.WriteString("[")
        for i, strike := range os.Strikes </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        strikesStrBuilder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">strikesStrBuilder.WriteString(fmt.Sprintf("%.2f", strike))</span>
        }
        <span class="cov0" title="0">strikesStrBuilder.WriteString("]")

        return fmt.Sprintf("Expiration: %s, Strikes: %s", dateStr, strikesStrBuilder.String())</span>
}

func (osr *OptionsStrikesResponse) IsValid() bool <span class="cov0" title="0">{
        if len(osr.Strikes) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (osr *OptionsStrikesResponse) String() string <span class="cov0" title="0">{
    // First, unpack the response to get a slice of OptionsStrikes
    unpackedStrikes, err := osr.Unpack()
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Sprintf("Error unpacking strikes: %v", err)
    }</span>

    // Initialize a builder for constructing the output string
    <span class="cov0" title="0">var sb strings.Builder

    // Loop over each OptionsStrikes in the unpacked slice
    for _, strike := range unpackedStrikes </span><span class="cov0" title="0">{
        // Use the String method of OptionsStrikes to append each to the builder
        sb.WriteString(strike.String() + "; ")
    }</span>

    // Append the "Updated" information last
    <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("Updated: %v", osr.Updated))

    // Return the constructed string
    return sb.String()</span>
}

func (osr *OptionsStrikesResponse) Unpack() ([]OptionsStrikes, error) <span class="cov0" title="0">{
        if !osr.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid OptionsStrikesResponse")
        }</span>

        <span class="cov0" title="0">loc, err := time.LoadLocation("America/New_York")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error loading location: %v", err)
        }</span>

        <span class="cov0" title="0">var unpackedStrikes []OptionsStrikes
        for dateStr, strikes := range osr.Strikes </span><span class="cov0" title="0">{
                // Parse the date in the given location
                date, err := time.ParseInLocation("2006-01-02", dateStr, loc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing date %s: %v", dateStr, err)
                }</span>
                // Set the time to 16:00:00
                <span class="cov0" title="0">date = time.Date(date.Year(), date.Month(), date.Day(), 16, 0, 0, 0, loc)

                unpackedStrikes = append(unpackedStrikes, OptionsStrikes{
                        Expiration: date,
                        Strikes:    strikes,
                })</span>
        }
        <span class="cov0" title="0">return unpackedStrikes, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "sort"
        "time"

        "github.com/MarketDataApp/sdk-go/helpers/dates"
        "github.com/iancoleman/orderedmap"
)

type StockCandlesResponse struct {
        Time   []int64    `json:"t" human:"Date"`
        Open   []float64  `json:"o" human:"Open"`
        High   []float64  `json:"h" human:"High"`
        Low    []float64  `json:"l" human:"Low"`
        Close  []float64  `json:"c" human:"Close"`
        Volume []int64    `json:"v" human:"Volume"`
        VWAP   *[]float64 `json:"vwap,omitempty" human:"VWAP,omitempty"`       // Optional, for V2 candles
        N      *[]int64   `json:"n,omitempty" human:"No. of Trades,omitempty"` // Optional, for V2 candles
}

type StockCandle struct {
        Time   time.Time
        Open   float64
        High   float64
        Low    float64
        Close  float64
        Volume int64
        VWAP   float64
        N      int64
}

func (sc StockCandle) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        if sc.VWAP == 0 &amp;&amp; sc.N == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("Time: %s, Open: %v, High: %v, Low: %v, Close: %v, Volume: %v",
                        sc.Time.In(loc).Format("2006-01-02 15:04:05 Z07:00"), sc.Open, sc.High, sc.Low, sc.Close, sc.Volume)
                }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("Time: %s, Open: %v, High: %v, Low: %v, Close: %v, Volume: %v, VWAP: %v, N: %v",
                        sc.Time.In(loc).Format("2006-01-02 15:04:05 Z07:00"), sc.Open, sc.High, sc.Low, sc.Close, sc.Volume, sc.VWAP, sc.N)
        }</span>
}


func (scr *StockCandlesResponse) Unpack() ([]StockCandle, error) <span class="cov2" title="2">{
        if err := scr.checkForEqualSlices(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">var stockCandles []StockCandle
        for i := range scr.Time </span><span class="cov3" title="4">{
                stockCandle := StockCandle{
                        Time:   time.Unix(scr.Time[i], 0),
                        Open:   scr.Open[i],
                        High:   scr.High[i],
                        Low:    scr.Low[i],
                        Close:  scr.Close[i],
                        Volume: scr.Volume[i],
                }
                if scr.VWAP != nil </span><span class="cov2" title="2">{
                        stockCandle.VWAP = (*scr.VWAP)[i]
                }</span>
                <span class="cov3" title="4">if scr.N != nil </span><span class="cov2" title="2">{
                        stockCandle.N = (*scr.N)[i]
                }</span>
                <span class="cov3" title="4">stockCandles = append(stockCandles, stockCandle)</span>
        }
        <span class="cov2" title="2">return stockCandles, nil</span>
}

func (s *StockCandlesResponse) String() string <span class="cov0" title="0">{
        // Determine the version of the struct
        version, _ := s.getVersion()

        if version == 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("Time: %v, Open: %v, High: %v, Low: %v, Close: %v, Volume: %v",
                        s.Time, s.Open, s.High, s.Low, s.Close, s.Volume)
        }</span> else<span class="cov0" title="0"> {
                vwap := "nil"
                n := "nil"
                if s.VWAP != nil </span><span class="cov0" title="0">{
                        vwap = fmt.Sprint(*s.VWAP)
                }</span>
                <span class="cov0" title="0">if s.N != nil </span><span class="cov0" title="0">{
                        n = fmt.Sprint(*s.N)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Time: %v, Open: %v, High: %v, Low: %v, Close: %v, Volume: %v, VWAP: %v, N: %v",
                        s.Time, s.Open, s.High, s.Low, s.Close, s.Volume, vwap, n)</span>
        }
}

func (s *StockCandlesResponse) checkTimeInAscendingOrder() error <span class="cov6" title="15">{
        for i := 1; i &lt; len(s.Time); i++ </span><span class="cov10" title="98">{
                if s.Time[i] &lt; s.Time[i-1] </span><span class="cov1" title="1">{
                        return fmt.Errorf("time is not in ascending order")
                }</span>
        }
        <span class="cov6" title="14">return nil</span>
}

func (s *StockCandlesResponse) IsValid() bool <span class="cov0" title="0">{
        if err := s.Validate(); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (s *StockCandlesResponse) Validate() error <span class="cov6" title="13">{
        // Create a channel to handle errors
        errChan := make(chan error, 4)

        // Run each validation function concurrently
        go func() </span><span class="cov6" title="13">{ errChan &lt;- s.checkTimeInAscendingOrder() }</span>()
        <span class="cov6" title="13">go func() </span><span class="cov6" title="13">{ errChan &lt;- s.checkForEqualSlices() }</span>()
        <span class="cov6" title="13">go func() </span><span class="cov6" title="13">{ errChan &lt;- s.checkForEmptySlices() }</span>()
        <span class="cov6" title="13">go func() </span><span class="cov6" title="13">{ _, err := s.getVersion(); errChan &lt;- err }</span>()

        // Check for errors from the validation functions
        <span class="cov6" title="13">for i := 0; i &lt; 4; i++ </span><span class="cov8" title="52">{
                if err := &lt;-errChan; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="13">return nil</span>
}

// checkForEqualSlices checks if all slices in the StockCandles struct have the same length.
// It returns an error if the lengths are not equal.
// This is important to ensure that each element in a slice corresponds to the same element in the other slices.
// For example, the first element in the Time slice should correspond to the first element in the Open, High, Low, Close, and Volume slices.
// If the Version is 2, it also checks the VWAP and N slices.
func (s *StockCandlesResponse) checkForEqualSlices() error <span class="cov6" title="15">{
        // Create a slice of the lengths of the Time, Open, High, Low, Close, and Volume slices
        lengths := []int{
                len(s.Time),
                len(s.Open),
                len(s.High),
                len(s.Low),
                len(s.Close),
                len(s.Volume),
        }

        // If the Version is 2, add the lengths of the VWAP and N slices to the lengths slice
        version, err := s.getVersion()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="15">if version == 2 </span><span class="cov4" title="7">{
                lengths = append(lengths, len(*s.VWAP), len(*s.N))
        }</span>

        // Check if all lengths in the lengths slice are equal
        // If they are not, return an error
        <span class="cov6" title="15">for i := 1; i &lt; len(lengths); i++ </span><span class="cov9" title="89">{
                if lengths[i] != lengths[0] </span><span class="cov0" title="0">{
                        return fmt.Errorf("arrays are not of the same length")
                }</span>
        }

        // If all lengths are equal, return nil
        <span class="cov6" title="15">return nil</span>
}

func (s *StockCandlesResponse) checkForEmptySlices() error <span class="cov6" title="13">{
        // Check if any of the slices are empty
        if len(s.Time) == 0 || len(s.Open) == 0 || len(s.High) == 0 || len(s.Low) == 0 || len(s.Close) == 0 || len(s.Volume) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("one or more slices are empty")
        }</span>

        // Use the getVersion method to check if the Version is 2, also check the VWAP and N slices
        <span class="cov6" title="13">version, err := s.getVersion()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="13">if version == 2 </span><span class="cov4" title="6">{
                if s.VWAP != nil &amp;&amp; len(*s.VWAP) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("slice VWAP is empty")
                }</span>
                <span class="cov4" title="6">if s.N != nil &amp;&amp; len(*s.N) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("slice N is empty")
                }</span>
        }

        // If none of the slices are empty, return nil
        <span class="cov6" title="13">return nil</span>
}

// getVersion returns the version of the StockCandles.
// If the version is not 1 or 2, it returns an error.
func (s *StockCandlesResponse) getVersion() (int, error) <span class="cov8" title="48">{
        if s.Time != nil &amp;&amp; s.Open != nil &amp;&amp; s.High != nil &amp;&amp; s.Low != nil &amp;&amp; s.Close != nil &amp;&amp; s.Volume != nil &amp;&amp; s.VWAP == nil &amp;&amp; s.N == nil </span><span class="cov7" title="25">{
                return 1, nil
        }</span> else<span class="cov7" title="23"> if s.Time != nil &amp;&amp; s.Open != nil &amp;&amp; s.High != nil &amp;&amp; s.Low != nil &amp;&amp; s.Close != nil &amp;&amp; s.Volume != nil &amp;&amp; s.VWAP != nil &amp;&amp; s.N != nil &amp;&amp; len(*s.VWAP) &gt; 0 &amp;&amp; len(*s.N) &gt; 0 </span><span class="cov7" title="23">{
                return 2, nil
        }</span> else<span class="cov0" title="0"> {
                return 0, fmt.Errorf("invalid StockCandle version")
        }</span>
}

// MarshalJSON is a method on the StockCandles struct.
// It marshals the struct into a JSON object.
// The JSON object is an ordered map with keys "s", "t", "o", "h", "l", "c", "v", "vw", and "n".
// The "s" key is always set to "ok".
// The "t", "o", "h", "l", "c", and "v" keys correspond to the Time, Open, High, Low, Close, and Volume slices in the struct.
// If the Version of the struct is 2, the "vw" and "n" keys are also set, corresponding to the VWAP and N slices in the struct.
// The method returns the JSON object as a byte slice and any error encountered during the marshaling process.
func (s *StockCandlesResponse) MarshalJSON() ([]byte, error) <span class="cov1" title="1">{
        // Create a new ordered map
        o := orderedmap.New()

        // Set the "s" key to "ok"
        o.Set("s", "ok")

        // Set the "t", "o", "h", "l", "c", and "v" keys to the corresponding slices in the struct
        o.Set("t", s.Time)
        o.Set("o", s.Open)
        o.Set("h", s.High)
        o.Set("l", s.Low)
        o.Set("c", s.Close)
        o.Set("v", s.Volume)

        // If the Version of the struct is 2, set the "vw" and "n" keys to the corresponding slices in the struct
        version, err := s.getVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if version == 2 </span><span class="cov1" title="1">{
                o.Set("vwap", s.VWAP)
                o.Set("n", s.N)
        }</span>

        // Marshal the ordered map into a JSON object and return the result
        <span class="cov1" title="1">return json.Marshal(o)</span>
}

func (s *StockCandlesResponse) UnmarshalJSON(data []byte) error <span class="cov5" title="12">{
        // Define a secondary type to prevent infinite recursion
        type Alias StockCandlesResponse
        aux := &amp;struct {
                *Alias
        }{
                Alias: (*Alias)(s),
        }

        // Unmarshal the data into our auxiliary struct
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Call the Validate method
        <span class="cov5" title="12">if err := s.Validate(); err != nil </span><span class="cov0" title="0">{
                // Print the contents of the auxiliary struct only if validation fails
                fmt.Println(s.String())
                return err
        }</span>

        // Return nil if everything went well
        <span class="cov5" title="12">return nil</span>
}

func (s *StockCandlesResponse) GetDateRange() (dates.DateRange, error) <span class="cov5" title="9">{
        // Pass the slice of timestamps directly to Earliest and Latest
        min, err1 := dates.Earliest(s.Time)
        max, err2 := dates.Latest(s.Time)
        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return dates.DateRange{}, fmt.Errorf("error calculating date ranges: %v, %v", err1, err2)
        }</span>

        // Use NewDateRange to create a new DateRange instance
        <span class="cov5" title="9">dr, err := dates.NewDateRange(min, max)
        if err != nil </span><span class="cov0" title="0">{
                return dates.DateRange{}, err
        }</span>

        <span class="cov5" title="9">return *dr, nil</span>
}

// pruneIndices is a method on the StockCandles struct.
// It removes the data points at the given indices from the StockCandles instance.
// It modifies the Time, Open, High, Low, Close, and Volume slices to exclude the data points at the given indices.
// If the VWAP and N fields are not nil, it also prunes these slices.
// The indices are sorted in reverse order before pruning to avoid index out of range errors.
// If an index is out of range, it is ignored.
func (s *StockCandlesResponse) pruneIndices(indices ...int) <span class="cov2" title="2">{
        sort.Sort(sort.Reverse(sort.IntSlice(indices)))
        for _, index := range indices </span><span class="cov2" title="2">{
                if index &lt; 0 || index &gt;= len(s.Time) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="2">s.Time = append(s.Time[:index], s.Time[index+1:]...)
                s.Open = append(s.Open[:index], s.Open[index+1:]...)
                s.High = append(s.High[:index], s.High[index+1:]...)
                s.Low = append(s.Low[:index], s.Low[index+1:]...)
                s.Close = append(s.Close[:index], s.Close[index+1:]...)
                s.Volume = append(s.Volume[:index], s.Volume[index+1:]...)

                if s.VWAP != nil </span><span class="cov1" title="1">{
                        *s.VWAP = append((*s.VWAP)[:index], (*s.VWAP)[index+1:]...)
                }</span>

                <span class="cov2" title="2">if s.N != nil </span><span class="cov1" title="1">{
                        *s.N = append((*s.N)[:index], (*s.N)[index+1:]...)
                }</span>
        }
}

// pruneBeforeIndex removes the data point at the given index and all data points before it from the StockCandles instance.
// It modifies the Time, Open, High, Low, Close, and Volume slices to only include data from the given index onwards.
// If the VWAP and N fields are not nil, it also prunes these slices.
func (s *StockCandlesResponse) pruneBeforeIndex(index int) <span class="cov1" title="1">{
        if index+1 &lt; len(s.Time) </span><span class="cov1" title="1">{
                s.Time = s.Time[index+1:]
                s.Open = s.Open[index+1:]
                s.High = s.High[index+1:]
                s.Low = s.Low[index+1:]
                s.Close = s.Close[index+1:]
                s.Volume = s.Volume[index+1:]

                if s.VWAP != nil </span><span class="cov1" title="1">{
                        *s.VWAP = (*s.VWAP)[index+1:]
                }</span>

                <span class="cov1" title="1">if s.N != nil </span><span class="cov1" title="1">{
                        *s.N = (*s.N)[index+1:]
                }</span>
        }
}

// pruneAfterIndex removes the data point at the given index and all data points after it from the StockCandles instance.
// It modifies the Time, Open, High, Low, Close, and Volume slices to only include data up to, but not including, the given index.
// If the VWAP and N fields are not nil, it also prunes these slices.
// If the index is out of range, it returns an error.
func (s *StockCandlesResponse) pruneAfterIndex(index int) error <span class="cov1" title="1">{
        // Check if the index is within the range of the slices
        if index &lt; 0 || index &gt;= len(s.Time) </span><span class="cov0" title="0">{
                return fmt.Errorf("index %d out of range (0-%d)", index, len(s.Time)-1)
        }</span>

        // Prune the Time, Open, High, Low, Close, and Volume slices
        <span class="cov1" title="1">s.Time = s.Time[:index]
        s.Open = s.Open[:index]
        s.High = s.High[:index]
        s.Low = s.Low[:index]
        s.Close = s.Close[:index]
        s.Volume = s.Volume[:index]

        // If the VWAP field is not nil, prune the VWAP slice
        if s.VWAP != nil </span><span class="cov1" title="1">{
                *s.VWAP = (*s.VWAP)[:index]
        }</span>

        // If the N field is not nil, prune the N slice
        <span class="cov1" title="1">if s.N != nil </span><span class="cov1" title="1">{
                *s.N = (*s.N)[:index]
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *StockCandlesResponse) PruneOutsideDateRange(dr dates.DateRange) error <span class="cov1" title="1">{
        // Validate all timestamps
        validTimestamps, invalidTimestamps := dr.ValidateTimestamps(s.Time...)
        fmt.Println("Valid timestamps: ", validTimestamps)
        fmt.Println("Invalid timestamps: ", invalidTimestamps)

        // Loop through invalid timestamps, get index and prune
        for _, invalidTimestamp := range invalidTimestamps </span><span class="cov2" title="2">{
                for </span><span class="cov3" title="4">{
                        index := s.getIndex(invalidTimestamp)
                        if index &gt;= len(s.Time) || s.Time[index] != invalidTimestamp </span><span class="cov2" title="2">{
                                break</span>
                        }
                        <span class="cov2" title="2">s.pruneIndex(index)</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// getIndex is a method on the StockCandles struct.
// It iterates over the Time slice and returns the index of the first occurrence of the provided timestamp.
// If the timestamp is not found in the Time slice, it returns the length of the Time slice.
func (s *StockCandlesResponse) getIndex(t int64) int <span class="cov3" title="4">{
        for i, timestamp := range s.Time </span><span class="cov5" title="12">{
                if timestamp == t </span><span class="cov2" title="2">{
                        return i
                }</span>
        }
        <span class="cov2" title="2">return len(s.Time)</span>
}

// pruneIndex is a method on the StockCandles struct.
// It removes the element at the specified index from all slices in the struct.
// If the index is out of range, it returns an error.
// If the VWAP or N slices are not nil, it also removes the element at the index from these slices.
func (s *StockCandlesResponse) pruneIndex(index int) error <span class="cov2" title="2">{
        if index &lt; 0 || index &gt;= len(s.Time) </span><span class="cov0" title="0">{
                return fmt.Errorf("index %d out of range (0-%d)", index, len(s.Time)-1)
        }</span>

        // Remove the element at the index from the Time, Open, High, Low, Close, and Volume slices
        <span class="cov2" title="2">s.Time = append(s.Time[:index], s.Time[index+1:]...)
        s.Open = append(s.Open[:index], s.Open[index+1:]...)
        s.High = append(s.High[:index], s.High[index+1:]...)
        s.Low = append(s.Low[:index], s.Low[index+1:]...)
        s.Close = append(s.Close[:index], s.Close[index+1:]...)
        s.Volume = append(s.Volume[:index], s.Volume[index+1:]...)

        // If the VWAP slice is not nil, remove the element at the index from the VWAP slice
        if s.VWAP != nil </span><span class="cov2" title="2">{
                *s.VWAP = append((*s.VWAP)[:index], (*s.VWAP)[index+1:]...)
        }</span>

        // If the N slice is not nil, remove the element at the index from the N slice
        <span class="cov2" title="2">if s.N != nil </span><span class="cov2" title="2">{
                *s.N = append((*s.N)[:index], (*s.N)[index+1:]...)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

func CombineStockCandles(s1, s2 *StockCandlesResponse) (*StockCandlesResponse, error) <span class="cov3" title="3">{
        // Check if versions are the same
        version1, err1 := s1.getVersion()
        if err1 != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting version from s1: %v", err1)
        }</span>
        <span class="cov3" title="3">version2, err2 := s2.getVersion()
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting version from s2: %v", err2)
        }</span>
        <span class="cov3" title="3">if version1 != version2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("versions do not match")
        }</span>

        // Check for time overlap using the DoesNotContain method
        <span class="cov2" title="2">s1DateRange, err1 := s1.GetDateRange()
        if err1 != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting date range from s1: %v", err1)
        }</span>
        <span class="cov2" title="2">s2DateRange, err2 := s2.GetDateRange()
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting date range from s2: %v", err2)
        }</span>
        <span class="cov2" title="2">if !s1DateRange.DoesNotContain(s2DateRange) &amp;&amp; !s2DateRange.DoesNotContain(s1DateRange) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("time ranges overlap: s1 range %s, s2 range %s", s1DateRange.String(), s2DateRange.String())
        }</span>

        // Combine the structs
        <span class="cov1" title="1">combined := &amp;StockCandlesResponse{
                Time:   append(s1.Time, s2.Time...),
                Open:   append(s1.Open, s2.Open...),
                High:   append(s1.High, s2.High...),
                Low:    append(s1.Low, s2.Low...),
                Close:  append(s1.Close, s2.Close...),
                Volume: append(s1.Volume, s2.Volume...),
        }

        if version1 == 2 &amp;&amp; version2 == 2 </span><span class="cov0" title="0">{
                combinedVWAP := append(*s1.VWAP, *s2.VWAP...)
                combinedN := append(*s1.N, *s2.N...)
                combined.VWAP = &amp;combinedVWAP
                combined.N = &amp;combinedN
        }</span>

        // Validate the combined struct
        <span class="cov1" title="1">if err := combined.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("combineStockCandles validation failed: %v", err)
        }</span>

        // Dereference the old structs to free memory
        <span class="cov1" title="1">s1 = nil
        s2 = nil

        return combined, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"
)

type StockEarningsResponse struct {
        Symbol         []string   `json:"symbol"`
        FiscalYear     []int64    `json:"fiscalYear"`
        FiscalQuarter  []int64    `json:"fiscalQuarter"`
        Date           []int64    `json:"date"`
        ReportDate     []int64    `json:"reportDate"`
        ReportTime     []string   `json:"reportTime"`
        Currency       []string   `json:"currency"`
        ReportedEPS    []*float64 `json:"reportedEPS"`
        EstimatedEPS   []*float64 `json:"estimatedEPS"`
        SurpriseEPS    []*float64 `json:"surpriseEPS"`
        SurpriseEPSpct []*float64 `json:"surpriseEPSpct"`
        Updated        []int64    `json:"updated"`
}

type StockEarningsReport struct {
        Symbol         string
        FiscalYear     int64
        FiscalQuarter  int64
        Date           time.Time
        ReportDate     time.Time
        ReportTime     string
        Currency       string
        ReportedEPS    *float64
        EstimatedEPS   *float64
        SurpriseEPS    *float64
        SurpriseEPSpct *float64
        Updated        time.Time
}

func (ser StockEarningsReport) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")

        reportedEPS := "nil"
        if ser.ReportedEPS != nil </span><span class="cov0" title="0">{
                reportedEPS = fmt.Sprintf("%f", *ser.ReportedEPS)
        }</span>

        <span class="cov0" title="0">estimatedEPS := "nil"
        if ser.EstimatedEPS != nil </span><span class="cov0" title="0">{
                estimatedEPS = fmt.Sprintf("%f", *ser.EstimatedEPS)
        }</span>

        <span class="cov0" title="0">surpriseEPS := "nil"
        if ser.SurpriseEPS != nil </span><span class="cov0" title="0">{
                surpriseEPS = fmt.Sprintf("%f", *ser.SurpriseEPS)
        }</span>

        <span class="cov0" title="0">surpriseEPSpct := "nil"
        if ser.SurpriseEPSpct != nil </span><span class="cov0" title="0">{
                surpriseEPSpct = fmt.Sprintf("%f", *ser.SurpriseEPSpct)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Symbol: %s, Fiscal Year: %v, Fiscal Quarter: %v, Date: %v, Report Date: %v, Report Time: %v, Currency: %v, Reported EPS: %v, Estimated EPS: %v, Surprise EPS: %v, Surprise EPS Pct: %v, Updated: %s",
                ser.Symbol, ser.FiscalYear, ser.FiscalQuarter, ser.Date.Format("2006-01-02"), ser.ReportDate.Format("2006-01-02"), ser.ReportTime, ser.Currency, reportedEPS, estimatedEPS, surpriseEPS, surpriseEPSpct, ser.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"))</span>
}

func (ser *StockEarningsResponse) Unpack() ([]StockEarningsReport, error) <span class="cov0" title="0">{
        var stockEarningsReports []StockEarningsReport
        for i := range ser.Symbol </span><span class="cov0" title="0">{
                stockEarningsReport := StockEarningsReport{
                        Symbol:         ser.Symbol[i],
                        FiscalYear:     ser.FiscalYear[i],
                        FiscalQuarter:  ser.FiscalQuarter[i],
                        Date:           time.Unix(ser.Date[i], 0),
                        ReportDate:     time.Unix(ser.ReportDate[i], 0),
                        ReportTime:     ser.ReportTime[i],
                        Currency:       ser.Currency[i],
                        ReportedEPS:    ser.ReportedEPS[i],
                        EstimatedEPS:   ser.EstimatedEPS[i],
                        SurpriseEPS:    ser.SurpriseEPS[i],
                        SurpriseEPSpct: ser.SurpriseEPSpct[i],
                        Updated:        time.Unix(ser.Updated[i], 0),
                }
                stockEarningsReports = append(stockEarningsReports, stockEarningsReport)
        }</span>
        <span class="cov0" title="0">return stockEarningsReports, nil</span>
}

func (ser *StockEarningsResponse) String() string <span class="cov0" title="0">{
        var result strings.Builder

        fmt.Fprintf(&amp;result, "Symbol: %v, Fiscal Year: %v, Fiscal Quarter: %v, Date: %v, Report Date: %v, Report Time: %v, Currency: %v, ",
                ser.Symbol, ser.FiscalYear, ser.FiscalQuarter, ser.Date, ser.ReportDate, ser.ReportTime, ser.Currency)

        fmt.Fprintf(&amp;result, "Reported EPS: [")
        for _, v := range ser.ReportedEPS </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;result, "%f ", *v)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(&amp;result, "nil ")
                }</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(&amp;result, "], ")

        fmt.Fprintf(&amp;result, "Estimated EPS: [")
        for _, v := range ser.EstimatedEPS </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;result, "%f ", *v)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(&amp;result, "nil ")
                }</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(&amp;result, "], ")

        fmt.Fprintf(&amp;result, "Surprise EPS: [")
        for _, v := range ser.SurpriseEPS </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;result, "%f ", *v)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(&amp;result, "nil ")
                }</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(&amp;result, "], ")

        fmt.Fprintf(&amp;result, "Surprise EPS Pct: [")
        for _, v := range ser.SurpriseEPSpct </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;result, "%f ", *v)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(&amp;result, "nil ")
                }</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(&amp;result, "], ")

        fmt.Fprintf(&amp;result, "Updated: %v", ser.Updated)

        return result.String()</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"
)

type StockNewsResponse struct {
        Symbol          []string `json:"symbol"`
        Headline        []string `json:"headline"`
        Content         []string `json:"content"`
        Source          []string `json:"source"`
        PublicationDate []int64  `json:"publicationDate"`
        Updated         int64    `json:"updated"`
}

type StockNews struct {
        Symbol          string
        Headline        string
        Content         string
        Source          string
        PublicationDate time.Time
}

func (sn StockNews) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        return fmt.Sprintf("Symbol: %s, Headline: %s, Content: %s, Source: %s, PublicationDate: %s",
                sn.Symbol, sn.Headline, sn.Content, sn.Source, sn.PublicationDate.In(loc).Format("2006-01-02 15:04:05 Z07:00"))
}</span>

func (snr *StockNewsResponse) Unpack() ([]StockNews, error) <span class="cov0" title="0">{
        var stockNews []StockNews
        for i := range snr.Symbol </span><span class="cov0" title="0">{
                news := StockNews{
                        Symbol:          snr.Symbol[i],
                        Headline:        snr.Headline[i],
                        Content:         snr.Content[i],
                        Source:          snr.Source[i],
                        PublicationDate: time.Unix(snr.PublicationDate[i], 0),
                }
                stockNews = append(stockNews, news)
        }</span>
        <span class="cov0" title="0">return stockNews, nil</span>
}

func (snr *StockNewsResponse) String() string <span class="cov0" title="0">{
        var result strings.Builder

        for i := range snr.Symbol </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, "Symbol: %s, Headline: %s, Content: %s, Source: %s, Publication Date: %v",
                        snr.Symbol[i], snr.Headline[i], snr.Content[i], snr.Source[i], snr.PublicationDate[i])

                if i &lt; len(snr.Symbol)-1 </span><span class="cov0" title="0">{
                        result.WriteString("; ")
                }</span>
        }

        <span class="cov0" title="0">if snr.Updated != 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", Updated: %v", snr.Updated)
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package models

import (
        "fmt"
        "strings"
        "time"
)

type StockQuotesResponse struct {
        Symbol    []string   `json:"symbol"`
        Ask       []float64  `json:"ask"`
        AskSize   []int64    `json:"askSize"`
        Bid       []float64  `json:"bid"`
        BidSize   []int64    `json:"bidSize"`
        Mid       []float64  `json:"mid"`
        Last      []float64  `json:"last"`
        Change    []*float64 `json:"change,omitempty"`
        ChangePct []*float64 `json:"changepct,omitempty"`
        High52    *[]float64 `json:"52weekHigh,omitempty"`
        Low52     *[]float64 `json:"52weekLow,omitempty"`
        Volume    []int64    `json:"volume"`
        Updated   []int64    `json:"updated"`
}

type StockQuote struct {
        Symbol    string
        Ask       float64
        AskSize   int64
        Bid       float64
        BidSize   int64
        Mid       float64
        Last      float64
        Change    *float64
        ChangePct *float64
        High52    *float64
        Low52     *float64
        Volume    int64
        Updated   time.Time
}

func (sq StockQuote) String() string <span class="cov0" title="0">{
        loc, _ := time.LoadLocation("America/New_York")
        if sq.High52 != nil &amp;&amp; sq.Low52 != nil &amp;&amp; sq.Change != nil &amp;&amp; sq.ChangePct != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Ask: %v, AskSize: %v, Bid: %v, BidSize: %v, Mid: %v, Last: %v, Volume: %v, Updated: %s, High52: %v, Low52: %v, Change: %v, ChangePct: %v",
                        sq.Symbol, sq.Ask, sq.AskSize, sq.Bid, sq.BidSize, sq.Mid, sq.Last, sq.Volume, sq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *sq.High52, *sq.Low52, *sq.Change, *sq.ChangePct)
        }</span> else<span class="cov0" title="0"> if sq.High52 != nil &amp;&amp; sq.Low52 != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Ask: %v, AskSize: %v, Bid: %v, BidSize: %v, Mid: %v, Last: %v, Volume: %v, Updated: %s, High52: %v, Low52: %v",
                        sq.Symbol, sq.Ask, sq.AskSize, sq.Bid, sq.BidSize, sq.Mid, sq.Last, sq.Volume, sq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *sq.High52, *sq.Low52)
        }</span> else<span class="cov0" title="0"> if sq.Change != nil &amp;&amp; sq.ChangePct != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Symbol: %s, Ask: %v, AskSize: %v, Bid: %v, BidSize: %v, Mid: %v, Last: %v, Volume: %v, Updated: %s, Change: %v, ChangePct: %v",
                        sq.Symbol, sq.Ask, sq.AskSize, sq.Bid, sq.BidSize, sq.Mid, sq.Last, sq.Volume, sq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"), *sq.Change, *sq.ChangePct)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("Symbol: %s, Ask: %v, AskSize: %v, Bid: %v, BidSize: %v, Mid: %v, Last: %v, Volume: %v, Updated: %s",
                        sq.Symbol, sq.Ask, sq.AskSize, sq.Bid, sq.BidSize, sq.Mid, sq.Last, sq.Volume, sq.Updated.In(loc).Format("2006-01-02 15:04:05 Z07:00"))
        }</span>
}

func (sqr *StockQuotesResponse) Unpack() ([]StockQuote, error) <span class="cov0" title="0">{
        var stockQuotes []StockQuote
        for i := range sqr.Symbol </span><span class="cov0" title="0">{
                stockQuote := StockQuote{
                        Symbol:  sqr.Symbol[i],
                        Ask:     sqr.Ask[i],
                        AskSize: sqr.AskSize[i],
                        Bid:     sqr.Bid[i],
                        BidSize: sqr.BidSize[i],
                        Mid:     sqr.Mid[i],
                        Last:    sqr.Last[i],
                        Volume:  sqr.Volume[i],
                        Updated: time.Unix(sqr.Updated[i], 0),
                }
                if sqr.Change != nil &amp;&amp; len(sqr.Change) &gt; i </span><span class="cov0" title="0">{
                        stockQuote.Change = sqr.Change[i]
                }</span>
                <span class="cov0" title="0">if sqr.ChangePct != nil &amp;&amp; len(sqr.ChangePct) &gt; i </span><span class="cov0" title="0">{
                        stockQuote.ChangePct = sqr.ChangePct[i]
                }</span>
                <span class="cov0" title="0">if sqr.High52 != nil &amp;&amp; len(*sqr.High52) &gt; i </span><span class="cov0" title="0">{
                        val := (*sqr.High52)[i]
                        stockQuote.High52 = &amp;val
                }</span>
                <span class="cov0" title="0">if sqr.Low52 != nil &amp;&amp; len(*sqr.Low52) &gt; i </span><span class="cov0" title="0">{
                        val := (*sqr.Low52)[i]
                        stockQuote.Low52 = &amp;val
                }</span>
                <span class="cov0" title="0">stockQuotes = append(stockQuotes, stockQuote)</span>
        }
        <span class="cov0" title="0">return stockQuotes, nil</span>
}

func (sqr *StockQuotesResponse) String() string <span class="cov0" title="0">{
        var result strings.Builder

        fmt.Fprintf(&amp;result, "Symbol: %v, Ask: %v, Ask Size: %v, Bid: %v, Bid Size: %v, Mid: %v, Last: %v", 
                sqr.Symbol, sqr.Ask, sqr.AskSize, sqr.Bid, sqr.BidSize, sqr.Mid, sqr.Last)

        if sqr.Change != nil &amp;&amp; len(sqr.Change) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", Change: %v", sqr.Change[0])
        }</span>
        <span class="cov0" title="0">if sqr.ChangePct != nil &amp;&amp; len(sqr.ChangePct) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", ChangePct: %v", sqr.ChangePct[0])
        }</span>
        <span class="cov0" title="0">if sqr.High52 != nil &amp;&amp; len(*sqr.High52) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", High52: %v", *sqr.High52)
        }</span>
        <span class="cov0" title="0">if sqr.Low52 != nil &amp;&amp; len(*sqr.Low52) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;result, ", Low52: %v", *sqr.Low52)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(&amp;result, ", Volume: %v, Updated: %v", sqr.Volume, sqr.Updated)

        return result.String()</span>
}</pre>
		
		<pre class="file" id="file55" style="display: none">package models

import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/iancoleman/orderedmap"
)

// TickersResponse represents the response from the /stocks/tickers endpoint.
type TickersResponse struct {
        Symbol        []string `json:"symbol"`
        Name          []string `json:"name,omitempty"`
        Type          []string `json:"type,omitempty"`
        Currency      []string `json:"currency,omitempty"`
        Exchange      []string `json:"exchange,omitempty"`
        FigiShares    []string `json:"figiShares,omitempty"`
        FigiComposite []string `json:"figiComposite,omitempty"`
        Cik           []string `json:"cik,omitempty"`
        Updated       *[]int64 `json:"updated,omitempty"`
}

// IsValid checks if the TickersResponse is valid.
func (tr *TickersResponse) IsValid() bool <span class="cov0" title="0">{
        return len(tr.Symbol) &gt; 0
}</span>

// String returns a string representation of TickersResponse.
func (tr *TickersResponse) String() string <span class="cov0" title="0">{
        var str strings.Builder
        str.WriteString("TickersResponse{\n")
        for i := range tr.Symbol </span><span class="cov0" title="0">{
                str.WriteString(fmt.Sprintf("Symbol: %s, Name: %s, Type: %s, Currency: %s, Exchange: %s, FigiShares: %s, FigiComposite: %s, Cik: %s\n", tr.Symbol[i], tr.Name[i], tr.Type[i], tr.Currency[i], tr.Exchange[i], tr.FigiShares[i], tr.FigiComposite[i], tr.Cik[i]))
                if tr.Updated != nil &amp;&amp; i &lt; len(*tr.Updated) &amp;&amp; (*tr.Updated)[i] != 0 </span><span class="cov0" title="0">{
                        str.WriteString(fmt.Sprintf("Updated: %v\n", time.Unix((*tr.Updated)[i], 0)))
                }</span> else<span class="cov0" title="0"> {
                        str.WriteString("Updated: \n")
                }</span>
        }
        <span class="cov0" title="0">str.WriteString("}")
        return str.String()</span>
}

// Unpack converts TickersResponse to a slice of Ticker.
func (tr *TickersResponse) Unpack() ([]Ticker, error) <span class="cov1" title="1">{
        if tr == nil || tr.Updated == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TickersResponse or its Updated field is nil")
        }</span>
        <span class="cov1" title="1">var tickerInfos []Ticker
        for i := range tr.Symbol </span><span class="cov10" title="15025">{
                if i &gt;= len(tr.Name) || i &gt;= len(tr.Type) || i &gt;= len(tr.Currency) || i &gt;= len(tr.Exchange) || i &gt;= len(tr.FigiShares) || i &gt;= len(tr.FigiComposite) || i &gt;= len(tr.Cik) || (tr.Updated != nil &amp;&amp; i &gt;= len(*tr.Updated)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index out of range")
                }</span>
                <span class="cov10" title="15025">tickerInfo := Ticker{
                        Symbol:        tr.Symbol[i],
                        Name:          tr.Name[i],
                        Type:          tr.Type[i],
                        Currency:      tr.Currency[i],
                        Exchange:      tr.Exchange[i],
                        FigiShares:    tr.FigiShares[i],
                        FigiComposite: tr.FigiComposite[i],
                        Cik:           tr.Cik[i],
                }
                if tr.Updated != nil &amp;&amp; (*tr.Updated)[i] != 0 </span><span class="cov10" title="15025">{
                        t := time.Unix((*tr.Updated)[i], 0)
                        tickerInfo.Updated = &amp;t
                }</span>
                <span class="cov10" title="15025">tickerInfos = append(tickerInfos, tickerInfo)</span>
        }
        <span class="cov1" title="1">return tickerInfos, nil</span>
}

// UniqueSymbols extracts and returns a slice of unique stock symbols from the TickersResponse.
// It returns the slice of unique symbols and any error encountered during the conversion to a map.
func (tr *TickersResponse) UniqueSymbols() ([]string, error) <span class="cov0" title="0">{
        tickerMap, err := tr.ToMap()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">uniqueSymbols := make([]string, 0, len(tickerMap))
        for symbol := range tickerMap </span><span class="cov0" title="0">{
                uniqueSymbols = append(uniqueSymbols, symbol)
        }</span>

        <span class="cov0" title="0">return uniqueSymbols, nil</span>
}

// ToMap converts TickersResponse to a map with the symbol as the key.
func (tr *TickersResponse) ToMap() (map[string]Ticker, error) <span class="cov1" title="1">{
        tickerInfos, err := tr.Unpack()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">tickerMap := make(map[string]Ticker)
        for _, tickerInfo := range tickerInfos </span><span class="cov10" title="15025">{
                tickerMap[tickerInfo.Symbol] = tickerInfo
        }</span>
        <span class="cov1" title="1">return tickerMap, nil</span>
}

// MarshalJSON is a method on the TickersResponse struct.
func (tr *TickersResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if tr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TickersResponse is nil")
        }</span>
        // Create a new ordered map
        <span class="cov0" title="0">o := orderedmap.New()

        // Set the "s" key to "ok"
        o.Set("s", "ok")

        // Set the other keys to the corresponding slices in the struct
        o.Set("symbol", tr.Symbol)
        o.Set("name", tr.Name)
        o.Set("type", tr.Type)
        o.Set("currency", tr.Currency)
        o.Set("exchange", tr.Exchange)
        o.Set("figiShares", tr.FigiShares)
        o.Set("figiComposite", tr.FigiComposite)
        o.Set("cik", tr.Cik)
        o.Set("updated", tr.Updated)

        // Marshal the ordered map into a JSON object and return the result
        return json.Marshal(o)</span>
}

// Ticker represents the information of a ticker.
type Ticker struct {
        Symbol        string
        Name          string
        Type          string
        Currency      string
        Exchange      string
        FigiShares    string
        FigiComposite string
        Cik           string
        Updated       *time.Time
}

// String returns a string representation of Ticker.
func (ti *Ticker) String() string <span class="cov0" title="0">{
        updated := ""
        if ti.Updated != nil </span><span class="cov0" title="0">{
                updated = ti.Updated.String()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Ticker{Symbol: %s, Name: %s, Type: %s, Currency: %s, Exchange: %s, FigiShares: %s, FigiComposite: %s, Cik: %s, Updated: %s}", ti.Symbol, ti.Name, ti.Type, ti.Currency, ti.Exchange, ti.FigiShares, ti.FigiComposite, ti.Cik, updated)</span>
}

// MapToTickersResponse converts a map of Ticker to a TickersResponse.
func MapToTickersResponse(tickerMap map[string]Ticker) *TickersResponse <span class="cov0" title="0">{
        var tr TickersResponse
        tr.Updated = new([]int64) // Initialize tr.Updated
        keys := make([]string, 0, len(tickerMap))
        for key := range tickerMap </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        for _, key := range keys </span><span class="cov0" title="0">{
                tickerInfo := tickerMap[key]
                tr.Symbol = append(tr.Symbol, tickerInfo.Symbol)
                tr.Name = append(tr.Name, tickerInfo.Name)
                tr.Type = append(tr.Type, tickerInfo.Type)
                tr.Currency = append(tr.Currency, tickerInfo.Currency)
                tr.Exchange = append(tr.Exchange, tickerInfo.Exchange)
                tr.FigiShares = append(tr.FigiShares, tickerInfo.FigiShares)
                tr.FigiComposite = append(tr.FigiComposite, tickerInfo.FigiComposite)
                tr.Cik = append(tr.Cik, tickerInfo.Cik)
                if tickerInfo.Updated != nil </span><span class="cov0" title="0">{
                        *tr.Updated = append(*tr.Updated, tickerInfo.Updated.Unix())
                }</span> else<span class="cov0" title="0"> {
                        *tr.Updated = append(*tr.Updated, 0)
                }</span>
        }
        <span class="cov0" title="0">return &amp;tr</span>
}

// SaveToCSV saves the ticker map to a CSV file.
func SaveToCSV(tickerMap map[string]Ticker, filename string) error <span class="cov1" title="1">{
        if tickerMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tickerMap is nil")
        }</span>
        <span class="cov1" title="1">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        writer := csv.NewWriter(file)
        defer writer.Flush()

        // Write header
        err = writer.Write([]string{"Symbol", "Name", "Type", "Currency", "Exchange", "FigiShares", "FigiComposite", "Cik", "Updated"})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write data
        <span class="cov1" title="1">for _, tickerInfo := range tickerMap </span><span class="cov10" title="15025">{
                updated := ""
                if tickerInfo.Updated != nil </span><span class="cov10" title="15025">{
                        updated = tickerInfo.Updated.String()
                }</span>
                <span class="cov10" title="15025">err = writer.Write([]string{tickerInfo.Symbol, tickerInfo.Name, tickerInfo.Type, tickerInfo.Currency, tickerInfo.Exchange, tickerInfo.FigiShares, tickerInfo.FigiComposite, tickerInfo.Cik, updated})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// CombineTickerResponses combines multiple TickersResponses into a single map.
func CombineTickerResponses(responses []*TickersResponse) (map[string]Ticker, error) <span class="cov0" title="0">{
        tickerMap := make(map[string]Ticker)
        var mutex sync.Mutex

        var wg sync.WaitGroup
        errors := make(chan error)

        for _, response := range responses </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(response *TickersResponse) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        responseMap, err := response.ToMap()
                        if err != nil </span><span class="cov0" title="0">{
                                errors &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">mutex.Lock()
                        for key, value := range responseMap </span><span class="cov0" title="0">{
                                tickerMap[key] = value
                        }</span>
                        <span class="cov0" title="0">mutex.Unlock()</span>
                }(response)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errors)
        }</span>()

        <span class="cov0" title="0">for err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return tickerMap, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
