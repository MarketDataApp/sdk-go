package models

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/iancoleman/orderedmap"
)

// IndicesCandlesResponse represents the response structure for indices candles data.
// It includes slices for time, open, high, low, and close values of the indices.
//
// # Generated By
//
//   - IndexCandlesRequest.Packed(): This method sends the IndicesCandlesRequest to the Market Data API and returns the IndicesCandlesResponse. It handles the actual communication with the [/v1/indices/candles/] endpoint, sending the request, and returns a packed response that strictly conforms to the Market Data JSON response without unpacking the result into individual candle structs.
//
// # Methods
//
//   - String(): Provides a formatted string representation of the IndicesCandlesResponse instance. This method is primarily used for logging or debugging purposes, allowing the user to easily view the contents of an IndicesCandlesResponse object in a human-readable format. It concatenates the time, open, high, low, and close values of the indices into a single string.
//   - Unpack() ([]Candle, error): Unpacks the IndicesCandlesResponse into a slice of Candle structs, checking for errors in data consistency.
//   - MarshalJSON(): Marshals the IndicesCandlesResponse into a JSON object with ordered keys.
//   - UnmarshalJSON(data []byte): Custom unmarshals a JSON object into the IndicesCandlesResponse, including validation.
//   - Validate(): Runs checks for time in ascending order, equal slice lengths, and no empty slices.
//   - IsValid(): Checks if the IndicesCandlesResponse passes all validation checks and returns a boolean.
type IndicesCandlesResponse struct {
	Date  []int64   `json:"t"` // Date holds the Unix timestamps for each candle, representing the time at which each candle was opened.
	Open  []float64 `json:"o"` // Open contains the opening prices for each candle in the response.
	High  []float64 `json:"h"` // High includes the highest prices reached during the time period each candle represents.
	Low   []float64 `json:"l"` // Low encompasses the lowest prices during the candle's time period.
	Close []float64 `json:"c"` // Close contains the closing prices for each candle, marking the final price at the end of each candle's time period.
}

// String provides a formatted string representation of the IndicesCandlesResponse instance.
// This method is primarily used for logging or debugging purposes, allowing the user to easily
// view the contents of an IndicesCandlesResponse object in a human-readable format. It concatenates
// the time, open, high, low, and close values of the indices into a single string.
//
// # Returns
//
//   - string: A formatted string containing the time, open, high, low, and close values of the indices.
func (icr *IndicesCandlesResponse) String() string {
	return fmt.Sprintf("IndicesCandlesResponse{Time: %v, Open: %v, High: %v, Low: %v, Close: %v}",
		icr.Date, icr.Open, icr.High, icr.Low, icr.Close)
}

// checkTimeInAscendingOrder checks if the times in the IndicesCandlesResponse are in ascending order.
//
// # Returns
//
//   - An error if the times are not in ascending order, nil otherwise.
func (icr *IndicesCandlesResponse) checkTimeInAscendingOrder() error {
	for i := 1; i < len(icr.Date); i++ {
		if icr.Date[i] < icr.Date[i-1] {
			return fmt.Errorf("time is not in ascending order")
		}
	}
	return nil
}

// checkForEqualSlices checks if all slices in the IndicesCandlesResponse struct have the same length.
// It returns an error if the lengths are not equal.
//
// # Returns
//
//   - An error if the lengths are not equal.
func (icr *IndicesCandlesResponse) checkForEqualSlices() error {
	// Create a slice of the lengths of the Time, Open, High, Low, and Close slices
	lengths := []int{
		len(icr.Date),
		len(icr.Open),
		len(icr.High),
		len(icr.Low),
		len(icr.Close),
	}

	// Check if all lengths in the lengths slice are equal
	// If they are not, return an error
	for i := 1; i < len(lengths); i++ {
		if lengths[i] != lengths[0] {
			return fmt.Errorf("arrays are not of the same length")
		}
	}

	// If all lengths are equal, return nil
	return nil
}

// checkForEmptySlices checks if any of the slices in the IndicesCandlesResponse are empty.
//
// # Returns
//
//   - An error if one or more slices are empty, nil otherwise.
func (icr *IndicesCandlesResponse) checkForEmptySlices() error {
	// Check if any of the slices are empty
	if len(icr.Date) == 0 || len(icr.Open) == 0 || len(icr.High) == 0 || len(icr.Low) == 0 || len(icr.Close) == 0 {
		return fmt.Errorf("one or more slices are empty")
	}

	// If none of the slices are empty, return nil
	return nil
}

// Unpack converts the IndicesCandlesResponse into a slice of IndexCandle.
//
// # Returns
//
//   - []Candle: A slice of [Candle] that holds the OHLC data.
//   - error: An error object that indicates a failure in unpacking the response.
func (icr *IndicesCandlesResponse) Unpack() ([]Candle, error) {
	if err := icr.checkForEqualSlices(); err != nil {
		return nil, err
	}

	var indexCandles []Candle
	for i := range icr.Date {
		indexCandle := Candle{
			Date:  time.Unix(icr.Date[i], 0),
			Open:  icr.Open[i],
			High:  icr.High[i],
			Low:   icr.Low[i],
			Close: icr.Close[i],
		}
		indexCandles = append(indexCandles, indexCandle)
	}
	return indexCandles, nil
}

// MarshalJSON marshals the IndicesCandlesResponse struct into a JSON object, ensuring the keys are ordered as specified.
// This method is particularly useful when a consistent JSON structure with ordered keys is required for external interfaces or storage.
// The "s" key is set to "ok" to indicate successful marshaling, followed by the indices data keys "t", "o", "h", "l", and "c".
//
// # Returns
//
//   - []byte: A byte slice representing the marshaled JSON object. The keys within the JSON object are ordered as "s", "t", "o", "h", "l", and "c".
//   - error: An error object if marshaling fails, otherwise nil.
func (icr *IndicesCandlesResponse) MarshalJSON() ([]byte, error) {
	// Create a new ordered map
	o := orderedmap.New()

	// Set the "s" key to "ok"
	o.Set("s", "ok")

	// Set the "t", "o", "h", "l", and "c" keys to the corresponding slices in the struct
	o.Set("t", icr.Date)
	o.Set("o", icr.Open)
	o.Set("h", icr.High)
	o.Set("l", icr.Low)
	o.Set("c", icr.Close)

	// Marshal the ordered map into a JSON object and return the result
	return json.Marshal(o)
}

// UnmarshalJSON custom unmarshals a JSON object into the IndicesCandlesResponse, incorporating validation to ensure the data integrity of the unmarshaled object. This method is essential for converting JSON data into a structured IndicesCandlesResponse object while ensuring that the data adheres to expected formats and constraints.
//
// # Parameters
//
//   - []byte: A byte slice of the JSON object to be unmarshaled.
//
// # Returns
//
//   - error: An error if unmarshaling or validation fails, otherwise nil.
func (icr *IndicesCandlesResponse) UnmarshalJSON(data []byte) error {
	// Define a secondary type to prevent infinite recursion
	type Alias IndicesCandlesResponse
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(icr),
	}

	// Unmarshal the data into our auxiliary struct
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	// Call the Validate method
	if err := icr.Validate(); err != nil {
		// Print the contents of the auxiliary struct only if validation fails
		fmt.Println(icr.String())
		return err
	}

	// Return nil if everything went well
	return nil
}

// Validate performs multiple checks on the IndicesCandlesResponse to ensure data integrity. This method is crucial for verifying that the response data is consistent and reliable, specifically checking for time sequence, equal length of data slices, and the presence of data in each slice. It's used to preemptively catch and handle data-related errors before they can affect downstream processes.
//
// # Returns
//
//   - error: An error if any validation check fails, otherwise nil. This allows for easy identification of data integrity issues.
func (icr *IndicesCandlesResponse) Validate() error {
	// Create a channel to handle errors
	errChan := make(chan error, 3)

	// Run each validation function concurrently
	go func() { errChan <- icr.checkTimeInAscendingOrder() }()
	go func() { errChan <- icr.checkForEqualSlices() }()
	go func() { errChan <- icr.checkForEmptySlices() }()

	// Wait for all validation functions to finish
	for i := 0; i < 3; i++ {
		if err := <-errChan; err != nil {
			return err
		}
	}

	// Return nil if there were no errors
	return nil
}

// IsValid determines the validity of the IndicesCandlesResponse based on various validation checks.
// This method is primarily used to quickly assess if the response data adheres to expected formats and constraints,
// making it a crucial step before further processing of the response data.

// # Returns
//
//   - bool: Indicates whether the IndicesCandlesResponse is valid.
func (icr *IndicesCandlesResponse) IsValid() bool {
	if err := icr.Validate(); err != nil {
		return false
	}
	return true
}
