package models

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/MarketDataApp/sdk-go/helpers/dates"
	"github.com/iancoleman/orderedmap"
)

/*

Example API Response JSON:
{
	"s":"ok",
  	"updated":1706791474,
	"2024-02-02":[50.0,60.0,65.0,70.0,75.0,80.0,85.0,90.0,95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,152.5,155.0,157.5,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0],
	"2024-02-09":[95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0],
	"2024-02-16":[50.0,55.0,60.0,65.0,70.0,75.0,80.0,85.0,90.0,95.0,100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,162.5,165.0,167.5,170.0,172.5,175.0,177.5,180.0,182.5,185.0,187.5,190.0,192.5,195.0,197.5,200.0,202.5,205.0,207.5,210.0,212.5,215.0,217.5,220.0,222.5,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0,270.0,275.0,280.0,285.0,290.0,295.0,300.0,305.0,310.0,315.0,320.0],
	"2024-02-23":[100.0,105.0,110.0,115.0,120.0,125.0,130.0,135.0,140.0,145.0,150.0,155.0,160.0,165.0,170.0,175.0,180.0,185.0,190.0,195.0,200.0,205.0,210.0,215.0,220.0,225.0,230.0,235.0,240.0,245.0,250.0,255.0,260.0,265.0]
}

*/

// OptionsStrikes encapsulates the expiration date and available strike prices for an option contract.
//
// # Generated By
//
//   - OptionsStrikesResponse.Unpack(): Converts an ordered map of strikes into a slice of OptionsStrikes.
//
// # Methods
//
//   - String() string: Returns a string representation of the OptionsStrikes, detailing its expiration and formatted strike prices.
//
// # Notes
//
//   - This struct is primarily used to represent the structured data of option strikes and their expiration dates after unpacking from a JSON response.
type OptionsStrikes struct {
	Expiration time.Time // Expiration is the date and time when the option expires.
	Strikes    []float64 // Strikes is a slice of strike prices available for the option.
}

// OptionsStrikesResponse encapsulates the response structure for a request to retrieve option strikes, including the last update timestamp and a map of strikes organized by expiration date. The map uses ordered keys to maintain the chronological order of expiration dates.
//
// # Generated By
//
//   - OptionsStrikesRequest.Packed(): Makes the OptionsStrikesRequest and unmarshals JSON data into the OptionsStrikesResponse struct.
//
// # Methods
//
//   - UnmarshalJSON(data []byte) error: Custom unmarshals JSON data, initializing the Strikes map with ordered expiration dates and their corresponding strike prices.
//   - IsValid() bool: Checks if the OptionsStrikesResponse contains valid data.
//   - Validate() error: Validates the integrity of the OptionsStrikesResponse, ensuring it contains valid strikes data.
//   - String() string: Returns a string representation of the OptionsStrikesResponse, detailing strikes and their prices.
//   - Unpack() ([]OptionsStrikes, error): Converts the ordered map of strikes into a slice of OptionsStrikes, each representing a set of strikes and their corresponding expiration date.
//
// # Notes
//
//   - The Strikes field is represented as an ordered map to maintain the order of dates, which is crucial.
//   - The Updated field uses a UNIX timestamp to indicate the last time the data was updated.
type OptionsStrikesResponse struct {
	Updated int                    `json:"updated"` // Updated is a UNIX timestamp indicating when the data was last updated.
	Strikes *orderedmap.OrderedMap `json:"-"`       // Strikes is a map where each key is a date string and the value is a slice of strike prices for that date.
}

// UnmarshalJSON custom unmarshals the JSON data into the OptionsStrikesResponse struct.
//
// # Parameters
//
//   - data []byte: The JSON data to be unmarshaled.
//
// # Returns
//
//   - error: An error if unmarshaling fails, nil otherwise.
func (osr *OptionsStrikesResponse) UnmarshalJSON(data []byte) error {
	var aux map[string]interface{}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	// Initialize the OrderedMap
	osr.Strikes = orderedmap.New()

	// Extract and sort the keys (excluding "updated" and "s")
	var keys []string
	for key := range aux {
		if key != "updated" && key != "s" {
			keys = append(keys, key)
		}
	}
	sort.Strings(keys) // Sorts the keys alphabetically, which works well for ISO 8601 dates

	// Iterate over the sorted keys and add them to the OrderedMap
	for _, key := range keys {
		values, ok := aux[key].([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type for key %s", key)
		}
		floats := make([]float64, len(values))
		for i, v := range values {
			floatVal, ok := v.(float64)
			if !ok {
				return fmt.Errorf("unexpected type for value in key %s", key)
			}
			floats[i] = floatVal
		}
		osr.Strikes.Set(key, floats)
	}

	// Handle the "updated" key separately
	if updated, ok := aux["updated"].(float64); ok {
		osr.Updated = int(updated)
	} else {
		return fmt.Errorf("unexpected type or missing 'updated' key")
	}

	return nil
}

// String provides a human-readable representation of the OptionsStrikes struct, including its expiration and strike prices. This method is primarily used for logging, debugging, or displaying the OptionsStrikes in a format that is easy to read and understand.
//
// # Returns
//
//   - string: A formatted string encapsulating the details of the OptionsStrikes, particularly its expiration and formatted strike prices.
//
// # Notes
//
//   - This method formats strike prices to two decimal places and joins them with a space for readability.
func (os OptionsStrikes) String() string {
	// Convert each strike price to a string with two decimal places
	var strikesStrParts []string
	for _, strike := range os.Strikes {
		strikesStrParts = append(strikesStrParts, fmt.Sprintf("%.2f", strike))
	}
	// Join the formatted strike prices with a space
	strikesStr := strings.Join(strikesStrParts, " ")

	return fmt.Sprintf("OptionsStrikes{Expiration: %s, Strikes: [%s]}", dates.TimeString(os.Expiration), strikesStr)
}

// IsValid determines the validity of the OptionsStrikesResponse object by invoking the Validate method. This method is primarily used to quickly assess whether the response received from an options strikes request adheres to the expected structure and contains valid data. It simplifies error handling by providing a boolean indicator of validity, which can be particularly useful in conditional logic where a binary valid/invalid decision is required.
//
// # Returns
//
//   - bool: Indicates whether the OptionsStrikesResponse is valid. A return value of true signifies a valid response, while false indicates an invalid response.
//
// # Notes
//
//   - This method is a convenience wrapper around the Validate method, offering a simplified interface for validity checking.
func (osr *OptionsStrikesResponse) IsValid() bool {
	return osr.Validate() == nil
}

// Validate assesses the integrity of the OptionsStrikesResponse object. It is primarily used to ensure that the response received from an options strikes request contains valid and expected data, such as non-empty strikes data. This method is crucial for error handling and data validation in financial market data applications, preventing the further processing of invalid responses.
//
// # Returns
//
//   - error: An error indicating that the OptionsStrikesResponse is invalid, typically due to missing strikes data, or nil if the response is valid.
//
// # Notes
//
//   - This method is a fundamental part of the data validation process, ensuring that only responses with valid strikes data are processed.
func (osr *OptionsStrikesResponse) Validate() error {
	if len(osr.Strikes.Keys()) == 0 {
		return fmt.Errorf("invalid OptionsStrikesResponse: no strikes data")
	}
	return nil
}

// String returns a string representation of the OptionsStrikesResponse struct, encapsulating the details of strikes and their corresponding prices in a human-readable format. This method is primarily used for logging, debugging, or any scenario where a textual representation of the OptionsStrikesResponse data is necessary for understanding or analysis.
//
// # Returns
//
//   - string: The string representation of the OptionsStrikesResponse, detailing the strikes and their prices.
//
// # Notes
//
//   - This method formats the strikes data into a string, making it easier to visualize the structure and content of the OptionsStrikesResponse.
func (osr *OptionsStrikesResponse) String() string {
	var sb strings.Builder
	sb.WriteString("OptionsStrikesResponse{Strikes: [")
	first := true
	for _, key := range osr.Strikes.Keys() {
		if !first {
			sb.WriteString(", ")
		}
		first = false
		value, _ := osr.Strikes.Get(key)
		strikes, _ := value.([]float64) // Assuming the type assertion is always successful.

		// Convert strike prices to strings and join them
		var strikeStrs []string
		for _, strike := range strikes {
			strikeStrs = append(strikeStrs, fmt.Sprintf("%.2f", strike))
		}
		strikesStr := strings.Join(strikeStrs, " ")

		sb.WriteString(fmt.Sprintf("%s:[%s]", key, strikesStr))
	}
	sb.WriteString(fmt.Sprintf("], Updated: %d}", osr.Updated))
	return sb.String()
}

// Unpack converts the ordered map of strikes contained within the OptionsStrikesResponse into a slice of OptionsStrikes. This method is primarily used when a user needs to work with a structured list of strikes and their expiration dates, rather than dealing with the map data structure. It simplifies the process of iterating over strikes and performing operations on them.
//
// # Returns
//
//   - []OptionsStrikes: A slice of OptionsStrikes, each representing a set of strikes and their corresponding expiration date.
//   - error: An error if the validation of the OptionsStrikesResponse fails or if there are issues parsing the dates.
//
// # Notes
//
//   - This method first validates the OptionsStrikesResponse to ensure it contains valid data before attempting to unpack the strikes.
func (osr *OptionsStrikesResponse) Unpack() ([]OptionsStrikes, error) {
	if err := osr.Validate(); err != nil {
		return nil, err
	}

	loc, err := time.LoadLocation("America/New_York")
	if err != nil {
		return nil, fmt.Errorf("error loading location: %v", err)
	}

	var unpackedStrikes []OptionsStrikes
	for _, key := range osr.Strikes.Keys() {
		value, _ := osr.Strikes.Get(key)
		strikes := value.([]float64)

		date, err := time.ParseInLocation("2006-01-02", key, loc)
		if err != nil {
			return nil, fmt.Errorf("error parsing date %s: %v", key, err)
		}

		unpackedStrikes = append(unpackedStrikes, OptionsStrikes{
			Expiration: date,
			Strikes:    strikes,
		})
	}
	return unpackedStrikes, nil
}
