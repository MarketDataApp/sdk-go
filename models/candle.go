package models

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/MarketDataApp/sdk-go/helpers/dates"
)

// Candle represents a single candle in a stock candlestick chart, encapsulating the time, open, high, low, close prices, 
// volume, and optionally the symbol, VWAP, and number of trades.
//
// # Generated By
//   
//   - StockCandlesResponse.Unpack(): Generates Candle instances from a StockCandlesResponse.
//   - BulkStockCandlesResponse.Unpack(): Generates Candle instances from a BulkStockStockCandlesResponse.
//   - IndicesCandlesResponse.Unpack(): Generates Candle instances from a IndicesCandlesResponse.
//
// # Methods
//   
//   - String() string: Provides a string representation of the Candle.
//   - Equals(other Candle) bool: Checks if two Candle instances are equal.
//   - MarshalJSON() ([]byte, error): Customizes the JSON output of Candle.
//   - UnmarshalJSON(data []byte) error: Customizes the JSON input processing of Candle.
//
// # Notes
//   
//   - The VWAP, N fields are optional and will only be present in v2 Stock Candles.
//   - The Volume field is optional and will not be present in Index Candles.
//   - The Symbol field is optional and only be present in candles that were generated using the bulkcandles endpoint.
type Candle struct {
	Symbol string    `json:"symbol,omitempty"` // The symbol of the candle.
	Date   time.Time `json:"t"`                // Date represents the date and time of the candle.
	Open   float64   `json:"o"`                // Open is the opening price of the candle.
	High   float64   `json:"h"`                // High is the highest price reached during the candle's time.
	Low    float64   `json:"l"`                // Low is the lowest price reached during the candle's time.
	Close  float64   `json:"c"`                // Close is the closing price of the candle.
	Volume int64     `json:"v,omitempty"`      // Volume represents the trading volume during the candle's time.
	VWAP   float64   `json:"vwap,omitempty"`   // VWAP is the Volume Weighted Average Price, optional.
	N      int64     `json:"n,omitempty"`      // N is the number of trades that occurred, optional.
}

// String provides a textual representation of the Candle instance. This method is primarily used for logging or debugging purposes, where a developer needs a quick and easy way to view the contents of a Candle instance in a human-readable format.
//
// # Returns
//
//   - string: A string that represents the Candle instance, including its symbol, date/time, open, high, low, close prices, volume, VWAP, and number of trades, if available.
//
// # Notes
//
//   - The output format is designed to be easily readable, with each field labeled and separated by commas.
//   - Fields that are not applicable or not set (e.g., VWAP, N, Volume for Index Candles) are omitted from the output.
func (c Candle) String() string {
	loc, _ := time.LoadLocation("America/New_York")
	var parts []string
	if c.Symbol != "" {
		parts = append(parts, fmt.Sprintf("Symbol: %s", c.Symbol))
	}
	// Use IsStartOfDay to determine if the candle time is at the start of the day
	if dates.IsStartOfDay(c.Date, loc) {
		datePart := c.Date.In(loc).Format("2006-01-02")
		parts = append(parts, fmt.Sprintf("Date: %s", datePart))
	} else {
		timePart := c.Date.In(loc).Format("2006-01-02 15:04:05 Z07:00")
		parts = append(parts, fmt.Sprintf("Time: %s", timePart))
	}
	parts = append(parts, fmt.Sprintf("Open: %v", c.Open))
	parts = append(parts, fmt.Sprintf("High: %v", c.High))
	parts = append(parts, fmt.Sprintf("Low: %v", c.Low))
	parts = append(parts, fmt.Sprintf("Close: %v", c.Close))
	if c.Volume != 0 {
		parts = append(parts, fmt.Sprintf("Volume: %v", c.Volume))
	}
	if c.VWAP != 0 {
		parts = append(parts, fmt.Sprintf("VWAP: %v", c.VWAP))
	}
	if c.N != 0 {
		parts = append(parts, fmt.Sprintf("N: %v", c.N))
	}
	return "Candle{" + strings.Join(parts, ", ") + "}"
}

// Equals compares the current Candle instance with another Candle instance to determine if they represent the same candle data. 
// This method is useful for validating if two Candle instances have identical properties, including symbol, date/time, open, 
// high, low, close prices, volume, VWAP, and number of trades. It's primarily used in scenarios where candle data integrity 
// needs to be verified or when deduplicating candle data.
//
// # Parameters
//
//   - Candle: The other Candle instance to compare against the current instance.
//
// # Returns
//
//   - bool: Indicates whether the two Candle instances are identical. True if all properties match, false otherwise.
//
// # Notes
//
//   - This method performs a deep equality check on all Candle properties, including date/time which is compared using the Equal method from the time package to account for potential timezone differences.
func (c Candle) Equals(other Candle) bool {
	return c.Symbol == other.Symbol &&
		c.Date.Equal(other.Date) &&
		c.Open == other.Open &&
		c.High == other.High &&
		c.Low == other.Low &&
		c.Close == other.Close &&
		c.Volume == other.Volume &&
		c.VWAP == other.VWAP &&
		c.N == other.N
}

// MarshalJSON customizes the JSON output of the Candle struct, primarily used for converting the Candle data into a JSON format that includes the Date as a Unix timestamp instead of the standard time.Time format. This method is particularly useful when the Candle data needs to be serialized into JSON for storage or transmission over networks where a compact and universally understood date format is preferred.
//
// # Returns
//
//   - []byte: The JSON-encoded representation of the Candle.
//   - error: An error if the JSON marshaling fails.
//
// # Notes
//
//   - The Date field of the Candle is converted to a Unix timestamp to facilitate easier handling of date and time in JSON.
func (c Candle) MarshalJSON() ([]byte, error) {
	// Define a struct that matches Candle but with Date as an integer (Unix timestamp).
	type Alias Candle
	return json.Marshal(&struct {
		Date int64 `json:"t"` // Convert Date to Unix timestamp.
		*Alias
	}{
		Date:  c.Date.Unix(), // Convert time.Time to Unix timestamp.
		Alias: (*Alias)(&c),
	})
}

// UnmarshalJSON customizes the JSON input processing of Candle.
//
// UnmarshalJSON customizes the JSON input processing for the Candle struct, allowing for the Date field to be correctly interpreted from a Unix timestamp (integer) back into a Go time.Time object. This method is essential for deserializing Candle data received in JSON format, where date and time are represented as Unix timestamps, ensuring the Candle struct accurately reflects the original data.
//
// # Parameters
//
//   - data []byte: The JSON-encoded data that is to be unmarshaled into the Candle struct.
//
// # Returns
//
//   - error: An error if the JSON unmarshaling fails, nil otherwise.
//
// # Notes
//
//   - The Date field in the JSON is expected to be a Unix timestamp (integer). This method converts it back to a time.Time object, ensuring the Candle struct's Date field is correctly populated.
func (c *Candle) UnmarshalJSON(data []byte) error {
	// Define a struct that matches Candle but with Date as an integer (Unix timestamp).
	type Alias Candle
	aux := &struct {
		Date int64 `json:"t"`
		*Alias
	}{
		Alias: (*Alias)(c),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	c.Date = time.Unix(aux.Date, 0) // Convert Unix timestamp back to time.Time.
	return nil
}

// ByDate implements sort.Interface for []Candle based on the Date field.
type ByDate []Candle

func (a ByDate) Len() int           { return len(a) }
func (a ByDate) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByDate) Less(i, j int) bool { return a[i].Date.Before(a[j].Date) }

// ByVolume implements sort.Interface for []Candle based on the Volume field.
type ByVolume []Candle

func (a ByVolume) Len() int           { return len(a) }
func (a ByVolume) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByVolume) Less(i, j int) bool { return a[i].Volume < a[j].Volume }

// ByOpen implements sort.Interface for []Candle based on the Open field.
type ByOpen []Candle

func (a ByOpen) Len() int           { return len(a) }
func (a ByOpen) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByOpen) Less(i, j int) bool { return a[i].Open < a[j].Open }

// ByHigh implements sort.Interface for []Candle based on the High field.
type ByHigh []Candle

func (a ByHigh) Len() int           { return len(a) }
func (a ByHigh) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByHigh) Less(i, j int) bool { return a[i].High < a[j].High }

// ByLow implements sort.Interface for []Candle based on the Low field.
type ByLow []Candle

func (a ByLow) Len() int           { return len(a) }
func (a ByLow) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByLow) Less(i, j int) bool { return a[i].Low < a[j].Low }

// ByClose implements sort.Interface for []Candle based on the Close field.
type ByClose []Candle

func (a ByClose) Len() int           { return len(a) }
func (a ByClose) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByClose) Less(i, j int) bool { return a[i].Close < a[j].Close }

// ByVWAP implements sort.Interface for []Candle based on the VWAP field.
type ByVWAP []Candle

func (a ByVWAP) Len() int           { return len(a) }
func (a ByVWAP) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByVWAP) Less(i, j int) bool { return a[i].VWAP < a[j].VWAP }

// ByN implements sort.Interface for []Candle based on the N field.
type ByN []Candle

func (a ByN) Len() int           { return len(a) }
func (a ByN) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByN) Less(i, j int) bool { return a[i].N < a[j].N }

// BySymbol implements sort.Interface for []Candle based on the Symbol field.
// Candles are sorted in ascending order.
type BySymbol []Candle

func (a BySymbol) Len() int           { return len(a) }
func (a BySymbol) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a BySymbol) Less(i, j int) bool { return a[i].Symbol < a[j].Symbol }

// Clones the current Candle instance, creating a new instance with the same values. This method is useful when you need a copy of a Candle instance without modifying the original instance.
//
// # Returns
//
//   - Candle: A new Candle instance with the same values as the current instance.
func (c Candle) Clone() Candle {
	return Candle{
		Symbol: c.Symbol,
		Date:   c.Date,
		Open:   c.Open,
		High:   c.High,
		Low:    c.Low,
		Close:  c.Close,
		Volume: c.Volume,
		VWAP:   c.VWAP,
		N:      c.N,
	}
}

// IsBefore determines whether the current Candle instance occurred before another specified Candle instance. 
// This method is primarily used for comparing the dates of two Candle instances to establish their chronological order, 
// which can be useful in time series analysis or when organizing historical financial data.
//
// # Parameters
//
//   - other Candle: The Candle instance to compare with the current Candle instance.
//
// # Returns
//
//   - bool: Returns true if the date of the current Candle instance is before the date of the 'other' Candle instance; otherwise, returns false.
//
// # Notes
//
//   - This method only compares the dates of the Candle instances, ignoring other fields such as Open, Close, High, Low, etc.
func (c Candle) IsBefore(other Candle) bool {
	return c.Date.Before(other.Date)
}

// IsAfter determines if the current Candle instance occurred after another specified Candle instance. This method is useful 
// for chronological comparisons between two Candle instances, particularly in time series analysis or when organizing historical 
// financial data in ascending order.
//
// # Parameters
//
//   - other Candle: The Candle instance to compare with the current Candle instance.
//
// # Returns
//
//   - bool: Indicates whether the current Candle's date is after the 'other' Candle's date. Returns true if it is; otherwise, false.
func (c Candle) IsAfter(other Candle) bool {
	return c.Date.After(other.Date)
}

// IsValid evaluates the financial data of a Candle to determine its validity. This method is essential for ensuring that 
// the Candle's data adheres to basic financial integrity rules, making it a critical step before performing further 
// analysis or operations with Candle data. A Candle is deemed valid if its high, open, and close prices are logically 
// consistent with each other and its volume is non-negative.
//
// # Returns
//
//   - bool: Indicates whether the Candle is valid based on its financial data. Returns true if all validity criteria are met; otherwise, false.
//
func (c Candle) IsValid() bool {
	return c.High >= c.Low && c.Open >= c.Low && c.Close >= c.Low && c.High >= c.Open && c.High >= c.Close && c.Volume >= 0
}
