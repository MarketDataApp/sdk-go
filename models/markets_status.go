package models

import (
	"fmt"
	"strings"
	"time"

	"github.com/MarketDataApp/sdk-go/helpers/dates"
)

// MarketStatusResponse encapsulates the response data for market status queries, including dates and optionally, the
// corresponding market statuses.
//
// # Generated By
//
//   - MarketStatusRequest.Get(): Generates a MarketStatusResponse containing market status information for requested dates.
//
// # Methods
//
//   - String(): Returns a string representation of the MarketStatusResponse.
type MarketStatusResponse struct {
	Date   []int64  `json:"date"`   // Date contains UNIX timestamps for each market status entry.
	Status []string `json:"status"` // Status is a pointer to a slice of market status strings, which can be omitted if empty.
}

// IsValid determines whether the MarketStatusResponse instance has at least one date entry.
// This method is primarily used to verify that the response is not empty, indicating that there is market status data available for processing.
//
// # Returns
//
//   - bool: Indicates whether there is at least one date entry in the MarketStatusResponse. True if at least one date is present, false otherwise.
func (msr *MarketStatusResponse) IsValid() bool {
	return len(msr.Date) > 0
}

// String provides a formatted string representation of the MarketStatusResponse instance. This method is primarily used for logging
// or debugging purposes, allowing the user to easily view the contents of a MarketStatusResponse object in a human-readable format.
// It concatenates the dates and their corresponding statuses into a single string.
//
// # Returns
//
//   - string: A formatted string containing the dates and their corresponding statuses.
func (msr *MarketStatusResponse) String() string {
	dateParts := make([]string, len(msr.Date))
	for i, date := range msr.Date {
		dateParts[i] = fmt.Sprintf("%v", date)
	}
	statusParts := "nil"
	if len(msr.Status) > 0 {
		statusSlice := make([]string, len(msr.Status))
		for i, status := range msr.Status {
			statusSlice[i] = fmt.Sprintf("%q", status)
		}
		statusParts = "[" + strings.Join(statusSlice, ", ") + "]"
	}
	return fmt.Sprintf("MarketStatusResponse{Date: [%s], Status: %s}", strings.Join(dateParts, ", "), statusParts)
}

// Unpack transforms the MarketStatusResponse into a slice of MarketStatusReport, facilitating the analysis or processing
// of market status data in a structured format. This method is particularly useful when there's a need to iterate over
// market statuses, perform conditional checks, or when preparing the data for display. It ensures that each market status
// entry is paired with its corresponding date, converting UNIX timestamps to time.Time objects and mapping status strings
// to boolean open/closed indicators.
//
// # Returns
//
//   - []MarketStatusReport: A slice of MarketStatusReport, each representing a market status entry with its date and open/closed status.
//   - error: An error indicating issues with data consistency, such as mismatched slice lengths, or any other processing error.
//
// # Notes
//
//   - The method assumes that the lengths of the Date and Status slices in the MarketStatusResponse are equal. An error is returned if this is not the case.
func (msr *MarketStatusResponse) Unpack() ([]MarketStatusReport, error) {
	if len(msr.Date) != len(msr.Status) {
		return nil, fmt.Errorf("date and status slices are not of the same length")
	}

	var marketStatuses []MarketStatusReport
	for i, date := range msr.Date {
		status := strings.ToLower(msr.Status[i])
		marketStatus := MarketStatusReport{
			Date:   time.Unix(date, 0),
			Open:   status == "open",
			Closed: status == "closed",
		}
		marketStatuses = append(marketStatuses, marketStatus)
	}

	return marketStatuses, nil
}

// GetOpenDates identifies and returns all dates when the market was reported as open. This method is particularly useful for analyzing market activity over a period, allowing users to focus on days when trading was possible.

// # Returns
//
//   - []time.Time: A slice of time.Time objects, each representing a date when the market was open.
//   - error: An error object indicating issues encountered while unpacking the MarketStatusResponse.
//
// # Notes
//
//   - This method relies on the Unpack function to interpret the MarketStatusResponse. Any errors in unpacking will be propagated.
func (msr *MarketStatusResponse) GetOpenDates() ([]time.Time, error) {
	marketStatuses, err := msr.Unpack()
	if err != nil {
		return nil, err
	}

	var openDates []time.Time
	for _, marketStatus := range marketStatuses {
		if marketStatus.Open {
			openDates = append(openDates, marketStatus.Date)
		}
	}

	return openDates, nil
}

// GetClosedDates identifies and returns all dates when the market was reported as closed. This method is useful for analyzing market activity over a period, allowing users to focus on days when trading was not possible.
//
// # Returns
//
//   - []time.Time: A slice of time.Time objects, each representing a date when the market was closed.
//   - error: An error object indicating issues encountered while unpacking the MarketStatusResponse.
//
// # Notes
//
//   - This method relies on the Unpack function to interpret the MarketStatusResponse. Any errors in unpacking will be propagated.
func (msr *MarketStatusResponse) GetClosedDates() ([]time.Time, error) {
	marketStatuses, err := msr.Unpack()
	if err != nil {
		return nil, err
	}

	var closedDates []time.Time
	for _, marketStatus := range marketStatuses {
		if marketStatus.Closed {
			closedDates = append(closedDates, marketStatus.Date)
		}
	}

	return closedDates, nil
}

// GetDateRange calculates and returns the date range covered by the MarketStatusResponse. This method is primarily used
// when a user needs to determine the span of dates over which market status data is available, allowing for analysis
// of market trends within a specific timeframe.
//
// # Returns
//
//   - *dates.DateRange: A pointer to a DateRange object encapsulating the earliest and latest dates found in the MarketStatusResponse.
//   - error: An error object if there's an issue identifying the earliest or latest date within the MarketStatusResponse.
//
// # Notes
//
//   - This method relies on the dates.Earliest and dates.Latest functions to compute the date range. Any errors encountered
//     by these functions will be returned to the caller.
func (msr *MarketStatusResponse) GetDateRange() (*dates.DateRange, error) {
	// Use the Earliest and Latest functions to find the earliest and latest dates
	earliest, err := dates.Earliest(msr.Date)
	if err != nil {
		return nil, err
	}

	latest, err := dates.Latest(msr.Date)
	if err != nil {
		return nil, err
	}

	// Create a new DateRange using NewDateRange function
	dr, err := dates.NewDateRange(earliest, latest)
	if err != nil {
		return nil, err
	}

	return dr, nil
}

// MarketStatusReport encapsulates the operational status of a market on a specific date.
//
// # Generated By
//
//   - MarketStatusResponse.Unpack(): Generates a slice of []MarketStatusReport instances from a MarketStatusResponse.
//
// # Methods
//
//   - String() string: Provides a string representation of the MarketStatusReport.
//
// # Notes
//
//   - This struct is used to convey whether a market is open or closed on a particular date.
//   - The 'Open' and 'Closed' fields are mutually exclusive.
type MarketStatusReport struct {
	Date   time.Time `json:"date"`
	Open   bool      `json:"open"`
	Closed bool      `json:"closed"`
}

// String returns a string representation of the MarketStatusReport.
//
// # Returns
//
//   - string: A string representation of the MarketStatusReport.
func (ms MarketStatusReport) String() string {
	return fmt.Sprintf("MarketStatusReport{Date: %v, Open: %v, Closed: %v}", dates.TimeString(ms.Date), ms.Open, ms.Closed)
}
