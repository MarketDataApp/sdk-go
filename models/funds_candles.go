package models

import (
	"encoding/json"
	"fmt"
	"sort"
	"time"

	"github.com/MarketDataApp/sdk-go/helpers/dates"
	"github.com/iancoleman/orderedmap"
)

// FundCandlesResponse encapsulates the data structure for the JSON response of mutual fund candles data. It includes
// detailed information about fund prices at different times, such as opening, closing, highest, and lowest prices,
// along with the trading volume. For version 2 candles, it optionally includes the Volume Weighted Average Price (VWAP)
// and the number of trades.
//
// # Generated By
//
//   - FundCandlesRequest.Packed(): Sends a FundCandlesRequest and unmarshals the response into FundCandlesResponse.
//
// # Methods
//
//   - Unpack() ([]Candle, error): Converts a FundCandlesResponse into a slice of Candle.
//   - String() string: Returns a string representation of the FundCandlesResponse.
//   - IsValid() bool: Checks if a FundCandlesResponse is valid.
//   - Validate() error: Validates a FundCandlesResponse.
//   - MarshalJSON() ([]byte, error): Marshals a FundCandlesResponse into JSON.
//   - UnmarshalJSON(data []byte) error: Unmarshals JSON into a FundCandlesResponse.
//   - GetDateRange() (dates.DateRange, error): Returns the date range of a FundCandlesResponse.
//   - PruneOutsideDateRange(dr dates.DateRange) error: Removes data points outside a specified date range.
//
// # Notes
//
//   - The optional fields VWAP and N are only available for version 2 candles.
//   - The Date field uses UNIX timestamps to represent the date and time of each candle.
type FundCandlesResponse struct {
	Date   []int64    `json:"t"`              // Date holds UNIX timestamps for each candle.
	Open   []float64  `json:"o"`              // Open holds the opening prices for each candle.
	High   []float64  `json:"h"`              // High holds the highest prices reached in each candle.
	Low    []float64  `json:"l"`              // Low holds the lowest prices reached in each candle.
	Close  []float64  `json:"c"`              // Close holds the closing prices for each candle.
}

// Unpack converts a FundCandlesResponse into a slice of Candle. This method is primarily used to transform the aggregated
// mutual fund candles data from a structured response format into a more accessible slice of individual candle data. It allows users
// to iterate over or manipulate the mutual fund candle data more conveniently in their applications.
//
// # Returns
//
//   - []Candle: A slice of Candle containing the unpacked data from the FundCandlesResponse.
//   - error: An error if the slices within FundCandlesResponse are not of equal length, indicating inconsistent data.
//
// # Notes
//
//   - This method ensures that all slices within the FundCandlesResponse have the same length before unpacking to prevent data misalignment.
func (fcr *FundCandlesResponse) Unpack() ([]Candle, error) {
	if err := fcr.checkForEqualSlices(); err != nil {
		return nil, err
	}

	var fundCandles []Candle
	for i := range fcr.Date {
		fundCandle := Candle{
			Date:   time.Unix(fcr.Date[i], 0),
			Open:   fcr.Open[i],
			High:   fcr.High[i],
			Low:    fcr.Low[i],
			Close:  fcr.Close[i],
		}
		fundCandles = append(fundCandles, fundCandle)
	}
	return fundCandles, nil
}

// String generates a string representation of a FundCandlesResponse. This method is primarily used for logging or debugging purposes, allowing developers to easily view the contents of a FundCandlesResponse in a human-readable format.
//
// # Returns
//
//   - string: A string representation of the FundCandlesResponse.
//
// # Notes
//
//   - Mutual fund candles do not include Volume, VWAP, or transaction quantities (n).
func (f *FundCandlesResponse) String() string {
	return fmt.Sprintf("FundCandlesResponse{Date: %v, Open: %v, High: %v, Low: %v, Close: %v}",
		f.Date, f.Open, f.High, f.Low, f.Close)
}

// checkTimeInAscendingOrder checks if the times in a FundCandlesResponse are in ascending order.
//
// # Returns
//
//   - An error if the times are not in ascending order.
func (f *FundCandlesResponse) checkTimeInAscendingOrder() error {
	for i := 1; i < len(f.Date); i++ {
		if f.Date[i] < f.Date[i-1] {
			return fmt.Errorf("time is not in ascending order")
		}
	}
	return nil
}

// IsValid determines the validity of a FundCandlesResponse. It is primarily used to ensure that the data within the response adheres to expected formats and logical constraints before further processing or analysis.
//
// # Returns
//
//   - bool: Indicates whether the FundCandlesResponse is valid.
//
// # Notes
//
//   - This method should be used to prevent the propagation of invalid or corrupt data within applications that rely on mutual fund candle information.
func (f *FundCandlesResponse) IsValid() bool {
	if err := f.Validate(); err != nil {
		return false
	}
	return true
}

// Validate checks the integrity and consistency of a FundCandlesResponse. It ensures that the data within the response adheres to expected formats and logical constraints, such as time being in ascending order and all data slices being of equal length. This method is crucial for preventing the propagation of invalid or corrupt data within an application that relies on mutual fund candle information.
//
// # Returns
//
//   - error: An error if the FundCandlesResponse is not valid. A nil error indicates a valid FundCandlesResponse.
//
// # Notes
//
//   - This method performs multiple checks in parallel to efficiently validate the response.
func (f *FundCandlesResponse) Validate() error {
	// Create a channel to handle errors
	errChan := make(chan error, 3)

	// Run each validation function concurrently
	go func() { errChan <- f.checkTimeInAscendingOrder() }()
	go func() { errChan <- f.checkForEqualSlices() }()
	go func() { errChan <- f.checkForEmptySlices() }()

	// Check for errors from the validation functions
	for i := 0; i < 3; i++ {
		if err := <-errChan; err != nil {
			return err
		}
	}

	return nil
}

// checkForEqualSlices checks if all slices in a FundCandlesResponse have the same length.
//
// # Returns
//
//   - An error if the slices have different lengths.
func (f *FundCandlesResponse) checkForEqualSlices() error {
	// Create a slice of the lengths of the Date, Open, High, Low, and Close slices
	lengths := []int{
		len(f.Date),
		len(f.Open),
		len(f.High),
		len(f.Low),
		len(f.Close),
	}

	// Check if all lengths in the lengths slice are equal
	// If they are not, return an error
	for i := 1; i < len(lengths); i++ {
		if lengths[i] != lengths[0] {
			return fmt.Errorf("arrays are not of the same length")
		}
	}

	// If all lengths are equal, return nil
	return nil
}

// checkForEmptySlices checks if any of the slices in a FundCandlesResponse are empty.
//
// # Returns
//
//   - An error if any of the slices are empty.
func (f *FundCandlesResponse) checkForEmptySlices() error {
	// Check if any of the slices are empty
	if len(f.Date) == 0 || len(f.Open) == 0 || len(f.High) == 0 || len(f.Low) == 0 || len(f.Close) == 0 {
		return fmt.Errorf("one or more slices are empty")
	}

	// If none of the slices are empty, return nil
	return nil
}

// MarshalJSON converts a FundCandlesResponse instance into its JSON representation.
// This method is primarily used for encoding the FundCandlesResponse into a JSON format that can be easily transmitted or stored.
// It organizes the mutual fund candle data into a structured JSON format, ensuring compatibility with systems that consume JSON.
//
// # Returns
//
//   - []byte: The JSON-encoded representation of the FundCandlesResponse.
//   - error: An error object that will be non-nil if the marshaling process encounters any issues.
func (f *FundCandlesResponse) MarshalJSON() ([]byte, error) {
	// Create a new ordered map
	o := orderedmap.New()

	// Set the "s" key to "ok"
	o.Set("s", "ok")

	// Set the "t", "o", "h", "l", "c" keys to the corresponding slices in the struct
	o.Set("t", f.Date)
	o.Set("o", f.Open)
	o.Set("h", f.High)
	o.Set("l", f.Low)
	o.Set("c", f.Close)

	// Marshal the ordered map into a JSON object and return the result
	return json.Marshal(o)
}

// UnmarshalJSON converts JSON data into a FundCandlesResponse instance. This method is essential for decoding JSON data received from external sources into a structured FundCandlesResponse object. It facilitates the easy consumption of JSON data by converting it into a more manageable Go struct. Additionally, it performs validation on the unmarshalled data to ensure it meets the expected format and constraints of a FundCandlesResponse.
//
// # Parameters
//
//   - []byte: The JSON-encoded data that needs to be converted into a FundCandlesResponse.
//
// # Returns
//
//   - error: An error object that will be non-nil if the unmarshaling process encounters any issues or if the validation of the unmarshalled data fails.
//
// # Notes
//
//   - This method leverages an auxiliary struct to prevent infinite recursion during the unmarshalling process.
func (f *FundCandlesResponse) UnmarshalJSON(data []byte) error {
	// Define a secondary type to prevent infinite recursion
	type Alias FundCandlesResponse
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(f),
	}

	// Unmarshal the data into our auxiliary struct
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	// Call the Validate method
	if err := f.Validate(); err != nil {
		// Print the contents of the auxiliary struct only if validation fails
		fmt.Println(f.String())
		return err
	}

	// Return nil if everything went well
	return nil
}

// GetDateRange calculates and returns the date range covered by the FundCandlesResponse. This method is useful for determining the span of time that the mutual fund candle data encompasses, allowing users to understand the temporal scope of the data they are working with.
//
// # Returns
//
//   - dates.DateRange: The range of dates covered by the FundCandlesResponse.
//   - error: An error if calculating the date range fails.
//
// # Notes
//
//   - This method is particularly useful when filtering data based on specific time frames.
func (f *FundCandlesResponse) GetDateRange() (dates.DateRange, error) {
	// Pass the slice of timestamps directly to Earliest and Latest
	min, err1 := dates.Earliest(f.Date)
	max, err2 := dates.Latest(f.Date)
	if err1 != nil || err2 != nil {
		return dates.DateRange{}, fmt.Errorf("error calculating date ranges: %v, %v", err1, err2)
	}

	// Use NewDateRange to create a new DateRange instance
	dr, err := dates.NewDateRange(min, max)
	if err != nil {
		return dates.DateRange{}, err
	}

	return *dr, nil
}

// pruneIndices removes data points at specified indices from a FundCandlesResponse.
//
// # Parameters
//
//   - indices: A variadic list of integers specifying the indices of data points to remove.
func (f *FundCandlesResponse) pruneIndices(indices ...int) {
	sort.Sort(sort.Reverse(sort.IntSlice(indices)))
	for _, index := range indices {
		if index < 0 || index >= len(f.Date) {
			continue
		}
		f.Date = append(f.Date[:index], f.Date[index+1:]...)
		f.Open = append(f.Open[:index], f.Open[index+1:]...)
		f.High = append(f.High[:index], f.High[index+1:]...)
		f.Low = append(f.Low[:index], f.Low[index+1:]...)
		f.Close = append(f.Close[:index], f.Close[index+1:]...)
	}
}

// pruneBeforeIndex removes data points before a specified index from a FundCandlesResponse.
//
// # Parameters
//
//   - index: The index before which all data points will be removed.
func (m *FundCandlesResponse) pruneBeforeIndex(index int) {
	if index+1 < len(m.Date) {
		m.Date = m.Date[index+1:]
		m.Open = m.Open[index+1:]
		m.High = m.High[index+1:]
		m.Low = m.Low[index+1:]
		m.Close = m.Close[index+1:]
	}
}

// pruneAfterIndex removes data points after a specified index from a FundCandlesResponse.
//
// # Parameters
//
//   - index: The index after which all data points will be removed.
//
// # Returns
//
//   - An error if the index is out of range.
func (m *FundCandlesResponse) pruneAfterIndex(index int) error {
	// Check if the index is within the range of the slices
	if index < 0 || index >= len(m.Date) {
		return fmt.Errorf("index %d out of range (0-%d)", index, len(m.Date)-1)
	}

	// Prune the Date, Open, High, Low, Close slices
	m.Date = m.Date[:index]
	m.Open = m.Open[:index]
	m.High = m.High[:index]
	m.Low = m.Low[:index]
	m.Close = m.Close[:index]

	return nil
}

// PruneOutsideDateRange method is used to filter out data points from a FundCandlesResponse that fall outside a specified date range.
// This method is essential when the user needs to focus on analyzing fund candle data within a specific period,
// thereby excluding irrelevant data points that do not fall within the desired date range.
//
// # Parameters
//
//   - dr dates.DateRange: A struct specifying the start and end dates for the range within which data points should be retained.
//
// # Returns
//
//   - error: An error if pruning fails, otherwise nil.
//
// # Notes
//
//   - This method modifies the FundCandlesResponse in place, removing any data points that are outside the specified date range.
func (f *FundCandlesResponse) PruneOutsideDateRange(dr dates.DateRange) error {
	// Validate all timestamps
	validTimestamps, invalidTimestamps := dr.ValidateTimestamps(f.Date...)
	fmt.Println("Valid timestamps: ", validTimestamps)
	fmt.Println("Invalid timestamps: ", invalidTimestamps)

	// Loop through invalid timestamps, get index and prune
	for _, invalidTimestamp := range invalidTimestamps {
		for {
			index := f.getIndex(invalidTimestamp)
			if index >= len(f.Date) || f.Date[index] != invalidTimestamp {
				break
			}
			f.pruneIndex(index)
		}
	}

	return nil
}

// getIndex is a method on the FundCandlesResponse struct that searches for a given timestamp within the Date slice.
//
// # Parameters
//
//   - t int64: The timestamp to search for within the Date slice.
//
// # Returns
//
//   - int: The index of the first occurrence of the provided timestamp within the Date slice.
//     If the timestamp is not found, it returns the length of the Date slice.
func (f *FundCandlesResponse) getIndex(t int64) int {
	for i, timestamp := range f.Date {
		if timestamp == t {
			return i
		}
	}
	return len(f.Date)
}

// pruneIndex removes the element at the specified index from all slices within the FundCandlesResponse struct.
//
// # Parameters
//
//   - index int: The index of the element to remove from each slice.
//
// # Returns
//
//   - error: An error if the index is out of range. Otherwise, returns nil.
func (f *FundCandlesResponse) pruneIndex(index int) error {
	if index < 0 || index >= len(f.Date) {
		return fmt.Errorf("index %d out of range (0-%d)", index, len(f.Date)-1)
	}

	// Remove the element at the index from the Date, Open, High, Low, and Close slices
	f.Date = append(f.Date[:index], f.Date[index+1:]...)
	f.Open = append(f.Open[:index], f.Open[index+1:]...)
	f.High = append(f.High[:index], f.High[index+1:]...)
	f.Low = append(f.Low[:index], f.Low[index+1:]...)
	f.Close = append(f.Close[:index], f.Close[index+1:]...)

	return nil
}

// CombineFundCandles merges two FundCandlesResponse structs into a single one.
// It checks if the versions of the two structs are the same, ensures there is no time overlap between them,
// and then combines their data into a new FundCandlesResponse struct. If the versions do not match or there is a time overlap,
// it returns an error.
//
// # Parameters
//
//   - *FundCandlesResponse: The first FundCandlesResponse struct to be combined.
//   - *FundCandlesResponse: The second FundCandlesResponse struct to be combined.
//
// # Returns
//
//   - *FundCandlesResponse: A pointer to the newly combined FundCandlesResponse struct.
//   - error: An error if the versions do not match, there is a time overlap, or the combined struct fails validation.
func CombineFundCandles(f1, f2 *FundCandlesResponse) (*FundCandlesResponse, error) {
	// Check for time overlap using the DoesNotContain method
	f1DateRange, err1 := f1.GetDateRange()
	if err1 != nil {
		return nil, fmt.Errorf("error getting date range from f1: %v", err1)
	}
	f2DateRange, err2 := f2.GetDateRange()
	if err2 != nil {
		return nil, fmt.Errorf("error getting date range from f2: %v", err2)
	}
	if !f1DateRange.DoesNotContain(f2DateRange) && !f2DateRange.DoesNotContain(f1DateRange) {
		return nil, fmt.Errorf("time ranges overlap: f1 range %s, f2 range %s", f1DateRange.String(), f2DateRange.String())
	}

	// Combine the structs
	combined := &FundCandlesResponse{
		Date:   append(f1.Date, f2.Date...),
		Open:   append(f1.Open, f2.Open...),
		High:   append(f1.High, f2.High...),
		Low:    append(f1.Low, f2.Low...),
		Close:  append(f1.Close, f2.Close...),
	}

	// Validate the combined struct
	if err := combined.Validate(); err != nil {
		return nil, fmt.Errorf("combineFundCandles validation failed: %v", err)
	}

	// Dereference the old structs to free memory
	f1 = nil
	f2 = nil

	return combined, nil
}
